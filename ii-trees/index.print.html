




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Welcome! This page is the main page for the Trees Section. This section has chapters which cover:
Basic Trees Recursive Trees Tries Binary Trees ">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Trees :: CC 315 Textbook">
    <meta name="twitter:description" content="Welcome! This page is the main page for the Trees Section. This section has chapters which cover:
Basic Trees Recursive Trees Tries Binary Trees ">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/ii-trees/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Trees :: CC 315 Textbook">
    <meta property="og:description" content="Welcome! This page is the main page for the Trees Section. This section has chapters which cover:
Basic Trees Recursive Trees Tries Binary Trees ">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Trees :: CC 315 Textbook">
    <meta itemprop="description" content="Welcome! This page is the main page for the Trees Section. This section has chapters which cover:
Basic Trees Recursive Trees Tries Binary Trees ">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2021-10-26T09:51:18-05:00">
    <meta itemprop="wordCount" content="24">
    <title>Trees :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/ii-trees/" rel="canonical" type="text/html" title="Trees :: CC 315 Textbook">
    <link href="/cc315/ii-trees/index.xml" rel="alternate" type="application/rss+xml" title="Trees :: CC 315 Textbook">
    <link href="/cc315/ii-trees/tele.html" rel="alternate" type="text/html" title="Trees :: CC 315 Textbook">
    <link href="/cc315/ii-trees/embed.html" rel="alternate" type="text/html" title="Trees :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1719522770" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1719522770" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/print.css?1719522770" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1719522770" rel="stylesheet">
    <script src="/cc315/js/variant.js?1719522770"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1719522770" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/ii-trees/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Trees</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/i-strings/1-strings-and-stringbuilders/05-summary/" title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/ii-trees/2-introduction-trees/" title="Introduction to Trees (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 5</div>

<h1 id="trees">Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for the Trees Section. This section has chapters which cover:</p>
<ol start="2">
<li>Basic Trees</li>
<li>Recursive Trees</li>
<li>Tries</li>
<li>Binary Trees</li>
</ol>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Trees</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 10</div>

<h1 id="introduction-to-trees">Introduction to Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Introduction to Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introduction to Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=As_g6_ozRkU">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/1-introduction/video/">Video Materials</a></p>
<p>For the next data structure in the course, we will cover trees, which are used to show hierarchical data. Trees can have many shapes and sizes and there is a wide variety of data that can be organized using them. Real world data that is appropriate for trees can include: family trees, management structures, file systems, biological classifications, anatomical structures and much more.</p>
<hr>
<p>We can look at an example of a tree and the relationships they can show. Consider this file tree; it has folders and files in folders.
<a href="#R-image-fb3d20c28d0f4a7961842080e812a18a" class="lightbox-link"><img alt="File Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2FileTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb3d20c28d0f4a7961842080e812a18a"><img alt="File Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2FileTree.png"></a></p>
<p>If we wanted to access the file <code>elm.txt</code>, we would have to follow this file path: <code>Foo/B/Q/E/elm.txt</code>. We can similarly store the file structure as a tree like we below. As before, if we wanted to get to the file <code>elm.txt</code> we would navigate the tree in the order: <code>Foo -&gt; B -&gt; Q -&gt; E -&gt; elm.txt</code>. As mentioned before, trees can be used on very diverse data sets; they are not limited to file trees!
<a href="#R-image-98cd143c7c3402659922d637ef16c0cd" class="lightbox-link"><img alt="File Tree as Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_FileTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-98cd143c7c3402659922d637ef16c0cd"><img alt="File Tree as Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_FileTree.png"></a></p>
<h2 id="what-are-trees">What are trees?</h2>
<p>In the last module we talked about strings which are a linear data structure. To be explicit, this means that the elements in a string form a line of characters. A tree, by contrast, is a <strong>hierarchal structure</strong> which is utilized best in multidimensional data. Going back to our file tree example, folders are not limited to just one file, there can be multiple files contained in a single folder- thus making it multidimensional.</p>
<p>Consider the string &ldquo;abc123&rdquo;; this is a linear piece of data where there is exactly one character after another. We can use trees to show linear data as well.
<a href="#R-image-c35261af58d2db65b915a142f052d7af" class="lightbox-link"><img alt="String as Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_String.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c35261af58d2db65b915a142f052d7af"><img alt="String as Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_String.png"></a></p>
<p>While trees <em>can</em> be used for linear data, it would be excessive and inefficient to implement them for single strings. In an upcoming module, we will see how we can use trees to represent any number of strings! For example, this tree below contains 7 words: &lsquo;a&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;any&rsquo;, &lsquo;all&rsquo;, and &lsquo;alp&rsquo;.
<a href="#R-image-87fde7959b04941b0d9500d38510cc31" class="lightbox-link"><img alt="Small Words" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87fde7959b04941b0d9500d38510cc31"><img alt="Small Words" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a></p>
<p>In the next sections, we will discuss the properties of a tree data structure and how we would design one ourselves. Once we have a good understanding of trees and the properties of trees, we will implement our own.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introduction</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="general-terms">General Terms</h1>


<a href="https://www.youtube.com/watch?v=JvbXXm_KEDY">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/2-general-terms/video/">Video Materials</a></p>
<p>To get ourselves comfortable in working with trees, we will outline some standard vocabulary. Throughout this section, we will use the following tree as a guiding example for visualizing the definitions.<br>
<a href="#R-image-39b1f76535100a24ee75f564976a1c07" class="lightbox-link"><img alt="Blank" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Blank.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39b1f76535100a24ee75f564976a1c07"><img alt="Blank" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Blank.png"></a></p>
<h2 id="definitions">Definitions</h2>
<ul>
<li><code>Node</code> - the general term for a structure which contains an item, such as a character or even another data structure.</li>
<li><code>Edge</code> - the connection between two nodes. In a tree, the edge will be pointing in a downward direction.</li>
</ul>
<p><a href="#R-image-f70d697b371b56cbd93c4a4a59f3f59f" class="lightbox-link"><img alt="Nodes and Edges" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_NodeEdge.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f70d697b371b56cbd93c4a4a59f3f59f"><img alt="Nodes and Edges" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_NodeEdge.png"></a>
This tree has five edges and six nodes. There is no limit to the number of nodes in a tree. The only stipulation is that the tree is <code>fully connected</code>. This means that there cannot be disjoint portions of the tree. We will look at examples in the next section.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A rule of thumb for discerning trees is this: if you imagine holding the tree up by the root and gravity took effect, then all edges must be pointing downward. If an edge is pointing upward, we will have a <code>cycle</code> within our structure so it will not be a tree.</p>
</div>
</div>
<hr>
<ul>
<li><code>Root</code> - the topmost node of the tree</li>
</ul>
<p><a href="#R-image-4f8a023f22cba0e5e99b14a90dbe4dda" class="lightbox-link"><img alt="Root" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Root.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4f8a023f22cba0e5e99b14a90dbe4dda"><img alt="Root" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Root.png"></a>
To be a tree, there must be exactly one root. Having multiple roots, will result in a <code>cycle</code> or a tree that is not <code>fully connected</code>. In short, a <code>cycle</code> is a loop in the tree.</p>
<hr>
<ul>
<li><code>Parent</code> - a node with an edge that connects to another node further from the root. We can also define the root of a tree with respect to this definition; <code>Root</code>: a node with no parent.</li>
<li><code>Child</code> - a node with an edge that connects to another node closer to the root.
<ul>
<li>In a general tree, the children of a node are an unordered set. There is not a fixed or defined order for generic trees.
<a href="#R-image-a9c996891c3d54cd11d367602c837c5b" class="lightbox-link"><img alt="Parent and Child" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a9c996891c3d54cd11d367602c837c5b"><img alt="Parent and Child" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild1.png"></a>
<a href="#R-image-b6f9788f948ae0fac4f078c154eb50f0" class="lightbox-link"><img alt="Parent and Child" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b6f9788f948ae0fac4f078c154eb50f0"><img alt="Parent and Child" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild2.png"></a>
In a tree, child nodes must have exactly one parent node. If a child node has more than one parent, then a <code>cycle</code> will occur. If there is a node without a parent node, then this is necessarily the root node. There is no limit to the number of child nodes a parent node can have, but to be a parent node, the node must have at least one child node.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>Leaf</code> - a node with no children.
<a href="#R-image-99e38f4919e25ced28b090625d924977" class="lightbox-link"><img alt="Leaf" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Leaf.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-99e38f4919e25ced28b090625d924977"><img alt="Leaf" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Leaf.png"></a>
This tree has four leaves. There is no limit to how many leaves can be in a tree.</li>
</ul>
<hr>
<ul>
<li><code>Degree</code>
<ul>
<li><code>Degree of a node</code> - the number of children a node has. The degree of a leaf is zero.</li>
<li><code>Degree of a tree</code> - the number of children the root of the tree has.
<a href="#R-image-acbb6291a1c26000221f04860f622b79" class="lightbox-link"><img alt="Degree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Degree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acbb6291a1c26000221f04860f622b79"><img alt="Degree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Degree.png"></a>
The degree of the nodes are shown as the values on the nodes in this example. The degree of the tree is equal to the degree of the root. Thus, the degree for this tree is 2.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>A <code>tree</code> is defined recursively. This means that each child of the root is the root of another tree and the children of those are roots to trees as well. Again, this is a recursive definition so it will continue to the leaves. The leaves are also trees with just a single node as the root.<br>
<a href="#R-image-ff620c9f247c4d40aed18b3f7f596cda" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff620c9f247c4d40aed18b3f7f596cda"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a>
In our example tree, we have six trees. Each tree is outlined in a red dashed circle:
<ul>
<li>the main tree,
<ul>
<li>the tree off the left of the main root,
<ul>
<li>the tree off the left of this root,</li>
<li>the tree in the center of this root,</li>
<li>the tree off the right of this root, and</li>
</ul>
</li>
<li>the tree off the right of the main root with a single node</li>
</ul>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of General Terms</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="what-makes-a-tree-a-tree">What Makes a Tree a Tree</h1>


<a href="https://www.youtube.com/watch?v=zZ7vDmZEEIo">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/3-what-makes-trees/video/">Video Materials</a></p>
<p>Trees can come in many shapes and sizes. There are, however some constraints to making a valid tree.</p>
<ul>
<li>A tree has a single root</li>
<li>A child has exactly one parent</li>
<li>A tree is fully connected (IE a single tree)</li>
<li>A tree has no cycles (IE no loops)</li>
</ul>
<h2 id="valid-trees">Valid Trees</h2>
<p>Any combination of the following represents a valid tree:</p>
<ul>
<li>
<p>A tree with a single node; just a root,
<a href="#R-image-8bbbe831e86adeb0d605cb353a7e9ff4" class="lightbox-link"><img alt="Single" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Simple.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8bbbe831e86adeb0d605cb353a7e9ff4"><img alt="Single" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Simple.png"></a></p>
</li>
<li>
<p>A tree where each node has a single child, or
<a href="#R-image-12a24f514dc159d913561f758a84ee37" class="lightbox-link"><img alt="Linear" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Linear.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-12a24f514dc159d913561f758a84ee37"><img alt="Linear" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Linear.png"></a></p>
</li>
<li>
<p>A tree where nodes have many children.
<a href="#R-image-c310a935572317f0a709afd61232d11e" class="lightbox-link"><img alt="Linear" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Wide.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c310a935572317f0a709afd61232d11e"><img alt="Linear" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Wide.png"></a></p>
</li>
</ul>
<h2 id="invalid-trees">Invalid Trees</h2>
<p>Below are some examples of invalid trees.</p>
<ul>
<li>
<p>A cycle
<a href="#R-image-7acd38065f31e688b1a1fb4ca50089a6" class="lightbox-link"><img alt="Cycle" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7acd38065f31e688b1a1fb4ca50089a6"><img alt="Cycle" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle.png"></a>
Again, cycles are essentially loops that occur in our tree. In this example, we see that our leaf has two parents. One way to determine whether your data structure has a cycle is if there is more than one way to get from the root to any node.</p>
</li>
<li>
<p>A cycle
<a href="#R-image-5092dfbaf6969b2d98c4d5e9b2ff2bf0" class="lightbox-link"><img alt="Cycle" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5092dfbaf6969b2d98c4d5e9b2ff2bf0"><img alt="Cycle" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle2.png"></a>
Here we can see another cycle. In this case, the node immediately after the root has two parents, which is a clue that a cycle exists. Another test</p>
</li>
<li>
<p>Two Roots
<a href="#R-image-5f59bb80af2c014c603f9cc1869fcfcc" class="lightbox-link"><img alt="Two Roots" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_TwoRoots.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f59bb80af2c014c603f9cc1869fcfcc"><img alt="Two Roots" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_TwoRoots.png"></a>
Trees must have a single root. In this instance, it may look like we have a tree with two roots. Working through this, we also see that the node in the center has two parents.</p>
</li>
<li>
<p>Two Trees
<a href="#R-image-0cedc3945cf7f380a6e66a39bffa7019" class="lightbox-link"><img alt="Double Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_DoubleTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0cedc3945cf7f380a6e66a39bffa7019"><img alt="Double Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_DoubleTree.png"></a>
This example would be considered two trees, not a tree with two parts. In this figure, we have two fully connected components. Since they are not connected to each other, this is not a single tree.</p>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of What Makes a Tree a Tree</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-i">MyTree I</h1>


<a href="https://www.youtube.com/watch?v=y02_6lWMVnQ">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/4-uml/video/">Video Materials</a></p>
<p>Along with understanding how trees work, we want to also be able to implement a tree of our own. We will now outline key components of a tree class.</p>
<hr>
<h3 id="mytree">MyTree</h3>
<p>Recall that trees are defined recursively so we can build them from the leaves up where each leaf is a tree itself. Each tree will have three properties: the item it contains as an object, its parent node of type MyTree, and its children as a list of MyTrees. Upon instantiation of a new MyTree, we will set the item value and initialize the parent node to None and the children to an empty list of type MyTree.
<a href="#R-image-d491d3afa941c26ebb1e80c83ce01202" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/tree_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d491d3afa941c26ebb1e80c83ce01202"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/tree_uml.png"></a></p>
<p>Suppose that we wanted to construct the following tree.
<a href="#R-image-fedd72e340c07715681bfda36a22d635" class="lightbox-link"><img alt="Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fedd72e340c07715681bfda36a22d635"><img alt="Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.png"></a>
We would start by initializing each node as a tree with no parent, no children, and the item in this instance would be the characters. Then we build it up level by level by add the appropriate children to the respective parent.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Disclaimer:</strong> This implementation will not prevent all cycles. In the next module, we will introduce steps to prevent cycles and maintain true tree structures.</p>
</div>
</div>
<hr>
<h3 id="finding-a-child">Finding a child</h3>
<p>In this method, we will take a value as input and then check if that value is the item of a child of the current node. If the value is not the item for any of the node&rsquo;s children then we should return none.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FINDCHILD(VALUE)
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        IF CHILD&#39;s ITEM is VALUE
</span></span><span class="line"><span class="cl">            return  CHILD
</span></span><span class="line"><span class="cl">    return NONE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="getting--children-item-parent-or-degree">Getting  children, item, parent, or degree</h3>
<p>Each of these will be rather straight forward; children, item, and parent are all attributes of our node, so we can have a getter function that returns the respective values. The slightly more involved task will be getting the degree. Recall that the degree of a node is equal to the number of children. Thus, we can simply count the number of children and return this number for the degree.</p>
<hr>
<h3 id="checking-node-type">Checking node type</h3>
<p>We will have two functions to check the node type: one to determine if the node is a leaf and one to determine if it is a root. The definition of a leaf is a node that has no children. Thus, to check if a node is a leaf, we can simply check if the number of children is equal to zero. Similarly, since the definition of a root is a node with no parent, we can check that the parent attribute of the node is None.</p>
<hr>
<h3 id="adding-a-child">Adding a child</h3>

<a href="https://www.youtube.com/watch?v=T5gy1Q7hx1w">YouTube Video</a>

<p>When we wish to add a child, we must fisrt make sure we are able to add the child.</p>
<ol>
<li>Check that the child is an instance of <code>MyTree</code></li>
<li>Make sure the child doesn&rsquo;t already have a parent</li>
<li>Make sure the child isn&rsquo;t already a child of the parent</li>
</ol>
<p>We will return true if the child was successfully added and false otherwise while raising the appropriate errors.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDCHILD(CHILD)
</span></span><span class="line"><span class="cl">    IF CHILD has PARENT
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    IF CHILD is CHILD of PARENT
</span></span><span class="line"><span class="cl">        return FALSE
</span></span><span class="line"><span class="cl">    ELSE
</span></span><span class="line"><span class="cl">        append CHILD to PARENT&#39;s children
</span></span><span class="line"><span class="cl">        set CHILD&#39;s parent to PARENT
</span></span><span class="line"><span class="cl">        return TRUE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As an example, lets walk through the process of building the tree above:</p>
<ol>
<li>Instantiate MyTree <code>a</code> with item &lsquo;A&rsquo;</li>
<li>Instantiate MyTree <code>b</code> with item &lsquo;B&rsquo;</li>
<li>Instantiate MyTree <code>c</code> with item &lsquo;C&rsquo;</li>
<li>Instantiate MyTree <code>d</code> with item &lsquo;D&rsquo;</li>
<li>Instantiate MyTree <code>e</code> with item &lsquo;E&rsquo;</li>
<li>Instantiate MyTree <code>f</code> with item &lsquo;F&rsquo;</li>
<li>Instantiate MyTree <code>g</code> with item &lsquo;G&rsquo;</li>
<li>Instantiate MyTree <code>h</code> with item &lsquo;H&rsquo;</li>
<li>Instantiate MyTree <code>i</code> with item &lsquo;I&rsquo;</li>
<li>Add child tree <code>g</code> to tree <code>d</code></li>
<li>Add child tree <code>h</code> to tree <code>d</code></li>
<li>Add child tree <code>i</code> to tree <code>d</code></li>
<li>Add child tree <code>e</code> to tree <code>b</code></li>
<li>Add child tree <code>f</code> to tree <code>b</code></li>
</ol>
<p>Once we have completed that, visually, we would have the tree above and in code we would have:</p>
<ul>
<li>MyTree <code>a</code> with parent_node = None, item = &lsquo;A&rsquo;, children = {<code>b</code>,<code>c</code>,<code>d</code>}</li>
<li>MyTree <code>b</code> with parent_node = <code>a</code>, item = &lsquo;B&rsquo;, children = {<code>e</code>,<code>f</code>}</li>
<li>MyTree <code>c</code> with parent_node = <code>a</code>, item = &lsquo;C&rsquo;, children = { }</li>
<li>MyTree <code>d</code> with parent_node = <code>a</code>, item = &lsquo;D&rsquo;, children = {<code>g</code>,<code>h</code>,<code>i</code>}</li>
<li>MyTree <code>e</code> with parent_node = <code>b</code>, item = &lsquo;E&rsquo;, children = { }</li>
<li>MyTree <code>f</code> with parent_node = <code>b</code>, item = &lsquo;F&rsquo;, children = { }</li>
<li>MyTree <code>g</code> with parent_node = <code>d</code>, item = &lsquo;G&rsquo;, children = { }</li>
<li>MyTree <code>h</code> with parent_node = <code>d</code>, item = &lsquo;H&rsquo;, children = { }</li>
<li>MyTree <code>i</code> with parent_node = <code>d</code>, item = &lsquo;I&rsquo;, children = { }</li>
</ul>
<p><strong>Note:</strong> When adding a child we must currently be at the node we want to be the parent. Much like when you want to add a file to a folder, you must specify exactly where you want it. If you don&rsquo;t, this could result in a wayward child.</p>
<hr>
<h3 id="removing-a-child">Removing a child</h3>

<a href="https://www.youtube.com/watch?v=QtfZIUMPrJY">YouTube Video</a>

<p>In the case of removing a child, we first need to check that the child we are attempting to remove is an instance of <code>MyTree</code>. We will return true if we successfully remove the child and false otherwise.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVECHILD(CHILD)
</span></span><span class="line"><span class="cl">    IF CHILD in PARENT&#39;S children
</span></span><span class="line"><span class="cl">        REMOVE CHILD from PARENT&#39;s children
</span></span><span class="line"><span class="cl">        SET CHILD&#39;s PARENT to NONE
</span></span><span class="line"><span class="cl">        return TRUE
</span></span><span class="line"><span class="cl">    ELSE
</span></span><span class="line"><span class="cl">        return FALSE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As with adding a child, we need to ensure that we are in the &lsquo;right place&rsquo; when attempting to remove a child. When removing a child, we are not &rsquo;erasing&rsquo; it, we are just cutting the tie from parent to child and child to parent. Consider removing <code>d</code> from <code>a</code>. Visually, we would have two disjoint trees, shown below:
<a href="#R-image-0ce31eb319ac049c958fde6c7946a7ca" class="lightbox-link"><img alt="Tree 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ce31eb319ac049c958fde6c7946a7ca"><img alt="Tree 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation2.png"></a></p>
<p>In code, we would have:</p>
<ul>
<li>MyTree <code>a</code> with parent_node = None, item = &lsquo;A&rsquo;, children = {<code>b</code>,<code>c</code>}</li>
<li>MyTree <code>b</code> with parent_node = <code>a</code>, item = &lsquo;B&rsquo;, children = {<code>e</code>,<code>f</code>}</li>
<li>MyTree <code>c</code> with parent_node = <code>a</code>, item = &lsquo;C&rsquo;, children = { }</li>
<li>MyTree <code>d</code> with parent_node = None, item = &lsquo;D&rsquo;, children = {<code>g</code>,<code>h</code>,<code>i</code>}</li>
<li>MyTree <code>e</code> with parent_node = <code>b</code>, item = &lsquo;E&rsquo;, children = { }</li>
<li>MyTree <code>f</code> with parent_node = <code>b</code>, item = &lsquo;F&rsquo;, children = { }</li>
<li>MyTree <code>g</code> with parent_node = <code>d</code>, item = &lsquo;G&rsquo;, children = { }</li>
<li>MyTree <code>h</code> with parent_node = <code>d</code>, item = &lsquo;H&rsquo;, children = { }</li>
<li>MyTree <code>i</code> with parent_node = <code>d</code>, item = &lsquo;I&rsquo;, children = { }</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of MyTree I</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this module we have introduce vocabulary related to trees and what makes a tree a tree. To recap, we have introduced the following:</p>
<ul>
<li><code>Child</code> - a node with an edge that connects to another node closer to the root.</li>
<li><code>Degree</code>
<ul>
<li><code>Degree of a node</code> - the number of children a node has. The degree of a leaf is zero.</li>
<li><code>Degree of a tree</code> - the number of children the root of the tree has.</li>
</ul>
</li>
<li><code>Edge</code> - connection between two nodes. In a tree, the edge will be pointing in a downward direction.</li>
<li><code>Leaf</code> - a node with no children.</li>
<li><code>Node</code> - the general term for a structure which contains an item, such as a character or even another data structure.</li>
<li><code>Parent</code> - a node with an edge that connects to another node further from the root. We can also define the root of a tree with respect to this definition;</li>
<li><code>Root</code> - the topmost node of the tree; a node with no parent.</li>
</ul>
<p>Now we will work on creating our own implementation of a tree. These definitions will serve as a resource to us when we need refreshing on meanings; feel free to refer back to them as needed.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 15</div>

<h1 id="tree-traversal">Tree Traversal</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Tree Traversal</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Tree Traversal</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>

<p>In the last module, we covered the underlying vocabulary of trees and how we can implement our own tree. To recall, we covered: node, edge, root, leaf, parent, child, and degree.</p>
<p>For this module we will expand on trees and gain a better understanding of how powerful trees can be. As before, we will use the same tree throughout the module for a guiding visual example.</p>
<p><a href="#R-image-7f7731fde8ed320b0f1e968541abe01a" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f7731fde8ed320b0f1e968541abe01a"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-i">Terms I</h1>


<a href="https://www.youtube.com/watch?v=uSagfd4L2D8">YouTube Video</a>

<p>Many of the terms used in trees relate to terms used in family trees. Having this in mind can help us to better understand some of the terminology involved with abstract trees. Here we have a sample family tree.
<a href="#R-image-febd9f56c4ed5f96f0a59aa36fe0dd3b" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-febd9f56c4ed5f96f0a59aa36fe0dd3b"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>
<ul>
<li><code>Ancestor</code> - The ancestors of a node are those reached from child to parent relationships. We can think of this as our parents and our parent&rsquo;s parents, and so on.
<ul>
<li>Let&rsquo;s look at all of the ancestors of each of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s ancestors: <u>Uzzi, Joe, Myra</u>. This is because, <strong>Uzzi</strong> is the parent of Ava, <strong>Joe</strong> is the parent of Uzzi, and <strong>Myra</strong> is the parent of Joe. Try to work out the following and click the name to reveal the ancestors.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>Zia, Myra</u> - **Zia** is the parent of Uma and **Myra** is the parent of Zia. </details>
  <details><summary markdown="span">Myra:</summary><u>None</u> - Myra does not have a parent node.</details>
  <details><summary markdown="span">Raju:</summary> <u>Myra</u> - **Myra** is the parent of Raju.</details>
  <details><summary markdown="span">Bev:</summary> <u>Uzzi, Joe, Myra</u> - **Uzzi** is the parent of Bev, **Joe** is the parent of Uzzi, and **Myra** is the parent of Joe.</details>
</li>
</ul>
</li>
<li><code>Descendant</code> - The descendants of a node are those reached from parent to child relationships. We can think of this as our children and our children&rsquo;s children and so on.
<ul>
<li>Let&rsquo;s look at all of the descendants of each of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s descendants: <u>None</u>. Ava has no child nodes and thus, no descendants. Try to work out the following and click the name to reveal the descendants.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>Ang</u> - **Ang** is the child of Uma</details>
  <details><summary markdown="span">Myra:</summary><u>Raju, Joe, Zia, Uzzi, Bert, Uma, Bev, Ava, Ang, Isla, Eoin</u> - All of the nodes in a tree will be descendants of the root. To work it out: **Raju, Joe** and **Zia** are the children of Myra, **Uma** is the child of Zia, **Ang** is the child of Uma, and we can work the rest out for Joe's children. </details>
  <details><summary markdown="span">Raju:</summary><u>None</u> - Raju has no child nodes.</details>
  <details><summary markdown="span">Bev:</summary><u>Isla, Eoin</u> - **Isla** is the child of Bev and **Eoin** is the child of Isla.</details>
</li>
</ul>
</li>
<li><code>Siblings</code> - Nodes which share the same parent
<ul>
<li>We can think about the siblings of all of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s siblings: <u>Bev</u> - Uzzi is the parent node of Ava; Uzzi has two child nodes, Ava and <strong>Bev</strong>. Try to work out the following and click the name to reveal the siblings.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>None</u> - Zia is the parent node of Uma; Zia has only one child node, Uma.</details>
  <details><summary markdown="span">Myra:</summary><u>None</u> - Myra is the root and thus does not have a parent node resulting in no siblings.</details>
  <details><summary markdown="span">Raju:</summary><u>Joe, Zia</u> -  Myra is the parent node of Raju; Myra has three child nodes, **Joe**, **Zia**, and Raju</details>
  <details><summary markdown="span">Bev:</summary><u>Ava</u> - Uzzi is the parent node of Bev; Uzzi has two child nodes, Bev and **Ava**.</details>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursion-refresh">Recursion Refresh</h1>


<a href="https://www.youtube.com/watch?v=7ee0C0v2L1w">YouTube Video</a>

<p><a href="#R-image-04e296bb907aecede5905d29b32ea2dc" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04e296bb907aecede5905d29b32ea2dc"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<p>In principle, the recursive case breaks the problem down into smaller portions until we reach the base case. Recursion presents itself in many ways when dealing with trees.</p>
<p>Trees are defined recursively with the base case being a single node. Then we recursively build the tree up. With this basis for our trees, we can define many properties using recursion rather effectively.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-ii">Terms II</h1>


<a href="https://www.youtube.com/watch?v=86uWWXaanCo">YouTube Video</a>

<p>We can describe the sizes of trees and position of nodes using different terminology, like level, depth, and height.</p>
<p><a href="#R-image-f96b44317340952d0a13df9c54f93de3" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f96b44317340952d0a13df9c54f93de3"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>
<ul>
<li><code>Level</code> - The level of a node characterizes the distance between the node and the root. The root of the tree is considered level 1. As you move away from the tree, the level increases by one.
<ul>
<li>For our family tree example, what nodes are in the following levels? Think about the answer and then click corresponding arrow.
  <details><summary markdown="span">Level 1:</summary><u>Myra</u> - Level 1 is always the root</details>
  <details><summary markdown="span">Level 2:</summary><u>Raju, Joe, Zia</u> - These are the nodes which are 1 edge away from the root.</details>
  <details><summary markdown="span">Level 3:</summary><u>Uzzi, Bert, Uma</u> - These are the nodes which are 2 edges away from the root. </details>
  <details><summary markdown="span">Level 4:</summary><u>Bev, Ava, Ang</u> - These are the nodes which are 3 edges away from the root. </details>
  <details><summary markdown="span">Level 5:</summary><u>Isla</u> - This is the only node which is 4 edges away from the root. </details>
  <details><summary markdown="span">Level 6:</summary><u>Eoin</u> - This is the only node which is 5 edges away from the root. </details>
</li>
</ul>
</li>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero. <code>Level</code> and <code>depth</code> are related in that: <code>level = 1 + depth</code>.
<ul>
<li>For our family tree example, what nodes have the following depths?
  <details><summary markdown="span">Depth 0:</summary><u>Myra</u> - The root will always be at depth 0.</details>
  <details><summary markdown="span">Depth 1:</summary><u>Raju, Joe, Zia</u> - These are the nodes which are 1 edge away from the root.</details>
  <details><summary markdown="span">Depth 2:</summary><u>Uzzi, Bert, Uma</u> - These are the nodes which are 2 edge away from the root.</details>
  <details><summary markdown="span">Depth 3:</summary><u>Bev, Ava, Ang</u> - These are the nodes which are 3 edge away from the root.</details>
  <details><summary markdown="span">Depth 4:</summary><u>Isla</u> - This is the only node which is 4 edges away from the root.</details>
  <details><summary markdown="span">Depth 5:</summary><u>Eoin</u> - This is the only node which is 5 edges away from the root.</details>
</li>
</ul>
</li>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.
<ul>
<li>For our family tree example, what nodes have the following heights?
  <details><summary markdown="span">Height 0:</summary><u>Raju, Eoin, Ava, Bert, Ang</u> - The leaves always have height 0. </details>
  <details><summary markdown="span">Height 1:</summary><u>Isla, Uma</u> - `Isla -> Eoin`  and `Uma -> Ang` </details>
  <details><summary markdown="span">Height 2:</summary><u>Bev, Zia</u> - `Bev -> Isla -> Eoin` and `Zia -> Uma -> Ang` </details>
  <details><summary markdown="span">Height 3:</summary><u>Uzzi</u> - `Uzzi -> Bev -> Isla -> Eoin`</details>
  <details><summary markdown="span">Height 4:</summary><u>Joe</u> - `Joe -> Uzzi -> Bev -> Isla -> Eoin`</details>
  <details><summary markdown="span">Height 5:</summary><u>Myra</u> - `Myra -> Joe -> Uzzi -> Bev -> Isla -> Eoin`</details>
</li>
</ul>
</li>
<li><code>Height of a Tree</code> - The height of a tree is equal to the height of the root.
<ul>
<li>Our family tree would have height 5</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-iii">Terms III</h1>


<a href="https://www.youtube.com/watch?v=Jurg4tZKCwI">YouTube Video</a>

<p>When working with multidimensional data structures, we also need to consider how they would be stored in a linear manner. Remember, pieces of data in computers are linear sequences of binary digits. As a result, we need a standard way of storing trees as a linear structure.</p>
<p><a href="#R-image-9bbc9fa07c0e8d5adff6c7222fb9470f" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bbc9fa07c0e8d5adff6c7222fb9470f"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png"></a></p>
<ul>
<li>
<p><code>Path</code> - a path is a sequence of nodes and edges, which connect a node with its descendant. We can look at some paths in the tree above:</p>
<ul>
<li>From <code>Q</code> to <code>O</code>: <code>QRO</code></li>
</ul>
  <details><summary markdown="span">From `Q` to `Y`:</summary>`QWY`</details>
  <details><summary markdown="span">From `R` to `P`:</summary>`RP`</details>
</li>
<li>
<p><code>Traversal</code> is a general term we use to describe going through a tree. The following traversals are defined recursively.</p>
</li>
</ul>
<h2 id="preorder-traversal">Preorder Traversal</h2>
<ol>
<li>Access the root, record its value.</li>
<li>Run the preorder traversal each of the children</li>
</ol>

<a href="https://www.youtube.com/watch?v=JthdRshLJP0">YouTube Video</a>

<ul>
<li>The <code>Pre</code> refers to the root, meaning the root goes before the children.</li>
<li>Remember: Root Children</li>
<li>For the above tree, the preorder traversal could result in: <code>QWYUERIOPTA</code>
<a href="#R-image-d10cc6aca9e90f246a271328056c99de" class="lightbox-link"><img alt="Preorder Traversal" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Preorder.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d10cc6aca9e90f246a271328056c99de"><img alt="Preorder Traversal" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Preorder.gif"></a></li>
</ul>
<h2 id="postorder-traversal">Postorder Traversal</h2>
<ol>
<li>Run the postorder traversal on each of the children</li>
<li>Access the root, record its value</li>
</ol>

<a href="https://www.youtube.com/watch?v=eEZmsK-loUU">YouTube Video</a>

<ul>
<li>The <code>Post</code> refers to the root, meaning the root goes after the children.</li>
<li>Remember: Children Root</li>
<li>For the above tree, the postorder traversal could result in: <code>YUWEIOPRATQ</code>
<a href="#R-image-6449c7232da04e5552a152a3ca116b3e" class="lightbox-link"><img alt="Postorder Traversal" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Postorder.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6449c7232da04e5552a152a3ca116b3e"><img alt="Postorder Traversal" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Postorder.gif"></a></li>
</ul>
<hr>
<p>When we talk about traversals for general trees we have used the phrase &rsquo;the traversal <em>could</em> result in&rsquo;. We would like to expand on why &lsquo;could&rsquo; is used here. Each of these general trees are the same but their traversals could be different. The key concept in this is that for a general tree, the children are an unordered set of nodes; they do not have a defined or fixed order. The relationships that are fixed are the parent/child relationships.
<a href="#R-image-17ba51bea2422ff831cef49ef5a9676c" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17ba51bea2422ff831cef49ef5a9676c"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png"></a>
<a href="#R-image-a37c761c29bd0d2436b6e4ceea502759" class="lightbox-link"><img alt="Traversal Tree1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a37c761c29bd0d2436b6e4ceea502759"><img alt="Traversal Tree1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal1.png"></a>
<a href="#R-image-2b76ad5015095107981ba22723106ce4" class="lightbox-link"><img alt="Traversal Tree2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b76ad5015095107981ba22723106ce4"><img alt="Traversal Tree2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal2.png"></a></p>
<table>
<thead>
<tr>
<th>Tree</th>
<th>Preorder</th>
<th>Postorder</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tree 1</td>
<td><code>QWYUERIOPTA</code></td>
<td><code>YUWEIOPRATQ</code></td>
</tr>
<tr>
<td>Tree 2</td>
<td><code>QETARIOPWUY</code></td>
<td><code>EATIOPRUYWQ</code></td>
</tr>
<tr>
<td>Tree 3</td>
<td><code>QROPITAEWUY</code></td>
<td><code>OPIRATEUYWQ</code></td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-i">MyTree Recursive I</h1>

<p>Again, we want to be able to implement a working version of a tree. From the last module, we had functions to add children, remove children, get attributes, and instantiate MyTree. We will now build upon that implementation to create a true tree.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<hr>
<h3 id="mytree-with-recursion">MyTree with recursion</h3>
<p>Recall that in the previous module, we were not yet able to enforce the no cycle rule. We will now enforce this and add other tree functionality.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Disclaimer:</strong> In the previous module we had a disclaimer that stated our implementation would not prevent cycles. The following functions and properties will implement recursion. Thus, we can maintain legal tree structures!</p>
</div>
</div>
<p>In the first module, we discussed how we can define trees recursively, meaning a tree consists of trees. We looked at the following example. Each red dashed line represented a distinct tree, thus we had five trees within the largest tree making six trees in total.
<a href="#R-image-7f017b0c0b6d92ad46b3dca0bb311b42" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f017b0c0b6d92ad46b3dca0bb311b42"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a></p>
<p>We will use our existing implementation from the first module. Now to make our tree recursive, we will include more getter functions as well as functions for traversals and defining node relationships.</p>
<p><a href="#R-image-c7f5b04934654c2f691f2f4f57c3ad0e" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/rec_tree_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7f5b04934654c2f691f2f4f57c3ad0e"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/rec_tree_uml.png"></a></p>
<hr>
<h3 id="get-depth-height-size-and-root">Get depth, height, size, and root</h3>
<p>We can define each of these recursively.</p>

<a href="https://www.youtube.com/watch?v=3mFKHgv6bhk">YouTube Video</a>

<h5 id="get-depth">Get Depth</h5>
<ul>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero.</li>
</ul>
<p>We can define the depth of a node recursively:</p>
<ul>
<li>Base case: we are at the root and the depth is zero</li>
<li>Recursive case: for any other node, the depth is 1 plus the depth of the parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETDEPTH()
</span></span><span class="line"><span class="cl">    if ROOT
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return 1 + PARENT.GETDEPTH()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-height">Get Height</h5>
<ul>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.</li>
</ul>
<p>We can define the height of a node recursively:</p>
<ul>
<li>Base case: we are at the leaf and the height is zero</li>
<li>Recursive case: for any other node, return 1 plus the maximum height of its children</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETHEIGHT()
</span></span><span class="line"><span class="cl">    if LEAF
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        MAX = 0
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            CURR<span class="nb">_</span>HEIGHT = CHILD.GETHEIGHT()
</span></span><span class="line"><span class="cl">            if CURR<span class="nb">_</span>HEIGHT &gt; MAX
</span></span><span class="line"><span class="cl">                MAX = CURR<span class="nb">_</span>HEIGHT
</span></span><span class="line"><span class="cl">        return 1 + MAX
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-root">Get Root</h5>
<ul>
<li><code>Root</code> - the topmost node of the tree; a node with no parent.</li>
</ul>
<p>We can define returning the root recursively:</p>
<ul>
<li>Base case: we are at the root so return it</li>
<li>Recursive case: for any other node, return the root of the nodes parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETROOT()
</span></span><span class="line"><span class="cl">    if ISROOT()
</span></span><span class="line"><span class="cl">        return this tree
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.GETROOT()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-size">Get Size</h5>
<p>We define the size of a tree as the total number of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETSIZE()
</span></span><span class="line"><span class="cl">    SIZE = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        SIZE += CHILD.GETSIZE()
</span></span><span class="line"><span class="cl">    return SIZE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="find-a-value">Find a Value</h4>
<p>To find a value within our tree, we will traverse down a branch as far as we can until we find the value. This will return the tree that has the value as the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FIND(VALUE)
</span></span><span class="line"><span class="cl">	if ITEM is VALUE
</span></span><span class="line"><span class="cl">		return this node
</span></span><span class="line"><span class="cl">	for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">		FOUND = CHILD.FIND(VALUE)
</span></span><span class="line"><span class="cl">		if FOUND is not NONE
</span></span><span class="line"><span class="cl">			return FOUND
</span></span><span class="line"><span class="cl">	return NONE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-ii">MyTree Recursive II</h1>

<h3 id="determine-relationships-ancestor-descendant-sibling">Determine relationships (Ancestor, Descendant, Sibling)</h3>
<p>We can determine many relationships within the tree. For example, given a node is it an ancestor of another node, a descendant, or a sibling?</p>

<a href="https://www.youtube.com/watch?v=hr73fsl8RzM">YouTube Video</a>

<h5 id="is-ancestor">Is Ancestor?</h5>
<p>For this function, we are asking: is this node an ancestor of the current instance? In this implementation, we will start at our instance and <strong>work down</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at a leaf so return false.</li>
<li>Recursive case: run the method from each of the children of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at LEAF
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            FOUND = CHILD.ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">            if FOUND
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-descendant">Is Descendant?</h5>
<p>For this function, we are asking: is this node a descendant of the current instance? In this implementation, we will start at our instance and <strong>work up</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at the root so return false.</li>
<li>Recursive case: run the method from the parent of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return PARENT.ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-sibling">Is Sibling?</h5>
<p>For this function, we are asking: is this node a sibling of the current instance? To determine this, we can get the parent of the current instance and then get the parents children. Finally, we check if the node in question is in that set of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISSIBLING(TREE)
</span></span><span class="line"><span class="cl">    if TREE in PARENT&#39;s CHILDREN
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="lowest-common-ancestor">Lowest common ancestor</h3>
<p>In any tree, we can say that the root is a common ancestor to all of the nodes. We would like to get more information about the common ancestry of two nodes. For this function, we are asking: which node is the first place where this instance and the input node&rsquo;s ancestries meet? Similar to our ISDESCENDANT, we will work our way up the tree to find the point where they meet</p>
<ul>
<li>Base case: we are at our tree so return the tree OR we are at an ancestor of our tree so return the instance OR we are at the root so return nothing</li>
<li>Recursive case: run the method from the parent.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return TREE
</span></span><span class="line"><span class="cl">    else if ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">        return instance
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return NONE
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="path-from-the-root">Path from the root</h3>
<p>This function will generate the path which goes from the root to the current instance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    if NOT ROOT
</span></span><span class="line"><span class="cl">        PARENT.PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    append ITEM to PATH
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-iii">MyTree Recursive III</h1>

<h3 id="traversals">Traversals</h3>
<p>In this module we have talked about two traversals: preorder and postorder. Both of these are defined recursively and the prefix refers to the order of the root.</p>
<h5 id="preorder">Preorder</h5>
<p>In a preorder traversal, first we access the root and then run the preorder traversal on the children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PREORDER(RESULT)
</span></span><span class="line"><span class="cl">    append ITEM to RESULT
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.PREORDER(RESULT)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="postorder">Postorder</h5>
<p>In a postorder traversal, first we run the postorder traversal on the children then we access the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   append ITEM to RESULT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this section, we discussed more terminology related to trees as well as tree traversals. To recap the new vocabulary:</p>
<ul>
<li><code>Ancestor</code> - The ancestors of a node are those reached from child to parent relationships. We can think of this as our parents and the parents of our parents, and so on.</li>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero. <code>Level</code> and <code>depth</code> are related in that: <code>level = 1 + depth</code>.</li>
<li><code>Descendant</code> - The descendants of a node are those reached from parent to child relationships. We can think of this as our children and our children&rsquo;s children and so on.</li>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.</li>
<li><code>Height of a Tree</code> - The height of a tree is equal to the height of the root.</li>
<li><code>Level</code> - The level of a node characterizes the distance the node is from the root. The root of the tree is considered level 1. As you move away from the tree, the level increases by one.</li>
<li><code>Path</code> - a sequence of nodes and edges which connect a node with its descendant.</li>
<li><code>Siblings</code> - Nodes which share the same parent</li>
<li><code>Traversal</code> is a general term we use to describe going through a tree. The following traversals are defined recursively.
<ul>
<li>Preorder Traversal (Remember: Root Children):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the children</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Children Root):
<ol>
<li>Run the postorder traversal on the children</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 20</div>

<h1 id="tries">Tries</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Tries</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Tries</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tries">Tries</h1>


<a href="https://www.youtube.com/watch?v=BNA3tbURiZk">YouTube Video</a>

<p>Recall that in the beginning of our discussions about trees, we looked at a small tree which contained seven strings as motivation for trees. This was a small example of a trie (pronounced &rsquo;try&rsquo;) which is a type of tree that can represent sets of words.
<a href="#R-image-9c67db900d77ef7545a210124e0ffab9" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9c67db900d77ef7545a210124e0ffab9"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a></p>
<p>Tries can be used for a variety of tasks ranging from leisurely games to accessibility applications. One example is &lsquo;Boggle&rsquo; where players have a set of random letters and try to make as many words as possible. To code this game, we could create a vocabulary with a trie then traverse it to determine if players have played legal words. We can also use tries to provide better typing accessibility. Users could type a few letters of a word and our code could traverse the trie and suggest what letters or words they may be trying to enter.</p>
<p>A trie is a type of tree with some special characteristics. First it must follow the guidelines of being a tree:</p>
<ul>
<li>There must be a single root,</li>
<li>Each child node has a single parent node,</li>
<li>It must be fully connected (no disjoint parts), and</li>
<li>There can be no cycles (no loops).</li>
</ul>
<p>The special characteristics for tries are:</p>
<ul>
<li>By starting at the root and traversing parent to children relationships we can build user-defined words, and</li>
<li>Each node has a boolean property to indicate if it is the end of a word.</li>
</ul>
<p>In this course, we will display nodes with two circles as a convention to show which nodes are the end of words. Looking at this small trie as an example, we can determine which words are contained in our trie.
<a href="#R-image-7ea7ca22ed24175c761bac67189dbf8a" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ea7ca22ed24175c761bac67189dbf8a"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a>
We start at the root, which will typically be an empty string, and traverse to a double lined node. <code>&quot;&quot; -&gt; a -&gt; l -&gt; l</code>. Thus, the word &lsquo;all&rsquo; is contained in our trie. Words within our tries do not have to end at leaves. For example, we can traverse <code>&quot;&quot; -&gt; a</code> for the word &lsquo;a&rsquo;. We say this trie &lsquo;contains&rsquo; seven words: &lsquo;a&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;any&rsquo;, &lsquo;all&rsquo;, and &lsquo;alp&rsquo;.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="trie-example">Trie Example</h1>

<p>Let&rsquo;s look at another example of a trie. Here we have a larger trie. Think about how many words are captured by the tree; click the tree to see how many!</p>
<details><summary markdown="span">![Trie Example](images/4/4Trie_Example.png)</summary> This tree contains **12** words: 'ate', 'an', 'and', 'ant', 'app', 'apple', 'cat', 'can', 'cup', 'by', 'be', and 'been'. </details>
<p>While the &lsquo;a&rsquo;, &lsquo;at&rsquo;, and &lsquo;bee&rsquo; are words in the English language, they are not recognized by our trie. Depending on what the user intended, this could be by design. When we build our tries, users will input words that are valid for their vocabulary. Tries are not limited to the English language and can be created for any vocabulary.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-i">MyTrie I</h1>

<p>To implement our own trie, we will build off of MyTree that we built recursively. We will add an attribute to our tree to reinforce which nodes are words and which ones are not.</p>
<p><a href="#R-image-53ec4f036b50aad3722e780e0aaa159c" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/trie_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53ec4f036b50aad3722e780e0aaa159c"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/trie_uml.png"></a></p>
<h3 id="attributes">Attributes</h3>
<p>We have the existing attributes of MyTree: parent, children, and item. For MyTrie, we introduce the boolean attribute <code>is_word</code> to delineate if our trie is a word.</p>
<h3 id="adding-a-word">Adding a Word</h3>

<a href="https://www.youtube.com/watch?v=kasaXiMbj9A">YouTube Video</a>

<p>To add a word to our trie, we traverse through the trie letter by letter. We can define this recursively.</p>
<ul>
<li>Base Case: length of the word is zero and it was already a word in our trie, return false (because we did not add the word) OR length of the word is zero and it is not already a word in our trie, set the boolean for the node at the end of the word to true and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string; if it does not exist create it, then run the add word function on the remainder of the string.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to true
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            NODE = new MyTrie with item equal FIRST
</span></span><span class="line"><span class="cl">            insert NODE into our existing trie 
</span></span><span class="line"><span class="cl">            CHILD = NODE
</span></span><span class="line"><span class="cl">        return CHILD.ADDWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="removing-a-word">Removing a Word</h3>

<a href="https://www.youtube.com/watch?v=ZcrqD8nlLjc">YouTube Video</a>

<p>Similar to adding a word, we traverse our trie letter by letter. Once we get to the end of the word set <code>is_word</code> to false. If the word ends at a leaf, we will remove the leaf (then if the second to last character is a leaf, we remove the leaf and so on). If the word does not end in a leaf, meaning another word uses that node, we will not remove the node.</p>
<ul>
<li>Base Case: length of the word is zero and it was not a word in our trie, return false (because we did not remove the word) OR length of the word is zero and it is  already a word in our trie, set the boolean for the node at the end of the word to false and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string, if that node does not exist, return false (because we did not remove the word). If the node does exist run remove word on the child for the remainder of the word. After that, if the node&rsquo;s <code>is_word</code> is false and it is a leaf, remove the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already not a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to false
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RET = CHILD.REMOVEWORD(REMAIN)
</span></span><span class="line"><span class="cl">            if CHILD is not a word AND CHILD is a leaf
</span></span><span class="line"><span class="cl">                REMOVECHILD(CHILD)
</span></span><span class="line"><span class="cl">            return RET
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="check-if-trie-contains-word">Check if trie contains word</h3>

<a href="https://www.youtube.com/watch?v=zG1aSR1iivI">YouTube Video</a>

<p>Again, we will traverse the trie letter by letter. Once we get to the last letter, we can return that nodes <code>is_word</code> attribute. There is a chance that somewhere in our word, the letter is not a child of the previous node. If that is the case, then we return false.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function CONTAINSWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        return `is<span class="nb">_</span>word`
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return CHILD.CONTAINSWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-ii">MyTrie II</h1>

<h3 id="getters">Getters</h3>

<a href="https://www.youtube.com/watch?v=su-hJ1CDY3M">YouTube Video</a>

<h4 id="getting-word-count">Getting word count</h4>
<p>For this function, we want to get the total number of words that are contained within our trie. We will fan out through all of the children and count all of the nodes that have their <code>is_word</code> attribute equal to true.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function WORDCOUNT()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        COUNT = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        COUNT += CHILD.WORDCOUNT()
</span></span><span class="line"><span class="cl">    return COUNT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-max-word-length">Get max word length</h4>
<p>Next, we want to get the longest word contained in our trie. To do this, we will recurse each child and find the maximum length of the child.</p>
<ul>
<li>Base Case: we are at a leaf and it is a word, return 0</li>
<li>Recursive Case: declare a maximum of -1 for a tracker and then for each child run the maximum word length function on it. If the value returned from the child is greater than our maximum tracker, set the tracker equal to the value. Once we have iterated all of the children, return the maximum tracker plus one.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function MAXWORD()
</span></span><span class="line"><span class="cl">    if LEAF and is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        MAX = -1
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            COUNT = CHILD.MAXWORD()
</span></span><span class="line"><span class="cl">            if COUNT greater than MAX
</span></span><span class="line"><span class="cl">                MAX = COUNT
</span></span><span class="line"><span class="cl">        return MAX + 1
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-completions">Get completions</h4>

<a href="https://www.youtube.com/watch?v=urFTpJwqRVY">YouTube Video</a>

<p>This function will act as an auto-complete utility of sorts. A user will input a string of characters and we will return all of the possible words that are contained in our trie. This will happen in two phases. First, we traverse the trie to get to the end of the input string (lines 1-12). The second portion then gets all of the words that are contained after that point in our trie (lines 14-21).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function COMPLETIONS(WORD)
</span></span><span class="line"><span class="cl">1.    if WORD length greater than 0
</span></span><span class="line"><span class="cl">2.        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">3.        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">4.        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">5.        if CHILD is none
</span></span><span class="line"><span class="cl">6.            return []
</span></span><span class="line"><span class="cl">7.        else
</span></span><span class="line"><span class="cl">8.            COMPLETES = CHILD.COMPLETIONS(REMAIN)
</span></span><span class="line"><span class="cl">9.            OUTPUT = []
</span></span><span class="line"><span class="cl">10.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">11.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">12.            return OUTPUT
</span></span><span class="line"><span class="cl">13.    else
</span></span><span class="line"><span class="cl">14.        OUTPUT = []
</span></span><span class="line"><span class="cl">15.        if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">16.            append ITEM to OUTPUT
</span></span><span class="line"><span class="cl">17.        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">18.            COMPLETES = CHILD.COMPLETIONS(&#34;&#34;)
</span></span><span class="line"><span class="cl">19.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">20.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">21.        reutrn OUTPUT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 25</div>

<h1 id="binary-trees">Binary Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Binary Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Binary Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-tree">Binary Tree</h1>


<a href="https://www.youtube.com/watch?v=FugxsgsFu9I">YouTube Video</a>

<p><a href="#R-image-00bcf2df3e2652d3adaf57cf7ee8977b" class="lightbox-link"><img alt="Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Tree_Binary.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-00bcf2df3e2652d3adaf57cf7ee8977b"><img alt="Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Tree_Binary.png"></a></p>
<p>A binary tree is a type of tree with some special conditions. First, it must follow the guidelines of being a tree:</p>
<ul>
<li>There must be single root,</li>
<li>each child node must have a single parent node,</li>
<li>it must be fully connected (no disjoint parts), and</li>
<li>there can be no cycles (no loops).</li>
</ul>
<p>The special conditions that we impose on binary trees are the following:</p>
<ul>
<li>Each node has at most 2 children (nodes can have 0, 1, or 2 children), and</li>
<li>unlike general trees, the children in a binary tree are not an unordered set. The children must be ordered such that:
<ul>
<li>all of the descendants in the left tree are less than the parent&rsquo;s value, and</li>
<li>all of the descendants in the right tree are greater than the parent&rsquo;s value</li>
</ul>
</li>
</ul>
<p>To reinforce these concepts, we will look at examples of binary trees and examples that are not binary trees.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-tree-examples">Binary Tree Examples</h1>


<a href="https://www.youtube.com/watch?v=8uSNprLBCpE">YouTube Video</a>

<hr>
<h3 id="valid-binary-trees">Valid Binary Trees</h3>
<p><a href="#R-image-bf6fdf5fba3a26e2e8f21bb02fb720c4" class="lightbox-link"><img alt="Single Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Single.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf6fdf5fba3a26e2e8f21bb02fb720c4"><img alt="Single Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Single.png"></a>
This is a valid binary tree. We have a single node, the root, with no children. As with general trees, binary trees are built recursively. Thus, each node and its child(ren) are trees themselves.</p>
<p><a href="#R-image-881cbb926fed47e4d03496e8f5b347ee" class="lightbox-link"><img alt="Unbalanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-881cbb926fed47e4d03496e8f5b347ee"><img alt="Unbalanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png"></a>
This is also a valid binary tree. All of the left children are less than their parent. The node with item &lsquo;10&rsquo; is also in the correct position as it is less than 12, 13, and 14 but greater than 9.</p>
<p><a href="#R-image-d35b59b27f1b4002f132e63bba3f562a" class="lightbox-link"><img alt="Balanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d35b59b27f1b4002f132e63bba3f562a"><img alt="Balanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png"></a>
We have the same nodes but our root is now 12 whereas before it was 14. This is also a valid binary tree.</p>
<p><a href="#R-image-7c975af70c928218b9093fde5a6f0e87" class="lightbox-link"><img alt="Alphabet Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Alpha.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c975af70c928218b9093fde5a6f0e87"><img alt="Alphabet Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Alpha.png"></a>
Here we have an example of a binary tree with alphabetical items. As long as we have items which have a predefined order, we can organize them using a binary tree.</p>
<hr>
<h3 id="invalid-binary-trees">Invalid Binary Trees</h3>
<p><a href="#R-image-aca4906e644346e7dc9aa546a8cb7872" class="lightbox-link"><img alt="Alphabet Non-Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_NOTAlpha.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aca4906e644346e7dc9aa546a8cb7872"><img alt="Alphabet Non-Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_NOTAlpha.png"></a>
We may be inclined to say that this is a binary tree: each node has 0, 1, or 2 children and amongst children and parent nodes, the left child is smaller than the parent and the right child is greater than the parent. However, in binary trees, all of the nodes in the left tree must be smaller than the root and all of the nodes in the right tree must be larger than the root. In this tree, <code>D</code> is out of place. Node <code>D</code> is less than node <code>T</code> but it is also less than node <code>Q</code>. Thus, node <code>D</code> must be on the right of node <code>Q</code>.</p>
<p><a href="#R-image-de4267d49551c41713c83998d2c1fda5" class="lightbox-link"><img alt="Too Many Children" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_ManyChildren.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de4267d49551c41713c83998d2c1fda5"><img alt="Too Many Children" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_ManyChildren.png"></a>
In this case, we do not have a binary tree. This does fit all of the criteria for being a tree but not the criteria for a binary tree. Nodes in binary trees can have at most 2 children. Node <code>30</code> has three children.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="traversals">Traversals</h1>


<a href="https://www.youtube.com/watch?v=TNkWt307y84">YouTube Video</a>

<p>In the first module we discussed two types of traversals: preorder and postorder. Within that discussion, we noted that for general trees, the preorder and postorder traversal may not be unique. This was due to the fact that children nodes are an unordered set.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>We are now working with binary trees which have a defined child order. As a result, the preorder and postorder traversals will be <strong>unique</strong>! These means that for a binary tree when we do a preorder traversal there is exactly one string that is possible. The same applies for postorder traversals as well.</p>
</div>
</div>
<p>Recall that these were defined as such:</p>
<ul>
<li>Preorder Traversal (Remember: Root Children):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the children</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Children Root):
<ol>
<li>Run the postorder traversal on the children</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
<p>Now for binary trees, we can modify their definitions to be more explicit:</p>
<ul>
<li>Preorder Traversal (Remember: Root Left Right):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the left child</li>
<li>Run the preorder traversal on the right child</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Left Right Root):
<ol>
<li>Run the postorder traversal on the left child</li>
<li>Run the postorder traversal on the right child</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
<p>Let&rsquo;s practice traversals on the following binary tree.
<a href="#R-image-fda8577c84307dbfb0d80cdd12d9a138" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fda8577c84307dbfb0d80cdd12d9a138"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Traversal.png"></a></p>
<h2 id="preorder-traversal">Preorder Traversal</h2>
<p><a href="#R-image-c6a96080a7ba6db01fa3f13ea61b7ea4" class="lightbox-link"><img alt="Preorder" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Pre.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c6a96080a7ba6db01fa3f13ea61b7ea4"><img alt="Preorder" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Pre.gif"></a></p>
<h2 id="postorder-traversal">Postorder Traversal</h2>
<p><a href="#R-image-2ab170ee94790c3f8fb210491a54152a" class="lightbox-link"><img alt="Postorder" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Post.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ab170ee94790c3f8fb210491a54152a"><img alt="Postorder" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Post.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="in-order-traversal">In-Order Traversal</h1>


<a href="https://www.youtube.com/watch?v=uyM6L6xqn_8">YouTube Video</a>

<p>Since we have fixed order on the children, we can introduce another type of traversal: in-order traversal.</p>
<ul>
<li>
<p>In-order Traversal:</p>
<ol>
<li>Run the in-order traversal on the left child</li>
<li>Access the root, write its value</li>
<li>Run the in-order traversal on the right child</li>
</ol>
<ul>
<li>Remember: Left Root Right</li>
</ul>
</li>
</ul>
<p><a href="#R-image-42f7588c465a7cbfca3faf3a1f58b849" class="lightbox-link"><img alt="In-order" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_In.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42f7588c465a7cbfca3faf3a1f58b849"><img alt="In-order" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_In.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mybinarytree">MyBinaryTree</h1>


<a href="https://www.youtube.com/watch?v=0U5EXtcHcsU">YouTube Video</a>

<p>Our implementation of binary trees will inherit from our MyTree implementation as binary trees are types of trees. Thus, MyBinaryTree will have the functionality of MyTree in addition to the following.</p>
<p><a href="#R-image-faf38c031bfd03a2a5a008d4dd581eb8" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/binary_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-faf38c031bfd03a2a5a008d4dd581eb8"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/binary_uml.png"></a></p>
<h2 id="attributes">Attributes</h2>
<p>The binary tree has two attributes</p>
<ul>
<li>Left Child: an instance of <code>MyBinaryTree</code>, the item should be less than the item of the parent.</li>
<li>Right Child: an instance of <code>MyBinaryTree</code>, the item should be greater than the item of the parent.</li>
</ul>
<h2 id="miscellaneous-functions">Miscellaneous Functions</h2>
<ul>
<li>
<p>Get Size</p>
<ul>
<li>Will override the <code>MyTree</code> size function. If the tree is empty then we return zero. If the tree is not empty then call the <code>MyTree</code> size function.</li>
</ul>
</li>
<li>
<p>Is Empty</p>
<ul>
<li>Will return true if the node we have called the function from is empty and false if otherwise.</li>
</ul>
</li>
<li>
<p>To Sorted List</p>
<ul>
<li>Will get all of the nodes items and sort them</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function TOSORTEDLIST()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    if there`s LEFTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + LEFTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    LIST = LIST + ITEM
</span></span><span class="line"><span class="cl">    if there`s RIGHTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + RIGHTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="inserting-children">Inserting Children</h1>


<a href="https://www.youtube.com/watch?v=qFalue24DdE">YouTube Video</a>

<p>When inserting children to a binary tree, we must take some special considerations. All of the node items in the left tree must be less than the parent node item and all of the node items in the right tree must be greater than the parent node item.</p>
<p>The general procedure for adding a child is the following:
<a href="#R-image-2e3fe8b8a13e3897196e831b2f9dd9e0" class="lightbox-link"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_AddFlowChart.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e3fe8b8a13e3897196e831b2f9dd9e0"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_AddFlowChart.png"></a></p>
<p>Suppose that we have the following tree and we want to add a node with item &lsquo;85&rsquo;. Click the binary tree to see the resulting tree.</p>
<details><summary markdown="span">![Tree To Add To](images/4/4Binary_Add.png)</summary> ![Tree Adding](images/4/4Binary_AddChild.gif) </details>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function INSERT(VALUE)
</span></span><span class="line"><span class="cl">    if node is empty:
</span></span><span class="line"><span class="cl">        set nodes item to value
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else if node.ITEM &gt; VALUE 
</span></span><span class="line"><span class="cl">            LC = node`s left child
</span></span><span class="line"><span class="cl">            if LC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.LEFTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return LC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RC = node`s right child
</span></span><span class="line"><span class="cl">            if RC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.RIGHTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return RC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="removing-children">Removing Children</h1>


<a href="https://www.youtube.com/watch?v=uyhC6GcyBW4">YouTube Video</a>

<p>Removing children is not as straightforward as inserting them. The general procedure for removing a child is to replace that nodes value with its smallest right descendant. First we will traverse the binary tree until we find the node with the value we are trying to remove (lines 18-32 below). Then we have three separate cases, discussed in detail below.</p>
<h2 id="removing-a-leaf">Removing a Leaf</h2>
<p>Removing a leaf is the most straightforward. We remove the value from the node and then sever the connection between parent and child. (lines 5-7 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>5</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove Leaf](images/4/4Bin_Remove.png)</summary> ![Result of Remove Leaf](images/4/4Bin_Remove2.png) </details>
<h2 id="removing-a-node-without-right-child">Removing a Node without Right Child</h2>
<p>When we remove a value from a node that does not have a right child, we cannot replace the value with the smallest right child. In this instance we will instead replace the value with the smallest left child then prune the tree to clean it up. Once we replace the value, we must switch the node&rsquo;s left child to be the right child in order to maintain proper binary tree structure. (lines 8-13 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>4</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove w/o RightChild](images/4/4Bin_Remove2.png)</summary> ![Result of Remove w/o RightChild](images/4/4Bin_Remove3.png) </details>
<h2 id="removing-a-node-with-right-child">Removing a Node with Right Child</h2>
<p>When we remove a value from a node that has a right child, we can replace the value with the nodes smallest right child. (Lines 14-17 Below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>10</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove with RightChild](images/4/4Bin_Remove.png)</summary> ![Result of Remove with RightChild](images/4/4Bin_Remove1.png) </details>
<h2 id="complete-pseudocode">Complete Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function REMOVE(VALUE)
</span></span><span class="line"><span class="cl">2.    if node is empty:
</span></span><span class="line"><span class="cl">3.        error
</span></span><span class="line"><span class="cl">4.    if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">5.        if node is a leaf
</span></span><span class="line"><span class="cl">6.            set node.ITEM to none
</span></span><span class="line"><span class="cl">7.            return TRUE
</span></span><span class="line"><span class="cl">8.        else if node has no right child
</span></span><span class="line"><span class="cl">9.            node.ITEM = LEFTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">10.           prune left-side
</span></span><span class="line"><span class="cl">11.           store left child in right child
</span></span><span class="line"><span class="cl">12.           set left child to none    
</span></span><span class="line"><span class="cl">13.           return TRUE
</span></span><span class="line"><span class="cl">14.        else
</span></span><span class="line"><span class="cl">15.            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">16.            prune right-side
</span></span><span class="line"><span class="cl">17.            return TRUE
</span></span><span class="line"><span class="cl">18.    else
</span></span><span class="line"><span class="cl">19.        if node.ITEM &gt; VALUE
</span></span><span class="line"><span class="cl">20.            if node has LEFTCHILD
</span></span><span class="line"><span class="cl">21.                SUCCESS = LEFTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">22.                prune left-side
</span></span><span class="line"><span class="cl">23.                return SUCCESS
</span></span><span class="line"><span class="cl">24.            else
</span></span><span class="line"><span class="cl">25.                return FALSE
</span></span><span class="line"><span class="cl">26.        else
</span></span><span class="line"><span class="cl">27.            if node has RIGHTCHILD
</span></span><span class="line"><span class="cl">28.                SUCCESS = RIGHTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">29.                prune right-side
</span></span><span class="line"><span class="cl">30.                return SUCCESS
</span></span><span class="line"><span class="cl">31.            else
</span></span><span class="line"><span class="cl">32.                return FALSE
</span></span><span class="line"><span class="cl">33. end function</span></span></code></pre></div><h2 id="extras-for-removal">Extras for Removal</h2>
<p>We use the pruning functions to severe the tie between parent and child nodes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNERIGHT()
</span></span><span class="line"><span class="cl">    if RIGHTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes RIGHTCHILD former RIGHTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if RIGHTCHLID is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNELEFT()
</span></span><span class="line"><span class="cl">    if LEFTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes LEFTCHILD former LEFTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if LEFTCHILD is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We use the remove smallest function to retrieve the smallest value in the binary tree which will replace our value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVESMALLEST()
</span></span><span class="line"><span class="cl">    if node has left child
</span></span><span class="line"><span class="cl">        REPLACEMENT = LEFTCHILD.REMOVESMALLEST
</span></span><span class="line"><span class="cl">        prune left-side
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        REPLACEMENT = node.ITEM
</span></span><span class="line"><span class="cl">        if node has right child
</span></span><span class="line"><span class="cl">            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">            prune right-side
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            node.ITEM = NONE
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="balance">Balance</h1>

<p><a href="#R-image-91ee92a23b29fd3c80b3fe776b1cb8e4" class="lightbox-link"><img alt="Unbalanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91ee92a23b29fd3c80b3fe776b1cb8e4"><img alt="Unbalanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png"></a>
While this is a valid binary tree, it is not balanced. Let&rsquo;s look at the following tree.</p>
<p><a href="#R-image-88bc3849baad1d5ecfe97d90f9882571" class="lightbox-link"><img alt="Balanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-88bc3849baad1d5ecfe97d90f9882571"><img alt="Balanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png"></a>
We have the same nodes but our root is now 12 whereas before it was 14. This is a valid binary tree. We call this a <code>balanced</code> binary tree. A balanced binary tree looks visually even amongst the left and right trees in terms of number of nodes.</p>
<p><strong>Note:</strong> Balancing is not necessary for a valid binary tree. It is, however, important in terms of time efficiency to have a balanced tree. For example, the number of actions when inserting an element is about the same as the number of levels in the tree. If we tried to add the value 11 into the unbalanced tree, we would traverse 5 nodes. If we tried to add the value 11 in to the balanced tree, we would traverse just 3 nodes.</p>
<p>We believe that balancing binary trees is out of the scope of this course. If you are interested in how we might balance a tree, feel free to check out these videos by Dr. Joshua Weese.</p>

<a href="https://www.youtube.com/watch?v=Em9-Rr6PEBc">YouTube Video</a>


<a href="https://www.youtube.com/watch?v=N7g8vn5sJoI">YouTube Video</a>


            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Emily Alfs
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/40efd19e59d94f2917b6e27c6fd41a830cbc25a3">Oct 26, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1719522770" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1719522770" defer></script>
    <script src="/cc315/js/theme.js?1719522770" defer></script>
  </body>
</html>
