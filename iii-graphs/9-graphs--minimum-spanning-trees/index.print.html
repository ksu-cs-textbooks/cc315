




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Welcome! This page is the main page for Graphs: Minimum Spanning Trees">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <meta name="twitter:description" content="Welcome! This page is the main page for Graphs: Minimum Spanning Trees">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/iii-graphs/9-graphs--minimum-spanning-trees/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <meta property="og:description" content="Welcome! This page is the main page for Graphs: Minimum Spanning Trees">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <meta itemprop="description" content="Welcome! This page is the main page for Graphs: Minimum Spanning Trees">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2021-10-21T16:59:20-05:00">
    <meta itemprop="wordCount" content="12">
    <title>Graphs: Minimum Spanning Trees :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/iii-graphs/9-graphs--minimum-spanning-trees/" rel="canonical" type="text/html" title="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/9-graphs--minimum-spanning-trees/index.xml" rel="alternate" type="application/rss+xml" title="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/9-graphs--minimum-spanning-trees/tele.html" rel="alternate" type="text/html" title="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/9-graphs--minimum-spanning-trees/embed.html" rel="alternate" type="text/html" title="Graphs: Minimum Spanning Trees :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1737135054" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1737135054" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/print.css?1737135054" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1737135054" rel="stylesheet">
    <script src="/cc315/js/variant.js?1737135054"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1737135054" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/iii-graphs/9-graphs--minimum-spanning-trees/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/iii-graphs/"><span itemprop="name">Iii-Graphs</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Graphs: Minimum Spanning Trees</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/iii-graphs/8-graphs--searching-and-traversing/6-in-practice/" title="In Practice (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/iii-graphs/9-graphs--minimum-spanning-trees/1-introduction/" title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 45</div>

<h1 id="graphs-minimum-spanning-trees">Graphs: Minimum Spanning Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Minimum Spanning Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Minimum Spanning Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=Rtlwi7b_PF8">YouTube Video</a>

<p>We will continue to work with graph algorithms in this module, specifically with finding minimum spanning trees (MST). MSTs have many real world applications such as:</p>
<ul>
<li>Electrical wiring,</li>
<li>Distribution networks,</li>
<li>Telecommunication networks, and</li>
<li>Network routing</li>
</ul>
<p>Suppose we were building an apartment complex and wanted to determine the most cost-effective wiring schema. Below, we have the possible construction costs for wiring apartment to apartment. Wiring vertically adjacent apartments is cheaper than wiring horizontally adjacent units and those closest to the power closet have lower costs as well.
<a href="#R-image-af4817f9bad7f8d9e3e4a5576f8e5ab7" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af4817f9bad7f8d9e3e4a5576f8e5ab7"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg"></a></p>
<p>To find the best possible solution, we would find the MST. The final wiring schema may look something like the figure below.
<a href="#R-image-dce76b7eaaa778ef9d1ac8c4b7e55598" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/mini_wire.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dce76b7eaaa778ef9d1ac8c4b7e55598"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/mini_wire.svg"></a></p>
<p>Determining a MST can result in lower costs and time used in many applications, especially logistics.
To properly define a minimum spanning tree, we will first introduce the concept of a spanning tree.</p>
<h2 id="spanning-trees">Spanning Trees</h2>
<p>A <strong>spanning tree</strong> for a graph is a subset of the graphs edges such that each node is visited once, no cycles are present, and there are no disconnected components.</p>
<p>Let&rsquo;s look at this graph as an example. We have five nodes and seven edges.</p>
<p><a href="#R-image-2ad6b433b9fab3bb3163a56168579c78" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ad6b433b9fab3bb3163a56168579c78"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below, we have valid examples of spanning trees. In each of the examples, we visit each node and there are no cycles. Recall that a cycle is a path in which the starting node and ending node are the same.</p>
<p><a href="#R-image-6ec78b9396b427855bc3bd10e94afc39" class="lightbox-link"><img alt="Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6ec78b9396b427855bc3bd10e94afc39"><img alt="Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>To be a spanning tree of a graph, it must:</p>
<ul>
<li><strong>span</strong> the graph, meaning all nodes must be visited, and</li>
<li>be a <strong>tree</strong>, meaning there are no cycles and no disconnected components.</li>
</ul>
<p>Further, we can imagine selecting a node in a spanning tree as the root and letting gravity take effect. This gives us a visual motivation as to why they are called spanning trees. In these examples, we have selected node A for the root for each of the spanning trees above.</p>
<p><a href="#R-image-c47867c30ef1a39353705787e019f67f" class="lightbox-link"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c47867c30ef1a39353705787e019f67f"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg"></a></p>
</div>
</div>
<h2 id="counterexamples">Counterexamples</h2>
<p>Below, we have invalid examples of spanning trees. In the left column, the examples are where all of the nodes are not connected in the same component. In the right column, the examples contain cycles. For example in the top right, we have the cycle <code>B-&gt;C-&gt;D-&gt;E-&gt;B</code></p>
<p><a href="#R-image-18546ecbb0e3e15241ec038d103d657d" class="lightbox-link"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18546ecbb0e3e15241ec038d103d657d"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="minimum-spanning-trees">Minimum Spanning Trees</h1>


<a href="https://www.youtube.com/watch?v=sMo3sTRoVrE">YouTube Video</a>

<p>Now that we have an understanding of general spanning trees, we will introduce the concept of minimum spanning trees. First let&rsquo;s introduce the concept of the cost of a tree.</p>
<p>The <strong>cost</strong> that is associated with a tree, is the sum of its edges weights. Let&rsquo;s look at this spanning tree which is from the previous page. The cost associated with this spanning tree is: <code>2+6+10+14=32</code>.
<a href="#R-image-a93127464b2e3a6f5593dd86ff5344b5" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a93127464b2e3a6f5593dd86ff5344b5"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg"></a></p>
<h2 id="minimum-spanning-trees-mst">Minimum Spanning Trees (MST)</h2>
<p>A <strong>minimum spanning tree</strong> is a spanning tree that has the smallest cost. Recall the graph from the previous page.</p>
<p><a href="#R-image-50df3b93868f74ba90c355cb341601a1" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50df3b93868f74ba90c355cb341601a1"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below on the left is a minimum spanning tree for the graph above. On the right is an example of a spanning tree, though it does not have the minimum cost.</p>
<p><a href="#R-image-dc4af4c7155a70c1deda25bc584ec4b3" class="lightbox-link"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc4af4c7155a70c1deda25bc584ec4b3"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg"></a></p>
<p>In this small example, it is rather straightforward to find the minimum spanning tree. We can use a bit of trial and error to determine if we have the minimum spanning tree or not. However, once the graphs start to get more nodes and more edges it quickly becomes more complicated.</p>
<p><a href="#R-image-92a74303149e8fcf616d0e20d6a114ad" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-92a74303149e8fcf616d0e20d6a114ad"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg"></a></p>
<p>There are two algorithms that we will introduce to give us a methodical way of finding the minimum spanning tree. The first that we will look at is Kruskal&rsquo;s algorithm and then we will look at Prim&rsquo;s algorithm.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="kruskal">Kruskal</h1>


<a href="https://www.youtube.com/watch?v=av-r-orP56g">YouTube Video</a>

<p>As graphs get larger, it is important to go about finding the MST in a methodical way. In the mid 1950&rsquo;s, there was a desire to form an algorithmic approach for solving the &rsquo;traveling salesperson&rsquo; problem^[We will describe this problem in a future section of this module]. Joseph Kruskal first published this algorithm in 1956 in the Proceedings of the American Mathematical Society^[https://www.ams.org/journals/proc/1956-007-01/S0002-9939-1956-0078686-7/S0002-9939-1956-0078686-7.pdf]. The algorithms prior to this were, as Kruskal said, &ldquo;unnecessarily elaborate&rdquo; thus the need for a more succinct algorithm arose.</p>
<h2 id="algorithm">Algorithm</h2>
<p>In his original work, Kruskal outlined three different yet similar algorithms to finding a minimum spanning tree. The <code>Kruskal Algorithm</code> that we use is as follows:</p>
<ol>
<li>Start with only the nodes of the graph and an empty set for the edges</li>
<li>Order the edges based on weight</li>
<li>Make each node their own set</li>
<li>Go through the edges in ascending order</li>
<li>If nodes <code>u</code> and <code>v</code> are connected by the edge and they are not in the same set yet, then join the two sets and add the edge to your set of edges</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-e10461b0de989eaece375e4a1fe511de" class="lightbox-link"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e10461b0de989eaece375e4a1fe511de"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-cf2669463e6049908a03e1a35a85ae18" class="lightbox-link"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/kruskal.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cf2669463e6049908a03e1a35a85ae18"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/kruskal.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-d43700d2bc06c00e2768b736e6243ded" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d43700d2bc06c00e2768b736e6243ded"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></p>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function KRUSKAL(GRAPH)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    ALLSETS = an empty list which will contain the sets
</span></span><span class="line"><span class="cl">    for NODE in GRAPH NODES
</span></span><span class="line"><span class="cl">        SET = a set with element NODE
</span></span><span class="line"><span class="cl">        add SET to ALLSETS
</span></span><span class="line"><span class="cl">    EDGES = list of GRAPH&#39;s edges
</span></span><span class="line"><span class="cl">    SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span class="line"><span class="cl">    for EDGE in SORTEDEDGES
</span></span><span class="line"><span class="cl">        SRC = source node of EDGE
</span></span><span class="line"><span class="cl">        TAR = target node of EDGE
</span></span><span class="line"><span class="cl">        SRCSET = the set from SETS in which SRC is contained
</span></span><span class="line"><span class="cl">        TARSET = the set form SETS in which TAR is contained
</span></span><span class="line"><span class="cl">        if SRCSET not equal TARSET
</span></span><span class="line"><span class="cl">            UNIONSET = SRCSET union TARSET
</span></span><span class="line"><span class="cl">            add UNIONSET to ALLSETS
</span></span><span class="line"><span class="cl">            remove SRCSET from ALLSETS
</span></span><span class="line"><span class="cl">            remove TARSET from ALLSETS
</span></span><span class="line"><span class="cl">            add EDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="prim">Prim</h1>


<a href="https://www.youtube.com/watch?v=B9bG6FTj5pA">YouTube Video</a>

<p>The history of <code>Prim's Algorithm</code> is not as straight forward as Kruskal&rsquo;s. While we often call it <code>Prim's Algorithm</code>, it was originally developed in 1930 by Vojtěch Jarník. Robert Prim later rediscovered and republished this algorithm in 1957, one year after Kruskals. To add to the naming confusion, Edsger Dijkstra also published this work again in 1959. Because of this, the algorithm can go by many names: <code>Jarkík's Algorithm</code>, <code>Jarník-Prim's Algorithm</code>, <code>Prim-Dijkstra's Algorithm</code>, and <code>DJP Algorithm</code>.</p>
<p>Prim cited &ldquo;large-scale communication&rdquo; as the motivation for this algorithm, specifically the &ldquo;Bell System leased-line&rdquo;^[R.C. Prim, May 8, 1957 Shortest Connection Networks And Some Generalizations https://archive.org/details/bstj36-6-1389]. Leased lines were used primarily in a commercial setting which connected business offices that were geographically distant (IE in different cities or even states). Companies would want all offices to be connected but wanted to avoid having to lay an excessive amount of wire. Below is a figure which Prim used to motivate the need for the algorithm. This image depicts the minimum spanning tree which connect each of the US continental state capitals along with Washington D.C.</p>
<p><a href="#R-image-379b593373f65ca39c00253ddd66973d" class="lightbox-link"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim_US.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-379b593373f65ca39c00253ddd66973d"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim_US.png"></a></p>
<h2 id="algorithm">Algorithm</h2>
<p>The basis of the algorithm is to start with only the nodes of the graph, then we do the following</p>
<ol>
<li>Choose a random node</li>
<li>Grow your tree by one edge, selecting the smallest edge to connect to a node that is not yet in the tree. Repeat until all the nodes have been visited</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-5ede3261f2bf600da49689ec939a40a7" class="lightbox-link"><img alt="Prim Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ede3261f2bf600da49689ec939a40a7"><img alt="Prim Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-d7d7b94e833843f79a9ae4562467460d" class="lightbox-link"><img alt="Prim Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d7d7b94e833843f79a9ae4562467460d"><img alt="Prim Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-dbbd2a79177d8502115b5b276d1c6d81" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dbbd2a79177d8502115b5b276d1c6d81"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Uniqueness</strong></p>
<p>You may have noticed that the minimum spanning tree that resulted from Kruskal&rsquo;s algorithm differed from Prim&rsquo;s algorithm. We have displaying them both below for reference.</p>
<table>
<thead>
<tr>
<th>Kruskal</th>
<th>Prim</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#R-image-5014b4f488394b3a5780e56c7a8d3528" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5014b4f488394b3a5780e56c7a8d3528"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></td>
<td><a href="#R-image-370e5a5f62477fa562dbf1a4ea3b63b1" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-370e5a5f62477fa562dbf1a4ea3b63b1"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></td>
</tr>
</tbody>
</table>
<p>While these are different, they are both valid. The trees both have cost 16. The MST of a graph will be unique, meaning there is only one, if none of the edges of the graph have the same weight.</p>
</div>
</div>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRIM(GRAPH, START)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    VISITED = empty set
</span></span><span class="line"><span class="cl">    add START to VISITED
</span></span><span class="line"><span class="cl">    AVAILEDGES = list of edges where START is the source
</span></span><span class="line"><span class="cl">    sort AVAILEDGES
</span></span><span class="line"><span class="cl">    while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">        SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">        SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">        if TAR not in VISITED
</span></span><span class="line"><span class="cl">            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">            add TAR to VISITED
</span></span><span class="line"><span class="cl">            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">        sort AVAILEDGES
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="traveling-salesperson">Traveling Salesperson</h1>


<a href="https://www.youtube.com/watch?v=txzR-tM6z7M">YouTube Video</a>


<a href="https://www.youtube.com/watch?v=OPvOpQ6w734">YouTube Video</a>

<p>While we won&rsquo;t outline algorithms suited for solving the traveling salesperson problem (TSP), we will outline the premise of the problem. This problem was first posed in 1832, almost a two centuries ago, and is still quite prevalent. It is applicable to traveling routes, distribution networks, computer architecture and much more. The TSP is a seminal problem that has motivated many research breakthroughs, including Kruskals algorithm!</p>
<p>The motivation of the TSP is this: given a set of locations, what is the shortest path such that we can visit each location and end back where started?</p>
<p>Suppose we wanted to take a roadtrip with friends to every state capital in the continental US as well as Washington D.C. To save money and time, we would want to minimize the distance that we travel. Since we are taking a roadtrip, we would want to avoid frivolous driving. For example, if we start in Sacremento, CA we would not want to end the trip in Boston, MA. The trip should start and end at the same location for efficiency.</p>
<p>The figure below shows the shortest trip that visits each state capital and Washington D.C. once. In this example, we can start where ever we like and will end up where we started.
<a href="#R-image-32ac664ff94c99f267c23ec79be4fe9e" class="lightbox-link"><img alt="Visit each state capital" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-32ac664ff94c99f267c23ec79be4fe9e"><img alt="Visit each state capital" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png"></a>^[PatriciaNeri, August 2018 https://communities.sas.com/t5/SAS-Communities-Library/What-is-the-shortest-tour-that-visits-only-once-the-48/ta-p/490231]</p>
<p>In this problem, it is easy to get overwhelmed by all of the possibilities. Since there are 49 cities to visit, there are over <code>6.2*10^60</code> possibilities. For reference, <code>10^12</code> is equivalent to one trillion! Thus, we need an algorithmic approach to solve this problem as opposed to a brute force method.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Emily Alfs
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/499f4d824a58536af610d92fd6aa49d60ed20d97">Oct 21, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1737135054" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1737135054" defer></script>
    <script src="/cc315/js/theme.js?1737135054" defer></script>
  </body>
</html>
