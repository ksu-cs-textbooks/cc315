




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Iii-Graphs :: CC 315 Textbook">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/iii-graphs/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Iii-Graphs :: CC 315 Textbook">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Iii-Graphs :: CC 315 Textbook">
    <meta itemprop="dateModified" content="2024-06-27T16:12:13-05:00">
    <title>Iii-Graphs :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/iii-graphs/" rel="canonical" type="text/html" title="Iii-Graphs :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/index.xml" rel="alternate" type="application/rss+xml" title="Iii-Graphs :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/tele.html" rel="alternate" type="text/html" title="Iii-Graphs :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/embed.html" rel="alternate" type="text/html" title="Iii-Graphs :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1719522770" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1719522770" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1719522770" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1719522770" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1719522770" rel="stylesheet">
    <link href="/cc315/css/print.css?1719522770" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1719522770" rel="stylesheet">
    <script src="/cc315/js/variant.js?1719522770"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1719522770" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/iii-graphs/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Iii-Graphs</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/ii-trees/5-binary-trees/8-balance/" title="Balance (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/iii-graphs/6-graphs--matrix-representation/" title="Graphs: Matrix Representation (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="iii-graphs">Iii-Graphs</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Iii-Graphs</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 30</div>

<h1 id="graphs-matrix-representation">Graphs: Matrix Representation</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Matrix Representation</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Matrix Representation</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=lVIlBepiPEc">YouTube Video</a>

<p>The next data structure we will introduce is a graph.</p>
<p><a href="#R-image-a5f6ebc42bdd6bf8e8994fdf9a072e0f" class="lightbox-link"><img alt="Graph Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphex1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a5f6ebc42bdd6bf8e8994fdf9a072e0f"><img alt="Graph Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphex1.svg"></a></p>
<p>Graphs are multidimensional data structures that can represent many different types of data. We can use graphs to represent electronic circuits and wiring, transportation routes, and networks such as the Internet or social groups.</p>
<p>A popular and fun use of graphs is to build connections between people such as Facebook friends or even connections between performers. One example is the parlor game <a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon" rel="external" target="_blank">Six Degrees of Kevin Bacon</a>. Players attempt to connect Kevin Bacon to other performers through movie roles in six people or less.</p>
<p><a href="#R-image-bf6ee9b75714d374d2506a4d9af24f3c" class="lightbox-link"><img alt="Six Degrees of Kevin Bacon" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/actors.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf6ee9b75714d374d2506a4d9af24f3c"><img alt="Six Degrees of Kevin Bacon" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/actors.svg"></a></p>
<p>For example, Laurence Fishburne and Kevin Bacon are directly connected via &lsquo;Mystic River&rsquo;. Keanu Reeves and Kevin Bacon have never performed in the same film, but Keanu Reeves and Laurence Fishburne are connected via &lsquo;The Matrix&rsquo;. Thus, Keanu and Kevin are connected via Laurence.</p>
<p>In this module we will discuss graphs in more detail and build our own implementation of graphs.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-i">Terms I</h1>


<a href="https://www.youtube.com/watch?v=QIX78W3GUpc">YouTube Video</a>

<p>We will discuss some of the basic terminology associated with graphs. Some of this vocabulary should feel familiar from the trees section; trees are a specific type of graph!</p>
<ul>
<li><code>Nodes</code>: Node is the general term for a structure which contains an item.
<ul>
<li><code>Size</code>: The size of a graph is the number of nodes.</li>
<li><code>Capacity</code>: The capacity of a graph is the maximum number of nodes.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Nodes</strong> can be, but are not limited to the following examples:
- physical locations (IE Manhattan, Topeka, Salina),
- computer components (IE CPU, GPU, RAM), or
- people (IE Kevin Bacon, Laurence Fishburne, Emma Stone)</p>
</div>
</div>
<ul>
<li><code>Edges</code>: Edges are the connection between two nodes. Depending on the data, edges can represent physical distance, films, cost, and much more.
<ul>
<li><code>Adjacent</code>: Node A and node B are said to be adjacent if there is an edge from node A to node B.</li>
<li><code>Neighbors</code>: The neighbors of a node are nodes which are adjacent to the node.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Edges</strong> can be, but are not limited to:
- physical distances, like the distance between cities or wiring between computer components,
- cost, like bus fares, and
- films, like the Six Degrees of Kevin Bacon example</p>
</div>
</div>
<ul>
<li><code>Cycles</code>: A cycle is a path where the first and last node are the only repeated nodes. More explicitly, this means that we start at node A and are able to end up back at node A.</li>
</ul>
<h2 id="example">Example</h2>
<p>For example, we can translate the <a href="https://www.amtrak.com/content/dam/projects/dotcom/english/public/documents/Maps/Amtrak-System-Map-1018.pdf" rel="external" target="_blank">Amtrak Train Station Connections</a> into a graph where the edges represent direct train station connections.</p>
<p><a href="#R-image-22f1ec1721f0bff876eb2608185fbb85" class="lightbox-link"><img alt="Amtrak Train Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/amtrak.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22f1ec1721f0bff876eb2608185fbb85"><img alt="Amtrak Train Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/amtrak.svg"></a>^[Generated using the Amtrak system map from 2018. This graph does not include all stations or connections.]</p>
<p>Within this context, we could say that Little Rock and Fort Worth are <code>adjacent</code>. The <code>neighbors</code> of San Antonio are Fort Worth, Los Angeles, and New Orleans. The Amtrak Train Graph has multiple <code>cycles</code>. One of these is <code>Kansas City -&gt; St. Louis -&gt; Chicago -&gt; Kansas City</code>.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graph-features">Graph Features</h1>


<a href="https://www.youtube.com/watch?v=F_mNd-CIFpc">YouTube Video</a>

<p>While trees are a type of graph, graphs can have more functionality than trees. For example, recall that to be a single tree, there could be no disconnected pieces.</p>
<ul>
<li><code>Connectedness</code>: Graphs do not require being fully connected. There can be disconnected portions within a graph. For example, the following graph shows all of the students in a sophomore biology class. There is an edge between two student nodes if they are Facebook friends.</li>
</ul>
<p><a href="#R-image-927cff487cbbe57c2b82e25baf3916df" class="lightbox-link"><img alt="Friends Group" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/friends.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-927cff487cbbe57c2b82e25baf3916df"><img alt="Friends Group" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/friends.svg"></a></p>
<p>Graphs can also have loops. In a tree, this would be like a node being its own parent, which is not an allowable condition.</p>
<ul>
<li><code>Loops</code>: Loops are edges which connect a node to itself. These can be useful in depicting graphs that show control flow in programming. In this example, node A is connected to node B and node A is connected to itself.</li>
</ul>
<p><a href="#R-image-927c2e909438d2fcf4f6aa8ac63786d9" class="lightbox-link"><img alt="With a Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/loop2.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-927c2e909438d2fcf4f6aa8ac63786d9"><img alt="With a Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/loop2.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="weighted-graphs">Weighted Graphs</h1>


<a href="https://www.youtube.com/watch?v=x4_myCOtFnk">YouTube Video</a>

<p>A <strong>weighted</strong> graph is a graph which has weights associated with the edges. These weights quantify the relationships, so they can represent dollars, minutes, miles, and many other factors which our data may depend upon.</p>
<p>Weights are not limited to physical quantities; they can also be our own defined similarity in text, product types, and anything for which we can create a similarity measure for. Let&rsquo;s look at concrete weights using the Amtrak example.</p>
<p>We are able to expand the Amtrak graph from the previous page to include approximate distances in miles between cities.</p>
<p><a href="#R-image-91c7fdb1158377d3e5cb3e10d45a7c8b" class="lightbox-link"><img alt="Amtrak Train Graph with Weights" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/amtrak_dist.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91c7fdb1158377d3e5cb3e10d45a7c8b"><img alt="Amtrak Train Graph with Weights" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/amtrak_dist.svg"></a>^[Generated using the Amtrak system map from 2018. This graph does not include all stations or connections. Distance was calculated approximately &lsquo;as the crow flies&rsquo;.]</p>
<p>Now that we have weights defined on our edges, we can compare paths in a different way. When we discussed trees, we just looked at the number of edges it took to get to another node. We can also determine the shortest path between nodes with respect to distance. If we wanted to travel from San Antonio to Kansas City, we may be tempted to travel <code>San Antoinio -&gt; Los Angeles -&gt; Albuquerque -&gt; Kansas City</code> as it has the fewest stops. This trip would take us 2,531 miles (1201+640+690). With the edge weights in mind, a much better route would be <code>San Antonio -&gt; Fort Worth -&gt; Little Rock -&gt; St. Louis -&gt; Kansas City</code> with a total of 1,089 miles(238+320+293+238) traveled.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="directed-graphs">Directed Graphs</h1>


<a href="https://www.youtube.com/watch?v=f7qyV9XOwzA">YouTube Video</a>

<p>A <strong>directed</strong> graph is a graph that has a direction associated with each edge. For example, trees are a directed graph. The edge orientation will imply a fixed direction that we can move about nodes. As with trees, the flat end of the arrow will represent the origin and the arrowhead will represent the destination. If an edge has no arrowheads, then it is assumed that we can traverse both directions.</p>
<p>In the following graph, we have an example distribution network where each store ends up with 5 units in its possession. For example, nine units go from the distribution center to Store A. The distribution center will never receive product from stores as it has no incoming edges.</p>
<p><a href="#R-image-3105b52e922cf8086447a45a820cbae0" class="lightbox-link"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/distribution-3.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3105b52e922cf8086447a45a820cbae0"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/distribution-3.svg"></a></p>
<p>Unlike trees, directed graphs can have nodes with multiple incoming edges. We can see an example of this at Store B. The distribution center and Store A both send units to Store B.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>In directed graphs, we must be cautious on how we define <strong>adjacent</strong>. For the following, we would say that the source is adjacent to the target. However, the target is not adjacent to the source.</p>
<p><a href="#R-image-4d192595dde8bcb4efb5106407daa98a" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d192595dde8bcb4efb5106407daa98a"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg"></a></p>
<p>Formally, node A and node B are said to be adjacent if there is an edge from node A to node B.</p>
</div>
</div>
<p>When discussing directed graphs, we must also talk about undirected graphs. An <strong>undirected</strong> graph is a graph in which none of the edges have an orientation. If there is at least one directed edge, then it is considered a directed graph.</p>
<ul>
<li><code>Undirected Edge</code>: An undirected edge is an edge which has no defined orientation (IE no arrowheads) which implies that we can traverse in either direction. If node A and node B are connected via an undirected edge then we say node A is adjacent to node B and node B is adjacent to node A.</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For the following undirected edge, we would say that the source is adjacent to the target and the target is adjacent to the source.</p>
<p><a href="#R-image-0c98a15cd30eb2c2775c1c6b67f5bd0e" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/undirected_edge.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c98a15cd30eb2c2775c1c6b67f5bd0e"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/undirected_edge.svg"></a></p>
</div>
</div>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Graph types and appearances can vary wildly. We are not limited to just weighted/unweighted or directed/undirected. We can also have combinations of weighted and directed.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example">Example</h1>

<p>In the following graph, we have an example of a weighted and directed map. This map represents a zoo train where each node represents a station and each edge is a part of the track. Zoo guests can get on and off wherever they desire.</p>
<p>This graph is weighted as guests must pay the associated fee for each part of the track. Our example train also has a one way direction in most cases. The exception to this is the entrance/exit to the aquarium, this part of the track can go either direction.</p>
<p>In this graph, we also have a couple of loops. This would allow for zoo-guests to ride the train around an expansive exhibit such as the elephants or giraffes.</p>
<p>One possible way to tour the zoo for a guest starting at the entrance could be: aquarium, primates, big cats, antelope, giraffes, loop around the giraffes, elephants, aquarium, then exit. Their total payment for just the train would be $14.</p>
<p><a href="#R-image-fce946f044218e873e418d793f466828" class="lightbox-link"><img alt="Zoo Train Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/zoo.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fce946f044218e873e418d793f466828"><img alt="Zoo Train Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/zoo.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="matrix-representation">Matrix Representation</h1>


<a href="https://www.youtube.com/watch?v=Uwd8YkQwoqM">YouTube Video</a>

<p>The first way that we can represent graphs is as matrices. In a matrix representation of a graph, we will have an array with all the nodes and a matrix to depict the edges. The matrix that depicts the edges is called the <code>adjacency matrix</code>.</p>
<p>To build the <code>adjacency matrix</code>, we go through the nodes and edges. If there is an edge with weight <code>w</code> going from <code>i</code> to <code>j</code>, then we put <code>w</code> in the <code>(i,j)</code> spot in our <code>adjacency matrix</code>. If there is no edge from <code>i</code> to <code>j</code> then we put infinity in the spot <code>(i,j)</code>. Let&rsquo;s look at some examples.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>An edge that starts at <code>source</code> and ends at <code>target</code> will result in an entry at <code>(source,target)</code> in the adjacency matrix.</p>
<p><a href="#R-image-e9e1d3c2adc740097e083df794987783" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e9e1d3c2adc740097e083df794987783"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg"></a></p>
</div>
</div>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For an unweighted graph, we treat the weights as 1 for all edges in our adjacency matrix.</p>
<p>For an undirected edge between nodes <code>i</code> and <code>j</code>, we put an edge from <code>i</code> to <code>j</code> and an edge from <code>j</code> to <code>i</code>.</p>
</div>
</div>
<h2 id="example-1">Example 1</h2>
<p>Suppose that we have the following graph:</p>
<p><a href="#R-image-f849543f78a7634f2f8a9c6575657f6f" class="lightbox-link"><img alt="Matrix Representation Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f849543f78a7634f2f8a9c6575657f6f"><img alt="Matrix Representation Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>Across the top of the following, we have the array of nodes. This give us the index at which each node is located. For example, node A is in spot <code>1</code>, node B is in spot <code>2</code>, node C is in spot <code>3</code> and so on.</p>
<p>Below that we have the adjacency matrix. For the directed edge with weight 2 that goes from node B to node C, we have the value 2 at (2,3) in the adjacency matrix as B has index 2 and C has index 3. For the directed edge with weight 4 that goes from node A to node F, we have the value 4 at (1,6) in the adjacency matrix as A has index 1 and F has index 6.</p>
<p>Since there is no edge that connects from node A to node B, we have infinity in <code>(1,2)</code>.</p>
<p><a href="#R-image-7062da83465e8deee5175bf20d88c48a" class="lightbox-link"><img alt="Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7062da83465e8deee5175bf20d88c48a"><img alt="Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixA.svg"></a></p>
<h2 id="example-2">Example 2</h2>
<p>Now suppose we have this graph. We now have some loops present.
<a href="#R-image-6e7580f9f89acfc9a25702d12f171939" class="lightbox-link"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6e7580f9f89acfc9a25702d12f171939"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a></p>
<p>For example, we have a loop on node E with weight 12 so we will put the value 12 in spot (5,5) as E has index 5.</p>
<p><a href="#R-image-77d23e0f6f18d271d0cdb8e41bbf57ba" class="lightbox-link"><img alt="Matrix 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-77d23e0f6f18d271d0cdb8e41bbf57ba"><img alt="Matrix 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixB.svg"></a></p>
<h2 id="example-3">Example 3</h2>
<p>Now suppose we have this graph which is undirected and unweighted.
<a href="#R-image-55ef0840f03889fb04e283ee9e48baf2" class="lightbox-link"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphC.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-55ef0840f03889fb04e283ee9e48baf2"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphC.svg"></a></p>
<p>Since this graph is unweighted, we will treat all edges as though they have weight equal to one. Since this graph is undirected, each edge will essentially show up twice.</p>
<p>For example, for the edge that connects nodes A and B, we will have an entry in our adjacency matrix at <code>(1,2)</code> and <code>(2,1)</code>.</p>
<p><a href="#R-image-c8d04b7236e24fccdea2b276192a1b1a" class="lightbox-link"><img alt="Matrix 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixC.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c8d04b7236e24fccdea2b276192a1b1a"><img alt="Matrix 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixC.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml">UML</h1>


<a href="https://www.youtube.com/watch?v=Alyg8IEC0Os">YouTube Video</a>

<p><a href="#R-image-271d63586438d149adaf31775e6b1a07" class="lightbox-link"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphmatUML.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-271d63586438d149adaf31775e6b1a07"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphmatUML.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>edges</code>: This will keep track of the edges which are in our graph.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array of size <code>capacity</code>, <code>edges</code> to be an empty two-dimensional array with dimensions <code>capacity</code> by <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for ROW in EDGES
</span></span><span class="line"><span class="cl">        for COL in ROW
</span></span><span class="line"><span class="cl">            VALUE = entry at (ROW,COL)
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (ROW,COL,VALUE) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity.</p>
</li>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph. We will iterate through our edges and return the number of entries that were not infinity.</p>
</li>
<li>
<p><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    if IDX in range of NODES length
</span></span><span class="line"><span class="cl">        LIST = []
</span></span><span class="line"><span class="cl">        ROW = the IDX-th row of EDGES
</span></span><span class="line"><span class="cl">        for J in range  0 to ROW length
</span></span><span class="line"><span class="cl">            VALUE = J-th entry of ROW
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (J,VALUE) to LIST
</span></span><span class="line"><span class="cl">        return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>


<a href="https://www.youtube.com/watch?v=MNoJEn_EvBk">YouTube Video</a>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Procedurally, we will try to put the node in the first empty place we find. To do this, we start with <code>IDX</code> equal to negative one then loop through all of the indexes of the graphs <code>nodes</code> attribute. At each index, we check if that entry is equal to the value we are trying to add. This will check if the value is already in our graph. If there is nothing in that entry and the <code>IDX</code> variable is still negative one, then we will set <code>IDX</code> equal to that index. We continue looping through the <code>nodes</code> attribute until we reach the end. It is possible that there is more than one open space in the <code>nodes</code> attribute. Thus, by checking if <code>IDX</code> is still negative one we can make sure to put <code>value</code> in the first empty spot. Once we finish going through <code>nodes</code> we check to see if we ever found an open spot. If <code>IDX</code> is still negative one, this would indicate that there was no room. Otherwise, we put <code>value</code> into <code>nodes</code> at spot <code>IDX</code> and increment the size.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        add VALUE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty and remove any edges that may be attached to it.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for J in node indexes 
</span></span><span class="line"><span class="cl">                set EDGES (J,IDX) equal to infinity 
</span></span><span class="line"><span class="cl">                set EDGES (IDX,J) equal to infinity
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SOURCE, TARGET, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        set EDGES(SOURCE, TARGET) equal to WEIGHT
</span></span><span class="line"><span class="cl">        return true 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        if EDGES(SOURCE, TARGET) is not equal to infinity
</span></span><span class="line"><span class="cl">            set EDGES(SOURCE, TARGET) equal to infinity
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes. We can utilize the remove edge function on &lsquo;NODE1&rsquo; to &lsquo;NODE2&rsquo; and then on &lsquo;NODE2&rsquo; to &lsquo;NODE1&rsquo;.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this module, we have introduced the graph data structure. We also looked at how we would implement a graph using a matrix representation. We introduced the following new concepts in this module:</p>
<ul>
<li>
<p><code>Directed Graphs</code>: A directed graph is a graph that has a direction associated with each edge. The flat end of the arrow will represent the origin and the arrowhead will represent the destination. If an edge has no arrowheads, then it is assumed that we can traverse both directions.</p>
</li>
<li>
<p><code>Edges</code>: Edges are the connection between two nodes. Depending on the data, edges can represent physical distance, films, cost, and much more.</p>
<ul>
<li><code>Adjacent</code>: Node A and node B are said to be adjacent if there is an edge from node A to node B.</li>
<li><code>Neighbors</code>: The neighbors of a node are nodes which are adjacent to the node.</li>
<li><code>Undirected Edge</code>: An undirected edge is an edge which has no defined orientation (IE no arrowheads). If node A and node B are connected via an undirected edge then we say node A is adjacent to node B and node B is adjacent to node A.</li>
</ul>
</li>
<li>
<p><code>Loops</code>: Loops are edges which connect a node to itself.</p>
</li>
<li>
<p><code>Nodes</code>: Node is the general term for a structure which contains an item.</p>
<ul>
<li><code>Size</code>: The size of a graph is the number of nodes.</li>
<li><code>Capacity</code>: The capacity of a graph is the maximum number of nodes.</li>
</ul>
</li>
<li>
<p><code>Weighted Graphs</code>: A weighted graph is a graph which has weights associated with the edges. These weights will quantify the  relationships so they can represent dollars, minutes, miles, and many other factors which our data may depend on.</p>
</li>
</ul>
<p>In the next module, we will look at a list implementation of graphs and when we might use one implementation over the other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 35</div>

<h1 id="graphs-list-representation">Graphs: List Representation</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: List Representation</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: List Representation</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=DgN_qmbtK_M">YouTube Video</a>

<p>In the previous module, we introduced graphs and a matrix-based implementation. For this module, we will continue working with graphs and change our implementation to lists.</p>
<h2 id="why-another-implementation">Why Another Implementation?</h2>
<p>When using graphs, a lot of situational variation can occur. Some graphs can have a few nodes with many edges, many nodes with few edges, and so on. When we use the matrix implementation, we initialize a matrix with the number of columns and rows equal to the number of nodes. For example, if we have a graph with 20 nodes, our adjacency matrix would have 20 rows and 20 columns, resulting in 400 potential entries.</p>
<p>First let&rsquo;s look at the implementation and then we will discuss when one may be better than the other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-representation">List Representation</h1>


<a href="https://www.youtube.com/watch?v=MJqStsuqf_U">YouTube Video</a>

<p>In the matrix representation, we had an array of the node items. In the list representation, we will have an array of node objects. Each <strong>node object</strong> will keep track of the node item, the node index, and the outgoing edges.</p>
<p><a href="#R-image-ad2966a96c10df599119a0508373bc95" class="lightbox-link"><img alt="Set Up" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ad2966a96c10df599119a0508373bc95"><img alt="Set Up" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg"></a></p>
<p>The <code>item</code> can be any object and the <code>index</code> will be a value within our capacity. The <code>edges</code> will be a list of pairs where the first entry is the index of the target node and the second entry is the weight of the edge.</p>
<p>Since each node will track its neighbors, it is important that we are consistent in our indexing of nodes. If our nodes were to get out of order, then our edges would as well.</p>
<h2 id="example-1">Example 1</h2>
<p>Consider the following graph which we saw in the matrix representation.</p>
<p><a href="#R-image-7e054b8ff44dff4e13f295327f1e4ae7" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e054b8ff44dff4e13f295327f1e4ae7"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>The following list of nodes depicts the graph above. We can see that each node object has the item and index.</p>
<p>If we look closer at the <code>edges</code> of the node with item <code>A</code> and index <code>1</code>, we see that the set of edges is equal to <code>[(4, 3.0), (6, 4.0)]</code>. This corresponds to the fact that there are two edges with the source as node <code>1</code>. The first ordered pair, <code>(4, 3.0)</code>, means that there is an edge with source node <code>1</code> (<code>A</code>) and target node <code>4</code> (<code>D</code>) that has weight <code>3</code>. We can confirm that in our graph we do have an edge from <code>A</code> to <code>D</code> with weight <code>3</code>.</p>
<p><a href="#R-image-fee67b391c4908ef6c9dee335751bcab" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fee67b391c4908ef6c9dee335751bcab"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="example-2">Example 2</h2>
<p>The following includes a couple of examples of loops within our graph.</p>
<p><a href="#R-image-8965050892eadf0e38ee8bd830cbb160" class="lightbox-link"><img alt="Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8965050892eadf0e38ee8bd830cbb160"><img alt="Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a></p>
<p>We have loops on nodes <code>D</code>, <code>E</code>, and <code>F</code> in our graph. Recall that a loop is an edge where the source and target are the same. For example, we have an edge with source <code>D</code> and target <code>D</code> that has weight <code>12</code>. We see this in our list representation in the node object with item <code>D</code> and index <code>4</code>, where we have the entry <code>(4,12.0)</code> in the edges.</p>
<p><a href="#R-image-454897aa328877c782db8f28a370d8ff" class="lightbox-link"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-454897aa328877c782db8f28a370d8ff"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="dense-vs-sparse">Dense VS Sparse</h1>


<a href="https://www.youtube.com/watch?v=y4bCalShe_Y">YouTube Video</a>

<p>When considering which implementation to use, we need to consider the connectivity in our graph. The terms that we use to describe the connectedness are <strong>dense</strong> and <strong>sparse</strong>.</p>
<ul>
<li><code>Dense Graph</code>: A dense graph is a graph in which there is a large number of edges. Typically in a dense graph, the number of edges is close to the maximum number of edges.</li>
<li><code>Sparse Graph</code>: A sparse graph is a graph in which there is a small number of edges. In this case the number of edges is considerably less than the maximum number of edges.</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Intuitively, we can think of dense and sparse in terms of populations. For example, if 100 people lived in a city block, we can consider that to be densely populated. If 100 people lived in 100 square miles we can consider that to be sparsely populated.</p>
</div>
</div>
<p>Let&rsquo;s look at some motivating examples to get an idea of how the different structures will handle these cases.</p>
<h2 id="dense">Dense</h2>
<p>The following is a dense graph. In this case, our graph does have the maximum number of edges. This means that every node is connected to every other node including itself.</p>
<p><a href="#R-image-6d4ea1f02ee50fd55d7760f132e8449d" class="lightbox-link"><img alt="Dense Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6d4ea1f02ee50fd55d7760f132e8449d"><img alt="Dense Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_graph.svg"></a>
<a href="#R-image-768af4272c2f51926bf1fe38f2313627" class="lightbox-link"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-768af4272c2f51926bf1fe38f2313627"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg"></a>
<a href="#R-image-3ef576feed2815653adf48dce7587662" class="lightbox-link"><img alt="Dense Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ef576feed2815653adf48dce7587662"><img alt="Dense Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_list.svg"></a></p>
<h2 id="sparse">Sparse</h2>
<p>The following is a sparse graph.</p>
<p><a href="#R-image-9e85a5cc64d3c8fbd2371ef9d34a3ae1" class="lightbox-link"><img alt="Sparse Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9e85a5cc64d3c8fbd2371ef9d34a3ae1"><img alt="Sparse Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg"></a>
<a href="#R-image-7e5a102ba691b47bf17bf288f3d10160" class="lightbox-link"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e5a102ba691b47bf17bf288f3d10160"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg"></a>
<a href="#R-image-18230ce7e9fa792ff602a4949a63dbaf" class="lightbox-link"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18230ce7e9fa792ff602a4949a63dbaf"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_list.svg"></a></p>
<h2 id="list-or-matrix">List or Matrix?</h2>
<p>For dense graphs, the matrix representation will have better qualities as we are already setting aside space for the maximum number of edges. Sparse graphs are better represented in the list representation.</p>
<p>When we initialize the matrix implementation, we initialize the <code>nodes</code> attribute to have dimension equal to the capacity of the graph. The <code>edges</code> attribute is initialized to be a square matrix with dimension equal to capacity by capacity. Thus, if we have a sparse matrix, we are representing a lot of non-existent edges.</p>
<p>When we initialize the list implementation, we just have the <code>nodes</code> attribute which has dimension equal to the capacity and each node tracks its own edges. If we have a dense matrix and we are searching for an edge, we must loop through each edge from the target node to see if the edge exists. In the matrix representation, we can access that edge directly.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>If the proportion of edges to the maximum number of edges is greater than 1/64, then the matrix representation is better in terms of space.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph-node">UML - Graph Node</h1>


<a href="https://www.youtube.com/watch?v=BVgbAW7NZY8">YouTube Video</a>

<p>In this representation, we will have an array of graph node objects. We will first cover the UML for the graph node objects and then discuss the graph functions and attributes.</p>
<p><a href="#R-image-654037d7eb89bbc3f334547294de2a93" class="lightbox-link"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-654037d7eb89bbc3f334547294de2a93"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>item</code>: the value that the node contains.</li>
<li><code>index</code>: the index of the node.</li>
<li><code>edges</code>: ordered pairs <code>(e, w)</code> where this node is the source, <code>e</code> is the target node index, and <code>w</code> is the weight of the edge as a double.</li>
</ul>
<p>We will initialize a graph node with the given item and the given index. We initialize the <code>edges</code> attribute to be an empty list.</p>
<h2 id="getters">Getters</h2>
<ul>
<li>
<p><code>get item</code>: Returns the graph node&rsquo;s item.</p>
</li>
<li>
<p><code>get index</code>: Returns the graph node&rsquo;s index.</p>
</li>
<li>
<p><code>get edges</code>: Returns the graph node&rsquo;s edges.</p>
</li>
<li>
<p><code>get edge</code>: From the source node, we will call the get edge function with the index of the target node as input. This will return the edge weight.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            return the second element in EDGE
</span></span><span class="line"><span class="cl">    return infinity </span></span></code></pre></div><h2 id="edge-functions">Edge Functions</h2>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Working with the edges in our graph becomes slightly more complicated in the list representation. Previously, we were able to go right to the entry in our adjacency matrix and update it. Since each node keeps track of its own edges in no particular order, we must loop through each entry of the edges attribute to find a potential edge.</p>
</div>
</div>
<ul>
<li><code>add edge</code>: From the source node, we will call the add edge function with the target node as input as well as the weight. First, we will attempt to remove the edge. We need to do this as we do not want duplicate edges in our graph. Then we will add the ordered pair to the edges attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(TARINDEX, WEIGHT)
</span></span><span class="line"><span class="cl">    call REMOVEEDGE(TARINDEX) on this node
</span></span><span class="line"><span class="cl">    append (TARINDEX, WEIGHT) to this nodes EDGES </span></span></code></pre></div><ul>
<li><code>remove edge</code>: From the source node, we will call the remove edge function with the target node as input. This will return true if it was successful and false if not.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            remove EDGE from EDGES
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    return false </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph">UML - Graph</h1>


<a href="https://www.youtube.com/watch?v=A6HVJWM3VS4">YouTube Video</a>

<p><a href="#R-image-c52bdb7b38825b5c5c6641baa2341df7" class="lightbox-link"><img alt="List Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c52bdb7b38825b5c5c6641baa2341df7"><img alt="List Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array with dimension <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes. This will be the same logic from our matrix graph.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                TAR = first entry of EDGE
</span></span><span class="line"><span class="cl">                WEIGHT = second entry of EDGE
</span></span><span class="line"><span class="cl">                append (NODE,TAR,WEIGHT) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity. From the source node object, we will call the graph node get edge function on the target index.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(SRC,TAR)
</span></span><span class="line"><span class="cl">    if SRC and TAR are between 0 and capacity
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        WEIGHT = call the graph node GETEDGE from SRCNODE on TAR
</span></span><span class="line"><span class="cl">        return WEIGHT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return infinity</span></span></code></pre></div><ul>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function NUMBEROFEDGES()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                increment COUNT by one
</span></span><span class="line"><span class="cl">    return COUNT</span></span></code></pre></div><ul>
<li><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    SRCNODE = the node at index IDX of the NODES attribute
</span></span><span class="line"><span class="cl">    if SRCNODE is not empty
</span></span><span class="line"><span class="cl">        return SRCNODE&#39;s edges 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return nothing
</span></span><span class="line"><span class="cl">        </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Finding a location for the node will be the same procedure as the matrix graph. If we find an open spot to add the node, we will instantiate a new graph node and insert it into the <code>nodes</code> attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        NEWNODE = graph node with VALUE and IDX for input
</span></span><span class="line"><span class="cl">        add NEWNODE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty. When we set the node to be empty, we clear all of the outgoing edges, so we just need to loop through the other nodes removing any possible incoming edges.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for NODE in NODES
</span></span><span class="line"><span class="cl">                if NODE has no entry
</span></span><span class="line"><span class="cl">                    from NODE call the graph node REMOVEEDGE function on IDX
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SRC, TAR, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE is not empty
</span></span><span class="line"><span class="cl">            from SRCNODE call the graph node ADDEDGE with TAR and WEIGHT as input
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE has no entry
</span></span><span class="line"><span class="cl">            RET = SRCNODE call the graph node REMOVEEDGE with TAR as input
</span></span><span class="line"><span class="cl">            return RET 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p><a href="#R-image-39446538ed180100088f67e263dade4c" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39446538ed180100088f67e263dade4c"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>In this module, we introduced a new way to store the graph data structure. Thus, we now have two ways to work with graphs, in lists and in matrices:</p>
<h2 id="list-representation">List Representation</h2>
<p><a href="#R-image-4aa1b434e71acef47af8e9dbcf41b86c" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4aa1b434e71acef47af8e9dbcf41b86c"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="matrix-representation">Matrix Representation</h2>
<p><a href="#R-image-096db50c0189056a00089dbdb39ab182" class="lightbox-link"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-096db50c0189056a00089dbdb39ab182"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixA.svg"></a></p>
<p>While these methods show the same information, there are cases when one way may be more desirable than the other.</p>
<p>We discussed how a sparse graph is better suited for a list representation and a dense graph is better suited for a matrix representation. We also touched on how working with the edges in a list representation can add complexity to our edge functions. If we are needing to access edge weights or update edges frequently, a matrix representation would be a good choice &ndash; especially if we have a lot of nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 40</div>

<h1 id="graphs-searching-and-traversing">Graphs: Searching and Traversing</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Searching and Traversing</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Searching and Traversing</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=rGiEVQE1hR4">YouTube Video</a>

<p>In the previous modules, we have introduced graphs and two implementations. This module will cover the traversals through graphs as well as path search techniques.</p>
<h2 id="motivation">Motivation</h2>
<p>As we have discussed previously, graphs can have many applications. Based on that, there are many things that we may want to infer from graphs. For example, if we have a graph that depicts a railroad or electrical network, we could determine what maximum flow of the network. The standard approach for this task is the <a href="https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/" rel="external" target="_blank">Ford-Fulkerson Algorithm</a>. In short, given a graph with edge weights that represent capacities the algorithm will determine the maximum flow throughout the graph.</p>
<p>From the matrix graph module, we used the following distribution network as an example.
<a href="#R-image-818b428ecdab0d593509728dc51e2c08" class="lightbox-link"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/distribution-3.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-818b428ecdab0d593509728dc51e2c08"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/distribution-3.svg"></a></p>
<p>Conceptually, we would want to determine the maximum number of units that could leave the distribution center without having excess laying around stores. Using the maximum flow algorithm, we would determine that the maximum number of units would be 15.</p>
<p><a href="#R-image-398dd98b9caac71ea42d4d6661bc1002" class="lightbox-link"><img alt="Max Flow" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/distribution-3MAX.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-398dd98b9caac71ea42d4d6661bc1002"><img alt="Max Flow" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/distribution-3MAX.svg"></a></p>
<p>The driving force in the Ford-Fulkerson algorithm, as well as other maximum  flow algorithms, is the ability to find a path from a source to a target. Specifically, these algorithms use breadth first and depth first searches to discover possible paths.</p>
<h2 id="searches">Searches</h2>
<p>To get to introducing the searches, we will first discuss the basis of them. Those are the depth first traversal and the breadth first traversal. We will outline the premise of these traversals and then discuss how we can modify their algorithms for various tasks, such as path searches.</p>
<p>We can perform these traversals on any type of graph. Conceptually, it will help to have a tree-like structure in mind to differentiate between depth first and breadth first.</p>
<p><a href="#R-image-ea4d8a824cdf62b35cfb75c15ddba897" class="lightbox-link"><img alt="Breadth VS Depth" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/8search_breadthVSdepth.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ea4d8a824cdf62b35cfb75c15ddba897"><img alt="Breadth VS Depth" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/8search_breadthVSdepth.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="depth-first">Depth First</h1>

<p>
<a href="https://www.youtube.com/watch?v=3lalaxn0yNs">YouTube Video</a>

<a href="https://core.cs.ksu.edu/4-cc315/08-graph-traversal/02-graph-traversals-dfs-slides/#/" rel="external" target="_blank">Video Slides</a></p>
<p>First we will discuss Depth First Traversal. We can define the depth first traversal in two ways, iteratively or recursively. For this course, we will define it iteratively.</p>
<p>In the iterative algorithm, we will initialize an empty stack and an empty set. The stack will determine which node we search next and the set will track which nodes we have already searched.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that a stack is a &lsquo;Last In First Out&rsquo; (LIFO) structure. Based on this, the depth first traversal will traverse a nodes descendants before its siblings.</p>
</div>
</div>
<p>To do the traversal, we must pick a starting node; this can be an arbitrary node in our graph. If we were doing the traversal on a tree, we would typically select the root at a starting point. We start a while loop to go through the stack which we will be pushing and popping from. We get the top element of the stack, if the node has not been visited yet then we will add it to the set to note that we have now visited it. Then we get the neighbors of the node and put them onto the stack and continue the process until the stack is empty.</p>
<p><a href="#R-image-c62f3eedd675ac10f79b2a574b837c00" class="lightbox-link"><img alt="DFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/SEARCH_DFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c62f3eedd675ac10f79b2a574b837c00"><img alt="DFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/SEARCH_DFS.gif"></a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function DEPTHFIRST(GRAPH,SRC)
</span></span><span class="line"><span class="cl">    STACK = empty array
</span></span><span class="line"><span class="cl">    DISCOVERED = empty set
</span></span><span class="line"><span class="cl">    append SRC to STACK
</span></span><span class="line"><span class="cl">    while STACK is not empty
</span></span><span class="line"><span class="cl">        CURR = top of the stack
</span></span><span class="line"><span class="cl">        if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">                append NODE to STACK</span></span></code></pre></div><p>Since the order of the neighbors is not guaranteed, the traversal on the same graph with the same starting node can find nodes in different orders.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="breadth-first">Breadth First</h1>


<a href="https://www.youtube.com/watch?v=FViSRGbGn54">YouTube Video</a>

<p><a href="https://core.cs.ksu.edu/4-cc315/08-graph-traversal/03-graph-traversals-bfs-slides/#/" rel="external" target="_blank">Video Slides</a></p>
<p>We can also perform a breadth first traversal either iteratively or recursively. As with the depth first traversal, we will define it iteratively.</p>
<p>In the iterative algorithm, we initialize an empty queue and an empty set. Like depth first traversal, the set will track which nodes we have discovered. We now use a queue to track which node we will search next.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that a queue is a &lsquo;First In First Out&rsquo; (FIFO) structure. Based on this, the breadth first traversal will traverse a nodes siblings before its descendants.</p>
</div>
</div>
<p>Again, we must pick a starting node; this can be an arbitrary node in our graph. We add the starting node to our queue and the set of discovered nodes. We start a while loop to go through the queue which we will be enqueue  and dequeue from. We get the first element of the queue, then get the neighbors of the current node. We loop through each edge adding the neighbor to the discovered set and the queue if it has not already been discovered. We continue this process until the queue is empty.</p>
<p><a href="#R-image-012c767347453912dc7bc6689180230b" class="lightbox-link"><img alt="BFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/SEARCH_BFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-012c767347453912dc7bc6689180230b"><img alt="BFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/SEARCH_BFS.gif"></a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function BREADTHFIRST(GRAPH,SRC)
</span></span><span class="line"><span class="cl">    QUEUE = empty queue
</span></span><span class="line"><span class="cl">    DISCOVERED = empty set
</span></span><span class="line"><span class="cl">    add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">    add SRC to QUEUE
</span></span><span class="line"><span class="cl">    while QUEUE is not empty
</span></span><span class="line"><span class="cl">        CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">                append NODE to QUEUE</span></span></code></pre></div>
  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>It is important to remember in these implementations that a stack is used for depth first and a queue is used for a breadth first. The stack, being a LIFO structure, will proceed with the newest entry which will put us farther away from the source. The queue, being a FIFO structure, will proceed with oldest entry which will focus the algorithm more on the adjacent nodes. If we were to use say a queue for a depth first search, we would be traversing neighbors before descendants.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="limitations">Limitations</h1>


<a href="https://www.youtube.com/watch?v=sSz7UDs0cH8">YouTube Video</a>

<p>When introducing graphs, we discussed how the components of a graph didn&rsquo;t have to all be connected. If our goal is to visit each node, like in the searches, then we will need to perform the search from every node.</p>
<p>For example, the graph below has two separate components. Lets walk through which nodes we will discover by calling the traversals from each node.</p>
<p><a href="#R-image-3655264232911bcfa525ac848ecdb7d9" class="lightbox-link"><img alt="Disconnected Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/8search_dis.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3655264232911bcfa525ac848ecdb7d9"><img alt="Disconnected Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/8search_dis.svg"></a></p>
<table>
<thead>
<tr>
<th>Start</th>
<th>Visited (in alphabetical order)</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>{A, D, H}</td>
</tr>
<tr>
<td>B</td>
<td>{B, E, H, I}</td>
</tr>
<tr>
<td>C</td>
<td>{C}</td>
</tr>
<tr>
<td>D</td>
<td>{D}</td>
</tr>
<tr>
<td>E</td>
<td>{E, H, I}</td>
</tr>
<tr>
<td>F</td>
<td>{C, F}</td>
</tr>
<tr>
<td>G</td>
<td>{C, G}</td>
</tr>
<tr>
<td>H</td>
<td>{H}</td>
</tr>
<tr>
<td>I</td>
<td>{I}</td>
</tr>
<tr>
<td>J</td>
<td>{C, F, G, J}</td>
</tr>
</tbody>
</table>
<p>In this example, we would need to call either traversal on nodes A, B and J in order to visit all of the nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="finding-a-path">Finding a Path</h1>


<a href="https://www.youtube.com/watch?v=DKy-q1hWPpQ">YouTube Video</a>

<p>An important application for these traversals is the ability to find a path between two nodes. This has many applications in railroad networks as well as electrical wiring. With some modifications to the traversals, we can determine if electricity can flow from a source to a target. We will modify depth first and breadth first traversals in similar ways.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>There are three cases that can happen when we search for a path between nodes:</p>
<ul>
<li>No Path: will return nothing</li>
<li>One Path: will return the path</li>
<li>Multiple Paths: will return A path</li>
</ul>
<p>With these searches, we are not guaranteed to return the same path if there are multiple paths.</p>
</div>
</div>
<p>We will call these Depth First Search (DFS) and Breadth First Search (BFS). In both traversals, we have added the following extra lines: 4, 9-16, and 22 through the end.</p>
<p>First, we have the addition of <code>PARENT_MAP</code> which will be a dictionary to keep track of how we get from one node to another. We will use the convention of having the key be the child and the value be the parent. While we use the terms child and parent, this is not exclusive to trees.</p>
<p>The ending portion starting at line 22, will add entries to our dictionary. If we haven&rsquo;t already found an edge to <code>NODE</code>, then we will add the edge that we are currently on.</p>
<p>The other addition is the block of code from line 9 to 16. We will enter this <code>if</code> block if the node that we are currently at is the target. This means that we have finally found a path from the source node to the target node. The process in this segment of code will backtrack through the path and build the path.</p>
<h2 id="depth-first-search-dfs">Depth First Search (DFS)</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     STACK = empty array
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     append SRC to STACK
</span></span><span class="line"><span class="cl">6.     while STACK is not empty
</span></span><span class="line"><span class="cl">7.         CURR = top of the stack
</span></span><span class="line"><span class="cl">8.         if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">9.             if CURR is TAR
</span></span><span class="line"><span class="cl">10.                 PATH = empty array
</span></span><span class="line"><span class="cl">11.                 TRACE = TAR
</span></span><span class="line"><span class="cl">12.                 while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                     append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                     set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                 reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                 return PATH
</span></span><span class="line"><span class="cl">17.            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">18.            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">19.            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">20.                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">21.                append NODE to STACK
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.    return nothing</span></span></code></pre></div><h2 id="dfs-example">DFS Example</h2>
<p><a href="#R-image-11c452cd1e471013d775c68211213434" class="lightbox-link"><img alt="DFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/DFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11c452cd1e471013d775c68211213434"><img alt="DFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/DFS.gif"></a></p>
<h2 id="breadth-first-search-bfs">Breadth First Search (BFS)</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function BREADTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     QUEUE = empty queue
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">6.     add SRC to QUEUE
</span></span><span class="line"><span class="cl">7.     while QUEUE is not empty
</span></span><span class="line"><span class="cl">8.         CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">9.         if CURR is TAR 
</span></span><span class="line"><span class="cl">10.            PATH = empty list 
</span></span><span class="line"><span class="cl">11.            TRACE = TAR
</span></span><span class="line"><span class="cl">12.            while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                    append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                    set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                return PATH
</span></span><span class="line"><span class="cl">17.        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">18.        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">19.            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">20.            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">21.                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.                append NODE to QUEUE
</span></span><span class="line"><span class="cl">25.    return nothing</span></span></code></pre></div><h2 id="bfs-example">BFS Example</h2>
<p><a href="#R-image-e6811e5e6182c487ae91a5145e320ae1" class="lightbox-link"><img alt="BFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/BFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6811e5e6182c487ae91a5145e320ae1"><img alt="BFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/BFS.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="in-practice">In Practice</h1>

<h2 id="traveling">Traveling</h2>
<p>Finding a path in a graph is a very common application in many fields. One application that we benefit from in our day to day lives is traveling. Programs like Google Maps calculate various paths from point A to point B.</p>
<p><a href="#R-image-a970f92454517d78f20f43aa5a8f8df6" class="lightbox-link"><img alt="Google Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/Map.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a970f92454517d78f20f43aa5a8f8df6"><img alt="Google Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/Map.png"></a>^[google.com/maps]</p>
<p>In the context of graph data structures, we can think of each intersection as a node and each road as an edge. Google Maps, however, tracks more features of edges than we have discussed. Not only do they track the distance between intersections, they also track time, tolls, construction, road surface and much more. In the next module, we will discuss more details of how we can find the shortest path.</p>
<h2 id="map-coloring">Map Coloring</h2>
<p>Another application of the general searches is coloring maps. The premise is that we don&rsquo;t want two adjacent territories to have the coloring. These territories could be states, like in the United States map below, counties, provinces, countries, and much more.</p>
<p><a href="#R-image-c25f9901370f46e616518b25fae37b48" class="lightbox-link"><img alt="US Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/USMap.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c25f9901370f46e616518b25fae37b48"><img alt="US Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/USMap.png"></a>^[https://commons.wikimedia.org/wiki/File:Map_of_USA_showing_state_names.png]</p>
<p>The following was generated for this course using the breadth first search and <code>MyMatrixGraph</code> class that we have implemented in this course. To create the visual rendering, the Python library <code>NetworkX</code>^[https://networkx.github.io/] was used. In this rendering, the starting node was Utah. If we were to start from say Alabama or Florida, we would not have a valid four coloring scheme once we got to Nevada. Since Hawaii and Alaska have no land border with any of the states, they can be any color.</p>
<p><a href="#R-image-3ca9afb8983f47e371f2ee75dde0a392" class="lightbox-link"><img alt="Color Generation" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/UsMapColor.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ca9afb8983f47e371f2ee75dde0a392"><img alt="Color Generation" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/UsMapColor.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 45</div>

<h1 id="graphs-minimum-spanning-trees">Graphs: Minimum Spanning Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Minimum Spanning Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Minimum Spanning Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=Rtlwi7b_PF8">YouTube Video</a>

<p>We will continue to work with graph algorithms in this module, specifically with finding minimum spanning trees (MST). MSTs have many real world applications such as:</p>
<ul>
<li>Electrical wiring,</li>
<li>Distribution networks,</li>
<li>Telecommunication networks, and</li>
<li>Network routing</li>
</ul>
<p>Suppose we were building an apartment complex and wanted to determine the most cost-effective wiring schema. Below, we have the possible construction costs for wiring apartment to apartment. Wiring vertically adjacent apartments is cheaper than wiring horizontally adjacent units and those closest to the power closet have lower costs as well.
<a href="#R-image-8c9eda662054f301774efbaaaf955afd" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8c9eda662054f301774efbaaaf955afd"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg"></a></p>
<p>To find the best possible solution, we would find the MST. The final wiring schema may look something like the figure below.
<a href="#R-image-7c791a73f23544e8d38cbbdcb40cb830" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/mini_wire.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c791a73f23544e8d38cbbdcb40cb830"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/mini_wire.svg"></a></p>
<p>Determining a MST can result in lower costs and time used in many applications, especially logistics.
To properly define a minimum spanning tree, we will first introduce the concept of a spanning tree.</p>
<h2 id="spanning-trees">Spanning Trees</h2>
<p>A <strong>spanning tree</strong> for a graph is a subset of the graphs edges such that each node is visited once, no cycles are present, and there are no disconnected components.</p>
<p>Let&rsquo;s look at this graph as an example. We have five nodes and seven edges.</p>
<p><a href="#R-image-ecdc14a437842a41d31faeab54e7235b" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ecdc14a437842a41d31faeab54e7235b"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below, we have valid examples of spanning trees. In each of the examples, we visit each node and there are no cycles. Recall that a cycle is a path in which the starting node and ending node are the same.</p>
<p><a href="#R-image-90ae3da7dad329ec12862d3fe0dd86c1" class="lightbox-link"><img alt="Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90ae3da7dad329ec12862d3fe0dd86c1"><img alt="Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>To be a spanning tree of a graph, it must:</p>
<ul>
<li><strong>span</strong> the graph, meaning all nodes must be visited, and</li>
<li>be a <strong>tree</strong>, meaning there are no cycles and no disconnected components.</li>
</ul>
<p>Further, we can imagine selecting a node in a spanning tree as the root and letting gravity take effect. This gives us a visual motivation as to why they are called spanning trees. In these examples, we have selected node A for the root for each of the spanning trees above.</p>
<p><a href="#R-image-76c03edbdf7d2140997804f67ebdc553" class="lightbox-link"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76c03edbdf7d2140997804f67ebdc553"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg"></a></p>
</div>
</div>
<h2 id="counterexamples">Counterexamples</h2>
<p>Below, we have invalid examples of spanning trees. In the left column, the examples are where all of the nodes are not connected in the same component. In the right column, the examples contain cycles. For example in the top right, we have the cycle <code>B-&gt;C-&gt;D-&gt;E-&gt;B</code></p>
<p><a href="#R-image-7faf8765855090da021267d078230949" class="lightbox-link"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7faf8765855090da021267d078230949"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="minimum-spanning-trees">Minimum Spanning Trees</h1>


<a href="https://www.youtube.com/watch?v=sMo3sTRoVrE">YouTube Video</a>

<p>Now that we have an understanding of general spanning trees, we will introduce the concept of minimum spanning trees. First let&rsquo;s introduce the concept of the cost of a tree.</p>
<p>The <strong>cost</strong> that is associated with a tree, is the sum of its edges weights. Let&rsquo;s look at this spanning tree which is from the previous page. The cost associated with this spanning tree is: <code>2+6+10+14=32</code>.
<a href="#R-image-5099f22c686b1cab603cd3dae07a4eea" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5099f22c686b1cab603cd3dae07a4eea"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg"></a></p>
<h2 id="minimum-spanning-trees-mst">Minimum Spanning Trees (MST)</h2>
<p>A <strong>minimum spanning tree</strong> is a spanning tree that has the smallest cost. Recall the graph from the previous page.</p>
<p><a href="#R-image-5172e5eb1cf105c85eb4586da8b53598" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5172e5eb1cf105c85eb4586da8b53598"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below on the left is a minimum spanning tree for the graph above. On the right is an example of a spanning tree, though it does not have the minimum cost.</p>
<p><a href="#R-image-414e86b34ccfb3b8efec15cf6e32933a" class="lightbox-link"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-414e86b34ccfb3b8efec15cf6e32933a"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg"></a></p>
<p>In this small example, it is rather straightforward to find the minimum spanning tree. We can use a bit of trial and error to determine if we have the minimum spanning tree or not. However, once the graphs start to get more nodes and more edges it quickly becomes more complicated.</p>
<p><a href="#R-image-2008a6cfe70e9469d9dd97b34968c2bd" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2008a6cfe70e9469d9dd97b34968c2bd"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg"></a></p>
<p>There are two algorithms that we will introduce to give us a methodical way of finding the minimum spanning tree. The first that we will look at is Kruskal&rsquo;s algorithm and then we will look at Prim&rsquo;s algorithm.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="kruskal">Kruskal</h1>


<a href="https://www.youtube.com/watch?v=av-r-orP56g">YouTube Video</a>

<p>As graphs get larger, it is important to go about finding the MST in a methodical way. In the mid 1950&rsquo;s, there was a desire to form an algorithmic approach for solving the &rsquo;traveling salesperson&rsquo; problem^[We will describe this problem in a future section of this module]. Joseph Kruskal first published this algorithm in 1956 in the Proceedings of the American Mathematical Society^[https://www.ams.org/journals/proc/1956-007-01/S0002-9939-1956-0078686-7/S0002-9939-1956-0078686-7.pdf]. The algorithms prior to this were, as Kruskal said, &ldquo;unnecessarily elaborate&rdquo; thus the need for a more succinct algorithm arose.</p>
<h2 id="algorithm">Algorithm</h2>
<p>In his original work, Kruskal outlined three different yet similar algorithms to finding a minimum spanning tree. The <code>Kruskal Algorithm</code> that we use is as follows:</p>
<ol>
<li>Start with only the nodes of the graph and an empty set for the edges</li>
<li>Order the edges based on weight</li>
<li>Make each node their own set</li>
<li>Go through the edges in ascending order</li>
<li>If nodes <code>u</code> and <code>v</code> are connected by the edge and they are not in the same set yet, then join the two sets and add the edge to your set of edges</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-b734a7c9f7af18ee25c84e32756ec81d" class="lightbox-link"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b734a7c9f7af18ee25c84e32756ec81d"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-1d5354a10d54ddb2790a8b6b74e50dfa" class="lightbox-link"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/kruskal.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d5354a10d54ddb2790a8b6b74e50dfa"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/kruskal.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-b3141efbf7258510661b9690e3976b12" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3141efbf7258510661b9690e3976b12"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></p>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function KRUSKAL(GRAPH)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    ALLSETS = an empty list which will contain the sets
</span></span><span class="line"><span class="cl">    for NODE in GRAPH NODES
</span></span><span class="line"><span class="cl">        SET = a set with element NODE
</span></span><span class="line"><span class="cl">        add SET to ALLSETS
</span></span><span class="line"><span class="cl">    EDGES = list of GRAPH&#39;s edges
</span></span><span class="line"><span class="cl">    SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span class="line"><span class="cl">    for EDGE in SORTEDEDGES
</span></span><span class="line"><span class="cl">        SRC = source node of EDGE
</span></span><span class="line"><span class="cl">        TAR = target node of EDGE
</span></span><span class="line"><span class="cl">        SRCSET = the set from SETS in which SRC is contained
</span></span><span class="line"><span class="cl">        TARSET = the set form SETS in which TAR is contained
</span></span><span class="line"><span class="cl">        if SRCSET not equal TARSET
</span></span><span class="line"><span class="cl">            UNIONSET = SRCSET union TARSET
</span></span><span class="line"><span class="cl">            add UNIONSET to ALLSETS
</span></span><span class="line"><span class="cl">            remove SRCSET from ALLSETS
</span></span><span class="line"><span class="cl">            remove TARSET from ALLSETS
</span></span><span class="line"><span class="cl">            add EDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="prim">Prim</h1>


<a href="https://www.youtube.com/watch?v=B9bG6FTj5pA">YouTube Video</a>

<p>The history of <code>Prim's Algorithm</code> is not as straight forward as Kruskal&rsquo;s. While we often call it <code>Prim's Algorithm</code>, it was originally developed in 1930 by VojtÄ›ch JarnÃ­k. Robert Prim later rediscovered and republished this algorithm in 1957, one year after Kruskals. To add to the naming confusion, Edsger Dijkstra also published this work again in 1959. Because of this, the algorithm can go by many names: <code>JarkÃ­k's Algorithm</code>, <code>JarnÃ­k-Prim's Algorithm</code>, <code>Prim-Dijkstra's Algorithm</code>, and <code>DJP Algorithm</code>.</p>
<p>Prim cited &ldquo;large-scale communication&rdquo; as the motivation for this algorithm, specifically the &ldquo;Bell System leased-line&rdquo;^[R.C. Prim, May 8, 1957 Shortest Connection Networks And Some Generalizations https://archive.org/details/bstj36-6-1389]. Leased lines were used primarily in a commercial setting which connected business offices that were geographically distant (IE in different cities or even states). Companies would want all offices to be connected but wanted to avoid having to lay an excessive amount of wire. Below is a figure which Prim used to motivate the need for the algorithm. This image depicts the minimum spanning tree which connect each of the US continental state capitals along with Washington D.C.</p>
<p><a href="#R-image-efe8bead36361e00448b13aa4dca0f39" class="lightbox-link"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim_US.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-efe8bead36361e00448b13aa4dca0f39"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim_US.png"></a></p>
<h2 id="algorithm">Algorithm</h2>
<p>The basis of the algorithm is to start with only the nodes of the graph, then we do the following</p>
<ol>
<li>Choose a random node</li>
<li>Grow your tree by one edge, selecting the smallest edge to connect to a node that is not yet in the tree. Repeat until all the nodes have been visited</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-5a0aadd8df5cd9ff84398aa895c86390" class="lightbox-link"><img alt="Prim Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5a0aadd8df5cd9ff84398aa895c86390"><img alt="Prim Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-ff7645d235f2596ae894d47222ce3062" class="lightbox-link"><img alt="Prim Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff7645d235f2596ae894d47222ce3062"><img alt="Prim Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-a7d5cc2bf1fc4cec24a684c4fa510dc0" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a7d5cc2bf1fc4cec24a684c4fa510dc0"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Uniqueness</strong></p>
<p>You may have noticed that the minimum spanning tree that resulted from Kruskal&rsquo;s algorithm differed from Prim&rsquo;s algorithm. We have displaying them both below for reference.</p>
<table>
<thead>
<tr>
<th>Kruskal</th>
<th>Prim</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#R-image-0f0d9a4d8a0d2b88a98ddd5fce068d14" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f0d9a4d8a0d2b88a98ddd5fce068d14"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></td>
<td><a href="#R-image-eeeb8c54d5312fd8bb5e2a24f7fa57ff" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-eeeb8c54d5312fd8bb5e2a24f7fa57ff"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></td>
</tr>
</tbody>
</table>
<p>While these are different, they are both valid. The trees both have cost 16. The MST of a graph will be unique, meaning there is only one, if none of the edges of the graph have the same weight.</p>
</div>
</div>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRIM(GRAPH, START)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    VISITED = empty set
</span></span><span class="line"><span class="cl">    add START to VISITED
</span></span><span class="line"><span class="cl">    AVAILEDGES = list of edges where START is the source
</span></span><span class="line"><span class="cl">    sort AVAILEDGES
</span></span><span class="line"><span class="cl">    while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">        SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">        SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">        if TAR not in VISITED
</span></span><span class="line"><span class="cl">            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">            add TAR to VISITED
</span></span><span class="line"><span class="cl">            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">        sort AVAILEDGES
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="traveling-salesperson">Traveling Salesperson</h1>


<a href="https://www.youtube.com/watch?v=txzR-tM6z7M">YouTube Video</a>


<a href="https://www.youtube.com/watch?v=OPvOpQ6w734">YouTube Video</a>

<p>While we won&rsquo;t outline algorithms suited for solving the traveling salesperson problem (TSP), we will outline the premise of the problem. This problem was first posed in 1832, almost a two centuries ago, and is still quite prevalent. It is applicable to traveling routes, distribution networks, computer architecture and much more. The TSP is a seminal problem that has motivated many research breakthroughs, including Kruskals algorithm!</p>
<p>The motivation of the TSP is this: given a set of locations, what is the shortest path such that we can visit each location and end back where started?</p>
<p>Suppose we wanted to take a roadtrip with friends to every state capital in the continental US as well as Washington D.C. To save money and time, we would want to minimize the distance that we travel. Since we are taking a roadtrip, we would want to avoid frivolous driving. For example, if we start in Sacremento, CA we would not want to end the trip in Boston, MA. The trip should start and end at the same location for efficiency.</p>
<p>The figure below shows the shortest trip that visits each state capital and Washington D.C. once. In this example, we can start where ever we like and will end up where we started.
<a href="#R-image-6df828c24d59a56efc97372cb26aa4d3" class="lightbox-link"><img alt="Visit each state capital" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6df828c24d59a56efc97372cb26aa4d3"><img alt="Visit each state capital" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png"></a>^[PatriciaNeri, August 2018 https://communities.sas.com/t5/SAS-Communities-Library/What-is-the-shortest-tour-that-visits-only-once-the-48/ta-p/490231]</p>
<p>In this problem, it is easy to get overwhelmed by all of the possibilities. Since there are 49 cities to visit, there are over <code>6.2*10^60</code> possibilities. For reference, <code>10^12</code> is equivalent to one trillion! Thus, we need an algorithmic approach to solve this problem as opposed to a brute force method.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
        </div>
      </main>
    
<div class="git-footer">
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1719522770" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1719522770" defer></script>
    <script src="/cc315/js/theme.js?1719522770" defer></script>
  </body>
</html>
