




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Welcome! This page is the main page for Graphs: List Representation">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Graphs: List Representation :: CC 315 Textbook">
    <meta name="twitter:description" content="Welcome! This page is the main page for Graphs: List Representation">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/iii-graphs/7-graphs--list-representation/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Graphs: List Representation :: CC 315 Textbook">
    <meta property="og:description" content="Welcome! This page is the main page for Graphs: List Representation">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Graphs: List Representation :: CC 315 Textbook">
    <meta itemprop="description" content="Welcome! This page is the main page for Graphs: List Representation">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2021-10-21T16:59:20-05:00">
    <meta itemprop="wordCount" content="11">
    <title>Graphs: List Representation :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/iii-graphs/7-graphs--list-representation/" rel="canonical" type="text/html" title="Graphs: List Representation :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/7-graphs--list-representation/index.xml" rel="alternate" type="application/rss+xml" title="Graphs: List Representation :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/7-graphs--list-representation/tele.html" rel="alternate" type="text/html" title="Graphs: List Representation :: CC 315 Textbook">
    <link href="/cc315/iii-graphs/7-graphs--list-representation/embed.html" rel="alternate" type="text/html" title="Graphs: List Representation :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1737135054" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1737135054" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/print.css?1737135054" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1737135054" rel="stylesheet">
    <script src="/cc315/js/variant.js?1737135054"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1737135054" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/iii-graphs/7-graphs--list-representation/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/iii-graphs/"><span itemprop="name">Iii-Graphs</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Graphs: List Representation</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/iii-graphs/6-graphs--matrix-representation/10-summary/" title="Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/iii-graphs/7-graphs--list-representation/1-introduction/" title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 35</div>

<h1 id="graphs-list-representation">Graphs: List Representation</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: List Representation</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: List Representation</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=DgN_qmbtK_M">YouTube Video</a>

<p>In the previous module, we introduced graphs and a matrix-based implementation. For this module, we will continue working with graphs and change our implementation to lists.</p>
<h2 id="why-another-implementation">Why Another Implementation?</h2>
<p>When using graphs, a lot of situational variation can occur. Some graphs can have a few nodes with many edges, many nodes with few edges, and so on. When we use the matrix implementation, we initialize a matrix with the number of columns and rows equal to the number of nodes. For example, if we have a graph with 20 nodes, our adjacency matrix would have 20 rows and 20 columns, resulting in 400 potential entries.</p>
<p>First let&rsquo;s look at the implementation and then we will discuss when one may be better than the other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-representation">List Representation</h1>


<a href="https://www.youtube.com/watch?v=MJqStsuqf_U">YouTube Video</a>

<p>In the matrix representation, we had an array of the node items. In the list representation, we will have an array of node objects. Each <strong>node object</strong> will keep track of the node item, the node index, and the outgoing edges.</p>
<p><a href="#R-image-9fc96ceccb8f25afdb63d1d74d5fba16" class="lightbox-link"><img alt="Set Up" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9fc96ceccb8f25afdb63d1d74d5fba16"><img alt="Set Up" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg"></a></p>
<p>The <code>item</code> can be any object and the <code>index</code> will be a value within our capacity. The <code>edges</code> will be a list of pairs where the first entry is the index of the target node and the second entry is the weight of the edge.</p>
<p>Since each node will track its neighbors, it is important that we are consistent in our indexing of nodes. If our nodes were to get out of order, then our edges would as well.</p>
<h2 id="example-1">Example 1</h2>
<p>Consider the following graph which we saw in the matrix representation.</p>
<p><a href="#R-image-680a7a4e4802e1397f1a9a4521d8b6f1" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-680a7a4e4802e1397f1a9a4521d8b6f1"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>The following list of nodes depicts the graph above. We can see that each node object has the item and index.</p>
<p>If we look closer at the <code>edges</code> of the node with item <code>A</code> and index <code>1</code>, we see that the set of edges is equal to <code>[(4, 3.0), (6, 4.0)]</code>. This corresponds to the fact that there are two edges with the source as node <code>1</code>. The first ordered pair, <code>(4, 3.0)</code>, means that there is an edge with source node <code>1</code> (<code>A</code>) and target node <code>4</code> (<code>D</code>) that has weight <code>3</code>. We can confirm that in our graph we do have an edge from <code>A</code> to <code>D</code> with weight <code>3</code>.</p>
<p><a href="#R-image-758f978e793137b8e2feed2d14dbd4e1" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-758f978e793137b8e2feed2d14dbd4e1"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="example-2">Example 2</h2>
<p>The following includes a couple of examples of loops within our graph.</p>
<p><a href="#R-image-1d3fc583340b4d59c0a082f2a2736b6b" class="lightbox-link"><img alt="Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d3fc583340b4d59c0a082f2a2736b6b"><img alt="Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a></p>
<p>We have loops on nodes <code>D</code>, <code>E</code>, and <code>F</code> in our graph. Recall that a loop is an edge where the source and target are the same. For example, we have an edge with source <code>D</code> and target <code>D</code> that has weight <code>12</code>. We see this in our list representation in the node object with item <code>D</code> and index <code>4</code>, where we have the entry <code>(4,12.0)</code> in the edges.</p>
<p><a href="#R-image-506ac62af2bcba2414e6405dbed649da" class="lightbox-link"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-506ac62af2bcba2414e6405dbed649da"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="dense-vs-sparse">Dense VS Sparse</h1>


<a href="https://www.youtube.com/watch?v=y4bCalShe_Y">YouTube Video</a>

<p>When considering which implementation to use, we need to consider the connectivity in our graph. The terms that we use to describe the connectedness are <strong>dense</strong> and <strong>sparse</strong>.</p>
<ul>
<li><code>Dense Graph</code>: A dense graph is a graph in which there is a large number of edges. Typically in a dense graph, the number of edges is close to the maximum number of edges.</li>
<li><code>Sparse Graph</code>: A sparse graph is a graph in which there is a small number of edges. In this case the number of edges is considerably less than the maximum number of edges.</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Intuitively, we can think of dense and sparse in terms of populations. For example, if 100 people lived in a city block, we can consider that to be densely populated. If 100 people lived in 100 square miles we can consider that to be sparsely populated.</p>
</div>
</div>
<p>Let&rsquo;s look at some motivating examples to get an idea of how the different structures will handle these cases.</p>
<h2 id="dense">Dense</h2>
<p>The following is a dense graph. In this case, our graph does have the maximum number of edges. This means that every node is connected to every other node including itself.</p>
<p><a href="#R-image-90088ddb4ec127f3ecbb71e6aa6165e2" class="lightbox-link"><img alt="Dense Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90088ddb4ec127f3ecbb71e6aa6165e2"><img alt="Dense Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_graph.svg"></a>
<a href="#R-image-f4557bbc4bf75f0750d7b7d03a3fae51" class="lightbox-link"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f4557bbc4bf75f0750d7b7d03a3fae51"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg"></a>
<a href="#R-image-33722a64e480edae635b88015960805e" class="lightbox-link"><img alt="Dense Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-33722a64e480edae635b88015960805e"><img alt="Dense Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_list.svg"></a></p>
<h2 id="sparse">Sparse</h2>
<p>The following is a sparse graph.</p>
<p><a href="#R-image-1ced6771bc87d8e9d0ab6c9ca5721aa4" class="lightbox-link"><img alt="Sparse Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ced6771bc87d8e9d0ab6c9ca5721aa4"><img alt="Sparse Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg"></a>
<a href="#R-image-a19020b39f477295de0fb7b7ebe03d24" class="lightbox-link"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a19020b39f477295de0fb7b7ebe03d24"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg"></a>
<a href="#R-image-a32cb8d7fee65350a815bc4158bdff74" class="lightbox-link"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a32cb8d7fee65350a815bc4158bdff74"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_list.svg"></a></p>
<h2 id="list-or-matrix">List or Matrix?</h2>
<p>For dense graphs, the matrix representation will have better qualities as we are already setting aside space for the maximum number of edges. Sparse graphs are better represented in the list representation.</p>
<p>When we initialize the matrix implementation, we initialize the <code>nodes</code> attribute to have dimension equal to the capacity of the graph. The <code>edges</code> attribute is initialized to be a square matrix with dimension equal to capacity by capacity. Thus, if we have a sparse matrix, we are representing a lot of non-existent edges.</p>
<p>When we initialize the list implementation, we just have the <code>nodes</code> attribute which has dimension equal to the capacity and each node tracks its own edges. If we have a dense matrix and we are searching for an edge, we must loop through each edge from the target node to see if the edge exists. In the matrix representation, we can access that edge directly.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>If the proportion of edges to the maximum number of edges is greater than 1/64, then the matrix representation is better in terms of space.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph-node">UML - Graph Node</h1>


<a href="https://www.youtube.com/watch?v=BVgbAW7NZY8">YouTube Video</a>

<p>In this representation, we will have an array of graph node objects. We will first cover the UML for the graph node objects and then discuss the graph functions and attributes.</p>
<p><a href="#R-image-e2666fee8e90f5857a9a85b1a4c57b8f" class="lightbox-link"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2666fee8e90f5857a9a85b1a4c57b8f"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>item</code>: the value that the node contains.</li>
<li><code>index</code>: the index of the node.</li>
<li><code>edges</code>: ordered pairs <code>(e, w)</code> where this node is the source, <code>e</code> is the target node index, and <code>w</code> is the weight of the edge as a double.</li>
</ul>
<p>We will initialize a graph node with the given item and the given index. We initialize the <code>edges</code> attribute to be an empty list.</p>
<h2 id="getters">Getters</h2>
<ul>
<li>
<p><code>get item</code>: Returns the graph node&rsquo;s item.</p>
</li>
<li>
<p><code>get index</code>: Returns the graph node&rsquo;s index.</p>
</li>
<li>
<p><code>get edges</code>: Returns the graph node&rsquo;s edges.</p>
</li>
<li>
<p><code>get edge</code>: From the source node, we will call the get edge function with the index of the target node as input. This will return the edge weight.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            return the second element in EDGE
</span></span><span class="line"><span class="cl">    return infinity </span></span></code></pre></div><h2 id="edge-functions">Edge Functions</h2>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Working with the edges in our graph becomes slightly more complicated in the list representation. Previously, we were able to go right to the entry in our adjacency matrix and update it. Since each node keeps track of its own edges in no particular order, we must loop through each entry of the edges attribute to find a potential edge.</p>
</div>
</div>
<ul>
<li><code>add edge</code>: From the source node, we will call the add edge function with the target node as input as well as the weight. First, we will attempt to remove the edge. We need to do this as we do not want duplicate edges in our graph. Then we will add the ordered pair to the edges attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(TARINDEX, WEIGHT)
</span></span><span class="line"><span class="cl">    call REMOVEEDGE(TARINDEX) on this node
</span></span><span class="line"><span class="cl">    append (TARINDEX, WEIGHT) to this nodes EDGES </span></span></code></pre></div><ul>
<li><code>remove edge</code>: From the source node, we will call the remove edge function with the target node as input. This will return true if it was successful and false if not.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            remove EDGE from EDGES
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    return false </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph">UML - Graph</h1>


<a href="https://www.youtube.com/watch?v=A6HVJWM3VS4">YouTube Video</a>

<p><a href="#R-image-a0eed3f0a31bb0055b2cc01af6510377" class="lightbox-link"><img alt="List Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0eed3f0a31bb0055b2cc01af6510377"><img alt="List Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array with dimension <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes. This will be the same logic from our matrix graph.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                TAR = first entry of EDGE
</span></span><span class="line"><span class="cl">                WEIGHT = second entry of EDGE
</span></span><span class="line"><span class="cl">                append (NODE,TAR,WEIGHT) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity. From the source node object, we will call the graph node get edge function on the target index.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(SRC,TAR)
</span></span><span class="line"><span class="cl">    if SRC and TAR are between 0 and capacity
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        WEIGHT = call the graph node GETEDGE from SRCNODE on TAR
</span></span><span class="line"><span class="cl">        return WEIGHT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return infinity</span></span></code></pre></div><ul>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function NUMBEROFEDGES()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                increment COUNT by one
</span></span><span class="line"><span class="cl">    return COUNT</span></span></code></pre></div><ul>
<li><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    SRCNODE = the node at index IDX of the NODES attribute
</span></span><span class="line"><span class="cl">    if SRCNODE is not empty
</span></span><span class="line"><span class="cl">        return SRCNODE&#39;s edges 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return nothing
</span></span><span class="line"><span class="cl">        </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Finding a location for the node will be the same procedure as the matrix graph. If we find an open spot to add the node, we will instantiate a new graph node and insert it into the <code>nodes</code> attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        NEWNODE = graph node with VALUE and IDX for input
</span></span><span class="line"><span class="cl">        add NEWNODE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty. When we set the node to be empty, we clear all of the outgoing edges, so we just need to loop through the other nodes removing any possible incoming edges.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for NODE in NODES
</span></span><span class="line"><span class="cl">                if NODE has no entry
</span></span><span class="line"><span class="cl">                    from NODE call the graph node REMOVEEDGE function on IDX
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SRC, TAR, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE is not empty
</span></span><span class="line"><span class="cl">            from SRCNODE call the graph node ADDEDGE with TAR and WEIGHT as input
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE has no entry
</span></span><span class="line"><span class="cl">            RET = SRCNODE call the graph node REMOVEEDGE with TAR as input
</span></span><span class="line"><span class="cl">            return RET 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p><a href="#R-image-757cc5bc72c23d6166ddd5d19b9cd7a4" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-757cc5bc72c23d6166ddd5d19b9cd7a4"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>In this module, we introduced a new way to store the graph data structure. Thus, we now have two ways to work with graphs, in lists and in matrices:</p>
<h2 id="list-representation">List Representation</h2>
<p><a href="#R-image-b03c712d02a0290e30f053f7d5a64306" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b03c712d02a0290e30f053f7d5a64306"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="matrix-representation">Matrix Representation</h2>
<p><a href="#R-image-9c92ff91369dd8f26843631b8fcdce1d" class="lightbox-link"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9c92ff91369dd8f26843631b8fcdce1d"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixA.svg"></a></p>
<p>While these methods show the same information, there are cases when one way may be more desirable than the other.</p>
<p>We discussed how a sparse graph is better suited for a list representation and a dense graph is better suited for a matrix representation. We also touched on how working with the edges in a list representation can add complexity to our edge functions. If we are needing to access edge weights or update edges frequently, a matrix representation would be a good choice &ndash; especially if we have a lot of nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Emily Alfs
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/499f4d824a58536af610d92fd6aa49d60ed20d97">Oct 21, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1737135054" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1737135054" defer></script>
    <script src="/cc315/js/theme.js?1737135054" defer></script>
  </body>
</html>
