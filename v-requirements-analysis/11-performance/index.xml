




	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on CC 315 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/</link>
    <description>Recent content in Performance on CC 315 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Module Outline</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/1-module-outline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/1-module-outline/</guid>
      <description>In this module, we will reintroduce the data structures that we have seen and implemented throughout CC315 as well as CC310. We will discuss the running time for various operations as well as space requirements for each structure.
You may recall that in CC310, we did a similar comparison. We will use most of the same operations from that module so we can draw comparisons between the structures in CC310 and CC315.</description>
    </item>
    <item>
      <title>Trees</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/2-trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/2-trees/</guid>
      <description>There are three types of trees to consider: generic trees, tries, and binary trees.
General Trees Insert: In general, inserting an element into a tree by making it a child of an existing tree is a constant time operation. However, this depends on us already having access to the parent tree we&amp;rsquo;d like to add the item to, which may require searching for that element in the tree as discussed below, which runs in linear time based on the size of the tree.</description>
    </item>
    <item>
      <title>Graphs</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/3-graphs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/3-graphs/</guid>
      <description>There are two types of graphs that we&amp;rsquo;ve covered in this class: list graphs and matrix graphs. Graphs are slightly different than other data structures, because we may want to find or access both nodes and edges in the graph. So, we&amp;rsquo;ll need to analyze the performance of graphs with respect to both nodes and edges.
Matrix Graph Recall that a matrix graph uses an array to store the nodes, and a two-dimensional array to store the edges.</description>
    </item>
    <item>
      <title>Priority Queues</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/4-priority-queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/4-priority-queues/</guid>
      <description>Let&amp;rsquo;s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the heap properties that it must maintain.
Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:
Each node has at most two children. If there are nodes in level i of the tree, then level i-1 is full.</description>
    </item>
    <item>
      <title>315 Structure Performance Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/5-315-structure-performance-summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/5-315-structure-performance-summary/</guid>
      <description>This page will be devoted to summarizing our performance discussions. Below, we have included a graph for a frame of reference for the various functions.
Generic Trees In the following, $n$ denotes the number of nodes in the tree.
Insert: 1 if we have the parent but $n$ if we have to find the parent Access: 1 if we want to access the root but $n$ otherwise Find: $n$ Delete: $n$ if we have to find the parent Memory: $n$ Tries In the following, $m$ denotes the length of a word and $n$ denotes the number of words in the trie.</description>
    </item>
    <item>
      <title>Tree Algorithms</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/6-tree-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/6-tree-algorithms/</guid>
      <description>We will now discuss the performance of the algorithms that we discussed in this course. When examining the performance of an algorithm we will look at the time and the space that it will require.
Time: To analyze the time of an algorithm, we will look at the number of operations required to complete the algorithm. Space: To analyze the space requirement of an algorithm, we will look at the various variables within the algorithm.</description>
    </item>
    <item>
      <title>Graph Algorithms</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/</guid>
      <description>Path Searches 1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2. STACK = empty array 3. DISCOVERED = empty set 4. PARENT_MAP = empty dictionary 5. append SRC to STACK 6. while STACK is not empty 7. CURR = top of the stack 8. if CURR not in DISCOVERED 9. if CURR is TAR 10. PATH = empty array 11. TRACE = TAR 12. while TRACE is not SRC 13. append TRACE to PATH 14. set TRACE equal to PARENT_MAP[TRACE] 15.</description>
    </item>
    <item>
      <title>310 Structure Performance Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/8-310-structure-performance-summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/8-310-structure-performance-summary/</guid>
      <description>Stacks A stack is a data structure with two main operations that are simple in concept. One is the push operation that lets you put data into the data structure and the other is the pop operation that lets you get data out of the structure.
A stack is what we call a Last In First Out (LIFO) data structure. That means that when we pop a piece of data off the stack, we get the last piece of data we put on the stack.</description>
    </item>
  </channel>
</rss>