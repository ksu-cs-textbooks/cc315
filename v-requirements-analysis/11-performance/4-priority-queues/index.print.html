




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="YouTube Video Let’s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the heap properties that it must maintain.
Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:
Each node has at most two children. If there are nodes in level i of the tree, then level i-1 is full.">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Priority Queues :: CC 315 Textbook">
    <meta name="twitter:description" content="YouTube Video Let’s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the heap properties that it must maintain.
Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:
Each node has at most two children. If there are nodes in level i of the tree, then level i-1 is full.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/v-requirements-analysis/11-performance/4-priority-queues/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Priority Queues :: CC 315 Textbook">
    <meta property="og:description" content="YouTube Video Let’s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the heap properties that it must maintain.
Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:
Each node has at most two children. If there are nodes in level i of the tree, then level i-1 is full.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="V-Requirements-Analyses">
    <meta property="article:modified_time" content="2024-06-27T16:12:13-05:00">
    <meta itemprop="name" content="Priority Queues :: CC 315 Textbook">
    <meta itemprop="description" content="YouTube Video Let’s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the heap properties that it must maintain.
Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:
Each node has at most two children. If there are nodes in level i of the tree, then level i-1 is full.">
    <meta itemprop="dateModified" content="2024-06-27T16:12:13-05:00">
    <meta itemprop="wordCount" content="563">
    <title>Priority Queues :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/v-requirements-analysis/11-performance/4-priority-queues/" rel="canonical" type="text/html" title="Priority Queues :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/4-priority-queues/index.xml" rel="alternate" type="application/rss+xml" title="Priority Queues :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/4-priority-queues/tele.html" rel="alternate" type="text/html" title="Priority Queues :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/4-priority-queues/embed.html" rel="alternate" type="text/html" title="Priority Queues :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1737135054" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1737135054" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/print.css?1737135054" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1737135054" rel="stylesheet">
    <script src="/cc315/js/variant.js?1737135054"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1737135054" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/v-requirements-analysis/11-performance/4-priority-queues/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/v-requirements-analysis/"><span itemprop="name">V-Requirements-Analyses</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/v-requirements-analysis/11-performance/"><span itemprop="name">Performance</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Priority Queues</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/v-requirements-analysis/11-performance/3-graphs/" title="Graphs (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/v-requirements-analysis/11-performance/5-315-structure-performance-summary/" title="315 Structure Performance Summary (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="priority-queues">Priority Queues</h1>


<a href="https://www.youtube.com/watch?v=doAjYITSxQI">YouTube Video</a>

<p><a href="#R-image-59d0e38435721346379106fc3e2ddd0f" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59d0e38435721346379106fc3e2ddd0f"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg"></a></p>
<p>Let&rsquo;s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the <em>heap properties</em> that it must maintain.</p>
<p>Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:</p>
<ol>
<li>Each node has at most two children.</li>
<li>If there are nodes in level <code>i</code> of the tree, then level <code>i-1</code> is full.</li>
<li>The nodes of the last level are as far left as possible.</li>
</ol>
<ul>
<li>
<p><strong>Insert</strong> To insert a new element in a priority queue, we place it at the end and then push it upwards until it is in the correct place. Because the heap property creates a perfectly balanced tree, at most it will have to perform $log_2(n)$ or $h$ operations. So, we say that insert runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Access Minimum</strong> The most common operation for accessing elements in the priority queue is to access the minimum element. Since it should always be the first element in the array due to the heap properties, this is clearly a constant time operation.</p>
</li>
<li>
<p><strong>Find Element</strong> To find an item in a priority queue, we must simply iterate through the array that stores the heap, which is a linear time operation based on the number of elements in the heap.</p>
</li>
<li>
<p><strong>Remove Minimum</strong> To remove the smallest element, we swap it with the last element and then remove it, then push the top element down into place. Similar to the push up operation, at most it will perform $log_2(n)$ or $h$ operations. So, we say that remove minimum runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Heapify</strong> This is the most interesting operation of a heap. When we use heapify, we add a large number of elements to the heap and then sort it exactly once by working from the bottom to the top and pushing down each element into place. On the surface, it appears that this should run in the order $n * log_2(n)$ time, since each push down operation takes $log_2(n)$ time, and we have to do that on the order of $n$ times to get each element in place. However, using a bit of mathematical analysis, it is possible to prove that this operation actually runs in linear time $n$ based on the number of elements. The work to actually prove this is a bit beyond the scope of this course, but <a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" rel="external" target="_blank">this StackOverflow discussion</a> is a great explanation of how it works.</p>
</li>
<li>
<p><strong>Memory</strong>: In terms of memory usage, a priority queue uses memory that is on the order of the number of elements in the priority queue.</p>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<h1 id="heapify-and-heap-sort">Heapify and Heap Sort</h1>
<p>Why is it important that heapify runs in linear time? That is because we can use heapify and remove minimum to sort data, which is a sorting algorithm known as heap sort.</p>
<p>We already saw that heapify runs in linear time based on the number of nodes, and each remove minimum operation runs in $log_2(n)$ time. To remove all the elements of the heap, we would do that $n$ times, so the overall time would be $n * log_2(n)$ time. If you recall, that is the same performance as merge sort and quicksort!</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/bc8ecbfe82c5e647ee7b79ce66d9924b9f2ba36c">Jun 27, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1737135054" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1737135054" defer></script>
    <script src="/cc315/js/theme.js?1737135054" defer></script>
  </body>
</html>
