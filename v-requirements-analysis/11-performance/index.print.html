




	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.2.0+tip">
    <meta name="description" content="K-State CC315 General Textbook">
    <meta name="author" content="Emily Alfs-Votipka">
    <title>Performance :: CC 315 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/" rel="canonical" type="text/html" title="CC 315 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/index.xml" rel="alternate" type="application/rss+xml" title="CC 315 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/tele.html" rel="alternate" type="text/html" title="CC 315 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/embed.html" rel="alternate" type="text/html" title="CC 315 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/fontawesome-all.min.css?1660069144" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc315/css/fontawesome-all.min.css?1660069144" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/featherlight.min.css?1660069144" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc315/css/featherlight.min.css?1660069144" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/auto-complete.css?1660069144" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc315/css/auto-complete.css?1660069144" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/perfect-scrollbar.min.css?1660069144" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/nucleus.css?1660069144" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/fonts.css?1660069144" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc315/css/fonts.css?1660069144" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/theme.css?1660069144" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/theme-light-theme.css?1660069144" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/ie.css?1660069144" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/variant.css?1660069144" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/print.css?1660069144" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/format-print.css?1660069144" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/variant.js?1660069144"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cc315/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cc315/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cc315/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cc315/css/custom.css?1660069144" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/jquery.min.js?1660069144" defer></script>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/1-module-outline/" title="Module Outline (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/" title="V-requirements-analyses (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/index.print.html">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit (CTRL+ALT+e)' href="https://gitlab.cs.ksu.edu/cc/315/generic/textbook/-/tree/master/content/v-requirements-analysis/11-Performance/_index.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="3" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cc315/"><span itemprop="name">Homepage</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/"><span itemprop="name">V-requirements-analyses</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/" aria-disabled="true"><span itemprop="name">Performance</span></a></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#welcome">Welcome!</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
          <article class="chapter deprecated">

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Performance</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
          <article class="default">
<h1>Module Outline</h1>
<p><a href="https://www.youtube.com/watch?v=OXNdQbHvj8U">YouTube Video</a></p>
<p>In this module, we will reintroduce the data structures that we have seen and implemented throughout CC315 as well as CC310. We will discuss the running time for various operations as well as space requirements for each structure.</p>
<p>You may recall that in CC310, we did a similar comparison. We will use most of the same operations from that module so we can draw comparisons between the structures in CC310 and CC315.</p>
<ul>
<li><strong>Insert</strong> – inserting a specific element into the structure, either in sorted order, or at the appropriate place as required by the definition of the data structure.</li>
<li><strong>Access</strong> – accessing a desired element. For general data structures, this is the process of accessing an element by its index or key in the structure. For stacks and queues, this was the process of accessing the next element to be returned.</li>
<li><strong>Find</strong> – this is the process of finding a specific element in the data structure, usually by iterating through it or using a search method if the structure is ordered in some way.</li>
<li><strong>Delete</strong> – this is the process of deleting a specific element in the case of a general-purpose structure or deleting and returning the next element in the case of a stack or queue. For more advanced structures, this may also require the structure to be reorganized a bit.</li>
</ul>
<p>We will also also discuss the memory required for each structure.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>Trees</h1>
<p><a href="https://www.youtube.com/watch?v=ygzji6IOd18">YouTube Video</a></p>
<p>There are three types of trees to consider: generic trees, tries, and binary trees.</p>
<h3 id="general-trees">General Trees</h3>
<p><img src="../../images/2/2Tree_Implementation.svg" alt="Tree"></p>
<ul>
<li>
<p><strong>Insert</strong>: In general, inserting an element into a tree by making it a child of an existing tree is a constant time operation. However, this depends on us already having access to the parent tree we&rsquo;d like to add the item to, which may require searching for that element in the tree as discussed below, which runs in linear time based on the size of the tree. As we saw in our projects, one way we can simplify this is using a hash table to help us keep track of the tree nodes while we build the tree, so that we can more quickly access a desired tree (in near constant time) and add a new child to that tree.</p>
</li>
<li>
<p><strong>Access</strong>: Again, this is a bit complex, as it requires us to make some assumptions about what information is available to us. Typically, we can only access the root element of a tree, which can be done in constant time. If we&rsquo;d like to access any of the other nodes in the tree, we&rsquo;ll have to traverse the tree to find them, either by searching for them if we don&rsquo;t know the path to the item (which is linear time based on the size of the tree), or directly walking the tree in the case that we do know the path (which is comparable to the length of the path, or linear based on the height of the tree).</p>
</li>
<li>
<p><strong>Find</strong>: Finding a particular node in a generic tree is a linear time operation based on the number of nodes in the tree. We simply must do a full traversal of the tree until we find the element we are searching for, typically either by performing a preorder or postorder traversal. This is very similar to simply looking at each element in a linear data structure.</p>
</li>
<li>
<p><strong>Delete</strong>: Removing a child from an existing tree is an interesting operation. If we&rsquo;ve already located the tree node that is the parent of the element we&rsquo;d like to remove, and we know which child we&rsquo;d like to remove, then the operation would be a linear time operation related to the number of children of that node. This is because we may have to iterate through the children of that tree node in order to find the one we&rsquo;d like to remove. Recall that trees generally store the children of each node in a linked list or an array, so the time it takes to remove a child is similar to the time it takes to remove an element from those structures. Again, if we have to search for either the parent or the tree node we&rsquo;d like to remove from that parent, we&rsquo;ll have to take that into account.</p>
</li>
<li>
<p><strong>Memory</strong>: In terms of memory usage, a generic tree uses memory that is on the order of the number of nodes in the tree. So, as the number of nodes in the tree is doubled, the amount of memory it uses doubles as well.</p>
</li>
</ul>
<h3 id="tries">Tries</h3>
<p><img src="../../images/assessments/4Trie_Tree1.svg" alt="Trie 1"></p>
<p>Tries improve on the structure of trees in one important way - instead of using a generic list to store each child, they typically use a statically sized array, where each index in the array directly corresponds to one of the possible children that the node could have. In the case of a trie that represents words, each tree node may have an array of 26 possible children, one for each letter of the alphabet. In our implementation, we chose to use lists instead to simplify things a bit, but for this analysis we&rsquo;ll assume that the children of a trie node can be accessed in constant time through the use of these static arrays.</p>
<p>In the analysis below, we&rsquo;ll assume that we are dealing with words in a trie, not individual nodes. We&rsquo;re also going to be always starting with the root node of the overall trie data structure.</p>
<ul>
<li>
<p><strong>Insert</strong>: To insert a new word in a trie, the process will run in linear time based on the length of the word. So, to insert a 10 character word in a trie, it should take on the order of 10 steps. This is because we can find each individual node for each character in constant time since we are using arrays as described above, and we&rsquo;ll need to do that once for each character, so the overall time is linear based on the number of characters. If the path doesn&rsquo;t exist, we&rsquo;ll have to create new tree nodes to fill it in, but if the path does exist, it could be as simple as setting the boolean value at the correct node to indicate that it is indeed a word.</p>
</li>
<li>
<p><strong>Access</strong>: Similarly to determine if a particular word is in the trie, it will also run in linear time based on the length of the word. We simply must traverse through the path in the tree, and at each node it is a constant time operation to find the correct child and continue onward. So, in total this is a linear time operation.</p>
</li>
<li>
<p><strong>Find</strong>: Find is pretty much the same as access, since we can&rsquo;t just directly jump to a particular node in the tree. So, this is also in linear time based on the length of the word.</p>
</li>
<li>
<p><strong>Delete</strong>: Once again, deleting a word simply involves finding it, which runs in linear time. Once it is deleted, we may go through and prune branches that are unused, which is also a linear time operation as we work back upwards in the trie. So, overall the whole operation runs in linear time based on the length of the word.</p>
</li>
</ul>
<p>In summary, pretty much every operation performed on a trie is related to the length of the word that is provided as input. Pretty nifty!</p>
<ul>
<li><strong>Memory</strong>: Analyzing the memory usage of a trie is a bit more interesting. Traditionally, we say that the memory consumed by a trie is on the order of $n * m$, where $n$ is the number of words stored in the trie, and $m$ is the length of the longest word in the trie. We come to this value because there could be $n$ words that do not share any prefixes, and if they are all the same length $n$ then we&rsquo;ll need that many nodes to represent the whole trie. However, in practice the actual memory usage may be somewhat less because of the shared prefixes and shorter words being part of longer words, but remember that we are concerned with the <strong>worst case</strong> memory usage for a trie, which is $n * m$.</li>
</ul>
<h3 id="binary-trees">Binary Trees</h3>
<p><img src="../../images/assessments/4Binary_Tree1.png" alt="Tree 1"></p>
<p>A binary tree is a tree that is limited to having only two children of each node, and the children and parents are sorted such that every element to the left of the node is less than or equal to its value, and all elements to the right of the node are greater than or equal to its value. Because of this, they perform a little differently than traditional trees.</p>
<p>One major concept related to binary trees is whether the tree is &ldquo;balanced&rdquo; or not. A balanced tree has children that differ in <em>height</em> by no more than 1. If the tree is <em>perfectly</em> balanced, meaning all subtrees are balanced, then there are some interesting relationships that develop.</p>
<p>Most notably, the overall height $h$ of the tree is no larger than $log_2(n)$, where $n$ is the number of elements in the tree.</p>
<p>We didn&rsquo;t cover the algorithms to balance a binary tree in this course since they can be a bit complex, but for this analysis we&rsquo;ll discuss the performance of binary trees when they are perfectly balanced as well as when they are unbalanced.</p>
<ul>
<li>
<p><strong>Insert</strong>: To insert a new element in a binary tree, we may have to descend all the way to the bottom of the tree, so the operation is linear based on the height of the tree. If the tree is a perfectly balanced binary tree, then it is on the order of $log_2(n)$. Otherwise, it is linear based on the height, which in the worst case of a completely unbalanced tree could be the number of nodes itself. Once you&rsquo;ve added the new item, a perfectly balance tree may need to rebalance itself, but that operation is not any more costly than the insert operation.</p>
</li>
<li>
<p><strong>Access</strong>: Similarly, to access a particular element in a binary tree, we&rsquo;ll have to descend through the tree until we find the element we are looking for. At each level, we know exactly which child to check, so it is once again related to the height of the tree. If the tree is a perfectly balanced binary tree, then it is on the order of $log_2(n)$. Otherwise, it is linear based on the height, which in the worst case of a completely unbalanced tree could be the number of nodes itself.</p>
</li>
<li>
<p><strong>Find</strong>: Once again, find in this instance is similar to access.</p>
</li>
<li>
<p><strong>Delete</strong>: Finally, deleting an element from a binary tree involves finding the element, which will be linear based on the height of the tree. Once the element is removed, then a perfectly balanced tree will need to rebalance itself, which could also take the same amount of time. So, in both cases, it runs on the order of $h$ time, which in the worst case is the total number of nodes $n$ on an unbalanced tree, or $log_2(n)$ on a perfectly balanced tree.</p>
</li>
</ul>
<p>So, most operations involving a perfectly balanced binary tree run in $log_2(n)$ time, which is very efficient when compared to a generic tree. However, if the tree is not balanced, then we cannot make any assumptions about the height of the tree and each operation could require $n$ time, where $n$ is the number of nodes in the tree.</p>
<ul>
<li><strong>Memory</strong>: The memory usage of a binary tree is directly correlated with the number of nodes, so we typically say that it is on the order of $n$ memory usage.</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>Graphs</h1>
<p><a href="https://www.youtube.com/watch?v=gd2_k51IFsw">YouTube Video</a></p>
<p>There are two types of graphs that we&rsquo;ve covered in this class: list graphs and matrix graphs. Graphs are slightly different than other data structures, because we may want to find or access both nodes and edges in the graph. So, we&rsquo;ll need to analyze the performance of graphs with respect to both nodes and edges.</p>
<h3 id="matrix-graph">Matrix Graph</h3>
<p><img src="../../images/6/graphB.svg" alt="Matrix Representation Example 2">
<img src="../../images/6/matrixB.svg" alt="Matrix Representation Example 3"></p>
<p>Recall that a matrix graph uses an array to store the nodes, and a two-dimensional array to store the edges.</p>
<ul>
<li>
<p><strong>Insert Node</strong>: Inserting a node is a linear time operation. To insert node, we looped through the nodes attribute and put the node in the first open index. Thus, it is linear with respect to the number of nodes.</p>
</li>
<li>
<p><strong>Access Node</strong>: Likewise, given the index of a node, we can get it&rsquo;s value in constant time by accessing the array.</p>
</li>
<li>
<p><strong>Find Node</strong>: To find the index of a node when we are given its value, we must iterate through the array of nodes, which will be a linear time operation based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Node</strong>: Finally, to remove a node from a graph we can simply set its value in the array of nodes to <code>null</code>. However, we may also need to go through the list of edges and make sure there are no edges to or from that node, so typically this operation runs on the order of the number of nodes in the graph since we must check each one.</p>
</li>
</ul>
<p>For the operations relating to edges below, we&rsquo;ll assume that we already know the indices of the two nodes we are connecting. If we don&rsquo;t know those, we&rsquo;ll have to use the find node process above first.</p>
<ul>
<li>
<p><strong>Insert Edge</strong>: To insert an edge into the graph we simply update the element in the two-dimensional array, which can be done in constant time.</p>
</li>
<li>
<p><strong>Access Edge</strong>: Likewise, to access an edge between two nodes, we simply access the element in the two-dimensional array, which is a constant time operation.</p>
</li>
<li>
<p><strong>Find Neighbors</strong>: Instead of finding a particular edge, we&rsquo;ll say that we want to find all of the neighboring nodes that can be accessed from a given node. In this case, we&rsquo;ll need to iterate through one row of the two-dimensional array, so the whole process runs on the order of linear time based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Edge</strong>: To remove an edge, we simply find it in the two-dimensional array and set its value to infinity, which can be done in constant time.</p>
</li>
</ul>
<p>So, for most matrix graph operations, we can do nearly everything in either constant time or, at worst, linear time based on the number of nodes in the graph.</p>
<ul>
<li><strong>Memory</strong>: Here is where things get interesting. Generally, we say that a matrix graph consumes $n^2$ memory, where $n$ is the number of nodes in the graph. This is because the two-dimensional array of edges is the vast majority of the memory consumption in a matrix graph. So, if the number of nodes is doubled, the memory usage will quadruple.</li>
</ul>
<h3 id="list-graph">List Graph</h3>
<p><img src="../../images/6/graphA.svg" alt="Example 1">
<img src="../../images/7/graphA_list_rep.svg" alt="List Representation for Example 1"></p>
<p>Recall that a list graph uses an array to store the nodes, and then each node stores a list of edges that start from that node.</p>
<ul>
<li>
<p><strong>Insert Node</strong>: Inserting a node is a linear time operation. To insert node, we looped through the nodes attribute and put the node in the first open index. Thus, it is linear with respect to the number of nodes.</p>
</li>
<li>
<p><strong>Access Node</strong>: Likewise, given the index of a node, we can get it&rsquo;s value in constant time by accessing the array.</p>
</li>
<li>
<p><strong>Find Node</strong>: To find the index of a node when we are given its value, we must iterate through the array of nodes, which will be a linear time operation based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Node</strong>: Finally, to remove a node from a graph we can simply set its value in the array of nodes to <code>null</code>. However, we may also need to go through each other node and check to make sure it isn&rsquo;t in the list of edges. So typically this operation runs on the order of the number of nodes in the graph since we must check each one.</p>
</li>
</ul>
<p>So far, a list graph seems to be pretty similar to a matrix graph in terms of performance. The real difference comes with how we handle edges, as well see next.</p>
<p>For the operations relating to edges below, we&rsquo;ll assume that we already know the indices of the two nodes we are connecting. If we don&rsquo;t know those, we&rsquo;ll have to use the find node process above first.</p>
<ul>
<li>
<p><strong>Insert Edge</strong>: To insert an edge into the graph, we must get the source node from the nodes array and then add an element to the list of edges. Assuming that the edges are stored in a linked list, this is a linear time operation in terms of the number of nodes since we may have to iterate through the list of edges to make sure this edge doesn&rsquo;t already exist and need updated. In the worst case, there may be $n$ edges here, so it is a linear operation.</p>
</li>
<li>
<p><strong>Access Edge</strong>: To access an edge between two nodes, we first find the source node in the list of nodes, which is a constant time operation. Then, we&rsquo;ll have to iterate through the list of edges, which is at worst linear time based on the size of the graph, since there could be $n$ outgoing edges from this node. So, overall the operation runs on the order of linear time based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Find Neighbors</strong>: Instead of finding a particular edge, we&rsquo;ll say that we want to find all of the neighboring nodes that can be accessed from a given node. In this case, we can just find the source node in the array of nodes, which is a constant time operation. Then, we can simply return the list of edges, which is also constant time. So, this operation is very efficient!</p>
</li>
<li>
<p><strong>Delete Edge</strong>: To remove an edge, we find the source node and iterate through the list of edges until we find the one to remove. So, this runs in linear time based on the number of nodes in the graph.</p>
</li>
</ul>
<p>So, for most list graph operations, we can also do nearly everything in either constant time or, at worst, linear time based on the number of nodes in the graph. The only real difference comes in how we handle edges, where some operations are a bit slower, but getting a list of all the neighbors of a node is actually a little quicker!</p>
<ul>
<li><strong>Memory</strong>: For a list graph, we typically say the memory usage is on the order of $n + e$, where $n$ is the number of nodes in the graph and $e$ is the number of edges in the graph.</li>
</ul>

  
  
<div class="box notices cstyle tip">
    <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
    <div class="box-content">
<h1 id="dense-vs-sparse-graphs">Dense vs. Sparse Graphs</h1>
<p>Let&rsquo;s analyze the memory usage of matrix and list graphs when dealing with dense and sparse graphs. This is the real key difference between the two data structures.</p>
<h2 id="dense-graph">Dense Graph</h2>
<p>A dense graph is a graph that has a large number of edges compared to the maximum number of edges possible. More specifically, the maximum number of edges a graph can have is $n^2$, so we would say a dense graph has a value for $e$ that is close to $n^2$. Because of this, the memory usage of a matrix graph ($n^2$) is actually a bit more efficient than a list graph ($n + n^2$) because it doesn&rsquo;t have the extra overhead of maintaining a list structure for each node.</p>
<h2 id="sparse-graph">Sparse Graph</h2>
<p>A sparse graph is a graph that has a small number of edges compared to the maximum number of edges possible. So, here we would say that the value of $e$ is much smaller than $n^2$, though it may still be larger than $n$ (otherwise each node would only have one edge coming from it, and this would be a linked list). In that case, we see that $n + e$ is much smaller than $n^2$, and a list graph is much more efficient. If you think about it, in a matrix graph a large number of the entries in the two-dimensional array would be set to infinity and unused, but they still take up memory. Those unused edges wouldn&rsquo;t exist in a list graph, making it much more memory efficient.</p>
    </div>
</div>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>Priority Queues</h1>
<p><a href="https://www.youtube.com/watch?v=doAjYITSxQI">YouTube Video</a></p>
<p><img src="../../images/10/todo_tree_array.svg" alt=""></p>
<p>Let&rsquo;s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the <em>heap properties</em> that it must maintain.</p>
<p>Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:</p>
<ol>
<li>Each node has at most two children.</li>
<li>If there are nodes in level <code>i</code> of the tree, then level <code>i-1</code> is full.</li>
<li>The nodes of the last level are as far left as possible.</li>
</ol>
<ul>
<li>
<p><strong>Insert</strong> To insert a new element in a priority queue, we place it at the end and then push it upwards until it is in the correct place. Because the heap property creates a perfectly balanced tree, at most it will have to perform $log_2(n)$ or $h$ operations. So, we say that insert runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Access Minimum</strong> The most common operation for accessing elements in the priority queue is to access the minimum element. Since it should always be the first element in the array due to the heap properties, this is clearly a constant time operation.</p>
</li>
<li>
<p><strong>Find Element</strong> To find an item in a priority queue, we must simply iterate through the array that stores the heap, which is a linear time operation based on the number of elements in the heap.</p>
</li>
<li>
<p><strong>Remove Minimum</strong> To remove the smallest element, we swap it with the last element and then remove it, then push the top element down into place. Similar to the push up operation, at most it will perform $log_2(n)$ or $h$ operations. So, we say that remove minimum runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Heapify</strong> This is the most interesting operation of a heap. When we use heapify, we add a large number of elements to the heap and then sort it exactly once by working from the bottom to the top and pushing down each element into place. On the surface, it appears that this should run in the order $n * log_2(n)$ time, since each push down operation takes $log_2(n)$ time, and we have to do that on the order of $n$ times to get each element in place. However, using a bit of mathematical analysis, it is possible to prove that this operation actually runs in linear time $n$ based on the number of elements. The work to actually prove this is a bit beyond the scope of this course, but 

<a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" target="_blank" rel="noopener">this StackOverflow discussion</a> is a great explanation of how it works.</p>
</li>
<li>
<p><strong>Memory</strong>: In terms of memory usage, a priority queue uses memory that is on the order of the number of elements in the priority queue.</p>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
    <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
    <div class="box-content">
<h1 id="heapify-and-heap-sort">Heapify and Heap Sort</h1>
<p>Why is it important that heapify runs in linear time? That is because we can use heapify and remove minimum to sort data, which is a sorting algorithm known as heap sort.</p>
<p>We already saw that heapify runs in linear time based on the number of nodes, and each remove minimum operation runs in $log_2(n)$ time. To remove all the elements of the heap, we would do that $n$ times, so the overall time would be $n * log_2(n)$ time. If you recall, that is the same performance as merge sort and quicksort!</p>
    </div>
</div>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>315 Structure Performance Summary</h1>
<p>This page will be devoted to summarizing our performance discussions. Below, we have included a graph for a frame of reference for the various functions.</p>
<p><img src="../../images/12/12_graph.png" alt="Graph"></p>
<h2 id="generic-trees">Generic Trees</h2>
<p>In the following, $n$ denotes the number of nodes in the tree.</p>
<ul>
<li><strong>Insert</strong>: 1 if we have the parent but $n$ if we have to find the parent</li>
<li><strong>Access</strong>: 1 if we want to access the root but $n$ otherwise</li>
<li><strong>Find</strong>: $n$</li>
<li><strong>Delete</strong>: $n$ if we have to find the parent</li>
<li><strong>Memory</strong>: $n$</li>
</ul>
<h2 id="tries">Tries</h2>
<p>In the following, $m$ denotes the length of a word and $n$ denotes the number of words in the trie.</p>
<ul>
<li><strong>Insert</strong>: $m$</li>
<li><strong>Access</strong>: $m$</li>
<li><strong>Find</strong>: $m$</li>
<li><strong>Delete</strong>: $m$</li>
<li><strong>Memory</strong>: $n\times m$</li>
</ul>
<h2 id="binary-trees">Binary Trees</h2>
<p>In the following, $n$ denotes the number of nodes in the tree.</p>
<ul>
<li><strong>Insert</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Access</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Find</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Delete</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Memory</strong>: $n$</li>
</ul>
<h2 id="matrix-graph">Matrix Graph</h2>
<p>In the following, $n$ denotes the number of nodes in the graph.</p>
<ul>
<li><strong>Insert Node</strong>: $n$</li>
<li><strong>Access Node</strong>: 1</li>
<li><strong>Find Node</strong>: $n$</li>
<li><strong>Delete Node</strong>: $n$</li>
<li><strong>Insert Edge</strong>: 1</li>
<li><strong>Access Edge</strong>: 1</li>
<li><strong>Find Neighbors</strong>: $n$</li>
<li><strong>Delete Edge</strong>: 1</li>
<li><strong>Memory</strong>: $n^2$</li>
</ul>
<h2 id="list-graph">List Graph</h2>
<p>In the following, $n$ denotes the number of nodes in the graph and $e$ denotes the number of edges.</p>
<ul>
<li><strong>Insert Node</strong>: $n$</li>
<li><strong>Access Node</strong>: 1</li>
<li><strong>Find Node</strong>: $n$</li>
<li><strong>Delete Node</strong>: $n$</li>
<li><strong>Insert Edge</strong>: $n$</li>
<li><strong>Access Edge</strong>: $n$</li>
<li><strong>Find Neighbors</strong>: 1</li>
<li><strong>Delete Edge</strong>: $n$</li>
<li><strong>Memory</strong>: $n+e$</li>
</ul>
<h2 id="priority-queue">Priority Queue</h2>
<p>In the following, $n$ denotes the number of elements in the priority queue.</p>
<ul>
<li><strong>Insert</strong>: $log_2(n)$</li>
<li><strong>Access Minimum</strong>: 1</li>
<li><strong>Find</strong>: $n$</li>
<li><strong>Remove Minimum</strong>: $log_2(n)$</li>
<li><strong>Heapify</strong>: $n$</li>
<li><strong>Memory</strong>: $n$</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>Tree Algorithms</h1>
<p>We will now discuss the performance of the algorithms that we discussed in this course. When examining the performance of an algorithm we will look at the time and the space that it will require.</p>
<ul>
<li><strong>Time</strong>: To analyze the time of an algorithm, we will look at the number of operations required to complete the algorithm.</li>
<li><strong>Space</strong>: To analyze the space requirement of an algorithm, we will look at the various variables within the algorithm. To calculate this, we can add up the space requirements for each variable within the algorithm</li>
</ul>
<h2 id="preorder-and-postorder">Preorder and Postorder</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>function PREORDER(RESULT)
</span></span><span style="display:flex;"><span>    append ITEM to RESULT
</span></span><span style="display:flex;"><span>    FOR CHILD in CHILDREN
</span></span><span style="display:flex;"><span>           CHILD.PREORDER(RESULT)
</span></span><span style="display:flex;"><span>end function
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>function POSTORDER(RESULT)
</span></span><span style="display:flex;"><span>   FOR CHILD in CHILDREN
</span></span><span style="display:flex;"><span>           CHILD.POSTORDER(RESULT)
</span></span><span style="display:flex;"><span>   append ITEM to RESULT
</span></span><span style="display:flex;"><span>end function
</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time required for preorder or postorder traversals will be linear with respect to the number of nodes. In a single iteration, we will execute the appending once and we will execute the for loop for each child.</li>
<li><strong>Space</strong>: Since <code>RESULT</code> is a variable defined and stored outside of the algorithm, it does not factor into our space requirement. Then we must account for the variables <code>CHILD</code> and <code>CHILDREN</code>. In any given iteration, <code>CHILD</code> will be constant and <code>CHILDREN</code> will have size equal to the number of children for the node we are currently at. In total, this would give us a space requirement that is linear with respect to the number of nodes.</li>
</ul>
<h2 id="inorder">Inorder</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>function INORDER(RESULT)
</span></span><span style="display:flex;"><span>    LEFTCHILD.INORDER(RESULT)
</span></span><span style="display:flex;"><span>    append ITEM to RESULT
</span></span><span style="display:flex;"><span>    RIGHTCHILD.INORDER(RESULT)
</span></span><span style="display:flex;"><span>end function
</span></span></code></pre></div><ul>
<li><strong>Time</strong>: For any given call to the inorder traversal, it will execute in constant time. We must factor in that we have a recursive function and as such, we will call the inorder traversal for each node. Thus our time requirement will be linear with respect to the number of nodes.</li>
<li><strong>Space</strong>: Since <code>RESULT</code> is a variable defined and stored outside of the algorithm, it does not factor into our space requirement. Then we must account for the variable <code>ITEM</code>. This will have constant space and thus, the space requirement for the inorder traversal is constant.</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>Graph Algorithms</h1>
<h2 id="path-searches">Path Searches</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span style="display:flex;"><span>2.     STACK = empty array
</span></span><span style="display:flex;"><span>3.     DISCOVERED = empty set
</span></span><span style="display:flex;"><span>4.     PARENT_MAP = empty dictionary
</span></span><span style="display:flex;"><span>5.     append SRC to STACK
</span></span><span style="display:flex;"><span>6.     while STACK is not empty
</span></span><span style="display:flex;"><span>7.         CURR = top of the stack
</span></span><span style="display:flex;"><span>8.         if CURR not in DISCOVERED
</span></span><span style="display:flex;"><span>9.             if CURR is TAR
</span></span><span style="display:flex;"><span>10.                 PATH = empty array
</span></span><span style="display:flex;"><span>11.                 TRACE = TAR
</span></span><span style="display:flex;"><span>12.                 while TRACE is not SRC
</span></span><span style="display:flex;"><span>13.                     append TRACE to PATH
</span></span><span style="display:flex;"><span>14.                     set TRACE equal to PARENT_MAP[TRACE]
</span></span><span style="display:flex;"><span>15.                 reverse the order of PATH
</span></span><span style="display:flex;"><span>16.                 return PATH
</span></span><span style="display:flex;"><span>17.            add CURR to DISCOVERED
</span></span><span style="display:flex;"><span>18.            NEIGHS = neighbors of CURR
</span></span><span style="display:flex;"><span>19.            for EDGE in NEIGHS
</span></span><span style="display:flex;"><span>20.                NODE = first entry in EDGE
</span></span><span style="display:flex;"><span>21.                append NODE to STACK
</span></span><span style="display:flex;"><span>22.                if PARENT_MAP does not have key NODE
</span></span><span style="display:flex;"><span>23.                    in the PARENT_MAP dictionary set key NODE with value CURR
</span></span><span style="display:flex;"><span>24.    return nothing
</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time analysis for the depth first search can be a bit complex. Lines 1 through 5 would execute in near constant time. When we start the while loop on line 6, it is more difficult to analyze how many times this can execute as <code>STACK</code> can contain duplicates. In the case that we have a sparse graph, this would be bound by the number of nodes. For a dense graph however, the number of executions would be bound by the number of edges. The code within the while loop would be bound by the number of nodes because of the check that we have not already discovered the node in line 8. If we haven&rsquo;t discovered it, we would take either the logic of lines 8 through 16 or lines 17 through 23 but never both in the same iteration. Both of these blocks are bound by the number of nodes in our graph. Thus the worst case time requirement would be $n^2$.</li>
<li><strong>Space</strong>: Depending on the density of our graph, the space required will be linear with respect to the number of nodes or edges. This is due to the fact that <code>STACK</code> can contain duplicate nodes. If we have a sparse graph then it will be bound by the number of nodes. If we have a dense graph then the space is bound by the number of edges.
<ul>
<li><code>STACK</code>: linear with respect to the number of edges</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of neighbors</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>1. function BREADTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span style="display:flex;"><span>2.     QUEUE = empty queue
</span></span><span style="display:flex;"><span>3.     DISCOVERED = empty set
</span></span><span style="display:flex;"><span>4.     PARENT_MAP = empty dictionary
</span></span><span style="display:flex;"><span>5.     add SRC to DISCOVERED
</span></span><span style="display:flex;"><span>6.     add SRC to QUEUE
</span></span><span style="display:flex;"><span>7.     while QUEUE is not empty
</span></span><span style="display:flex;"><span>8.         CURR = first element in QUEUE
</span></span><span style="display:flex;"><span>9.         if CURR is TAR 
</span></span><span style="display:flex;"><span>10.            PATH = empty list 
</span></span><span style="display:flex;"><span>11.            TRACE = TAR
</span></span><span style="display:flex;"><span>12.            while TRACE is not SRC
</span></span><span style="display:flex;"><span>13.                    append TRACE to PATH
</span></span><span style="display:flex;"><span>14.                    set TRACE equal to PARENT_MAP[TRACE]
</span></span><span style="display:flex;"><span>15.                reverse the order of PATH
</span></span><span style="display:flex;"><span>16.                return PATH
</span></span><span style="display:flex;"><span>17.        NEIGHS = neighbors of CURR
</span></span><span style="display:flex;"><span>18.        for EDGE in NEIGHS
</span></span><span style="display:flex;"><span>19.            NODE = first entry in EDGE
</span></span><span style="display:flex;"><span>20.            if NODE is not in DISCOVERED
</span></span><span style="display:flex;"><span>21.                add NODE to DISCOVERED
</span></span><span style="display:flex;"><span>22.                if PARENT_MAP does not have key NODE
</span></span><span style="display:flex;"><span>23.                    in the PARENT_MAP dictionary set key NODE with value CURR
</span></span><span style="display:flex;"><span>24.                append NODE to QUEUE
</span></span><span style="display:flex;"><span>25.    return nothing
</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The run time expected for breadth first search is a bit more straight forward as <code>QUEUE</code> will never have duplicates. Lines 1 through 6 will all execute in constant time. The while loop will occur $n$ times where $n$ is the number of nodes. Based on the logic, either 9-16 will execute or 17-24 will execute. Both of these are bound by the number of nodes in terms of time. Each iteration of the while loop will take $n$ time and we do the while loop $n$ times; thus the running time will be $n^2$.</li>
<li><strong>Space</strong>: The space required for BFS will be linear with respect to the number of nodes. We have 5 variables which have size bound by the number of nodes. If the number of nodes doubles, then we expect the amount of space to roughly double.
<ul>
<li><code>QUEUE</code>: linear with respect to the number of nodes</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of nodes</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="msts">MSTs</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>1. function KRUSKAL(GRAPH)
</span></span><span style="display:flex;"><span>2.     MST = GRAPH without the edges attribute(s)
</span></span><span style="display:flex;"><span>3.     ALLSETS = an empty list which will contain the sets
</span></span><span style="display:flex;"><span>4.     for NODE in GRAPH NODES
</span></span><span style="display:flex;"><span>5.         SET = a set with element NODE
</span></span><span style="display:flex;"><span>6.         add SET to ALLSETS
</span></span><span style="display:flex;"><span>7.     EDGES = list of GRAPH&#39;s edges
</span></span><span style="display:flex;"><span>8.     SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span style="display:flex;"><span>9.     for EDGE in SORTEDEDGES
</span></span><span style="display:flex;"><span>10.        SRC = source node of EDGE
</span></span><span style="display:flex;"><span>11.        TAR = target node of EDGE
</span></span><span style="display:flex;"><span>12.        SRCSET = the set from SETS in which SRC is contained
</span></span><span style="display:flex;"><span>13.        TARSET = the set form SETS in which TAR is contained
</span></span><span style="display:flex;"><span>14.        if SRCSET not equal TARSET
</span></span><span style="display:flex;"><span>15.            UNIONSET = SRCSET union TARSET
</span></span><span style="display:flex;"><span>16.            add UNIONSET to ALLSETS
</span></span><span style="display:flex;"><span>17.            remove SRCSET from ALLSETS
</span></span><span style="display:flex;"><span>18.            remove TARSET from ALLSETS
</span></span><span style="display:flex;"><span>19.            add EDGE to MST as undirected edge
</span></span><span style="display:flex;"><span>20.    return MST
</span></span></code></pre></div><ul>
<li>
<p><strong>Time</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. Lines 4-6 would take linear time with respect to the number of nodes. Then lines 9-19 would take linear time with respect to the number of edges as it would execute $e$ times and each operation can be done in constant time, except for searching through the sets and performing set operations, which require $log_2(n)$ time. Thus, Kruskal&rsquo;s algorithm will take time on the order of $e \times log_2(n)$ in the worst case.</p>
</li>
<li>
<p><strong>Space</strong>:The required space for Kruskal&rsquo;s algorithm is dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.</p>
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>ALLSETS</code>: linear with respect to the number of nodes</li>
<li><code>NODE</code>: 1</li>
<li><code>GRAPH NODES</code>: linear with respect to the number of nodes</li>
<li><code>SET</code>: 1</li>
<li><code>EDGES</code>: linear with respect to the number of edges</li>
<li><code>SORTEDEDGES</code>: linear with respect to the number of edges</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
<li><code>SRCSET</code>: 1</li>
<li><code>TARSET</code>: 1</li>
<li><code>UNIONSET</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>1. function PRIM(GRAPH, START)
</span></span><span style="display:flex;"><span>2.     MST = GRAPH without the edges attribute(s)
</span></span><span style="display:flex;"><span>3.     VISITED = empty set
</span></span><span style="display:flex;"><span>4.     add START to VISITED
</span></span><span style="display:flex;"><span>5.     AVAILEDGES = list of edges where START is the source
</span></span><span style="display:flex;"><span>6.     sort AVAILEDGES
</span></span><span style="display:flex;"><span>7.     while VISITED is not all of the nodes
</span></span><span style="display:flex;"><span>8.         SMLEDGE = smallest edge in AVAILEDGES
</span></span><span style="display:flex;"><span>9.         SRC = source of SMLEDGE
</span></span><span style="display:flex;"><span>10.        TAR = target of SMLEDGE
</span></span><span style="display:flex;"><span>11.        if TAR not in VISITED
</span></span><span style="display:flex;"><span>12.            add SMLEDGE to MST as undirected edge
</span></span><span style="display:flex;"><span>13.            add TAR to VISITED
</span></span><span style="display:flex;"><span>14.            add the edges where TAR is the source to AVAILEDGES
</span></span><span style="display:flex;"><span>15.        remove SMLEDGE from AVAILEDGES
</span></span><span style="display:flex;"><span>16.        sort AVAILEDGES
</span></span><span style="display:flex;"><span>17.    return MST
</span></span></code></pre></div><ul>
<li><strong>Time without Priority Queue</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. With a matrix graph, setting up <code>AVAILEDGES</code> would take linear time with respect to the number of nodes. With a list graph, this would happen in constant time. Then, we need to get the smallest edge from the <code>AVAILEDGES</code> list, which would be a linear time operation based on the number of edges, and we must do that once for up to each edge in the graph. So, the worst case running time for Prim&rsquo;s algorithm is $e^2$. (Our implementation is actually a bit slower than this since we sort the list of available edges each time, but that is technically not necessary - our implementation is closer to $e^2 \times log_2(e)$!)</li>
<li><strong>Time with Priority Queue</strong>: We do get an improvement when we choose to implement this with a priority queue. For the most part, the performance is the same. Using a priority queue, heapify would optimize the sorting to happen in linear time with respect to the number of elements. In that case, we can reduce the total running time to on the order of $e \times log_2(n)$, which is the same as Kruskal&rsquo;s algorithm.</li>
<li><strong>Space</strong>: The required space for Prim&rsquo;s algorithm is also dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>VISITED</code>: linear with respect to the number of nodes</li>
<li><code>AVAILEDGES</code>: linear with respect to the number of edges</li>
<li><code>SMLEDGE</code>: 1</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="shortest-path">Shortest Path</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>1. DIJKSTRAS(GRAPH, SRC)
</span></span><span style="display:flex;"><span>2.    SIZE = size of GRAPH
</span></span><span style="display:flex;"><span>3.    DISTS = array with length equal to SIZE
</span></span><span style="display:flex;"><span>4.    PREVIOUS = array with length equal to SIZE
</span></span><span style="display:flex;"><span>5.    set all of the entries in PREVIOUS to none
</span></span><span style="display:flex;"><span>6.    set all of the entries in DISTS to infinity 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>7.    DISTS[SRC] = 0 
</span></span><span style="display:flex;"><span>8.    PQ = min-priority queue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>9.    loop IDX starting at 0 up to SIZE
</span></span><span style="display:flex;"><span>10.        insert (DISTS[IDX],IDX) into PQ
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>11.    while PQ is not empty
</span></span><span style="display:flex;"><span>12.        MIN = REMOVE-MIN from PQ
</span></span><span style="display:flex;"><span>13.        for NODE in neighbors of MIN
</span></span><span style="display:flex;"><span>14.            WEIGHT = graph weight between MIN and NODE
</span></span><span style="display:flex;"><span>15.            CALC = DISTS[MIN] + WEIGHT
</span></span><span style="display:flex;"><span>16.            if CALC &lt; DISTS[NODE]
</span></span><span style="display:flex;"><span>17.                DISTS[NODE] = CALC
</span></span><span style="display:flex;"><span>18.                PREVIOUS[NODE] = MIN
</span></span><span style="display:flex;"><span>19.                PQIDX = index of NODE in PQ
</span></span><span style="display:flex;"><span>20.                PQ decrease-key (PQIDX, CALC)
</span></span><span style="display:flex;"><span>21.    return DISTS and PREVIOUS
</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time required for Dijkstra&rsquo;s algorithm will be $n^2$ in the worst case. We would expect lines 1 through 8 to take constant time. The for loop on line 9 would be bound by the number of nodes. We would expect the for loop on line 13 to be bound by the number of nodes. This for loop will execute each time <code>PQ</code> is not empty (line 11), which is bound by the number of nodes. Thus, the block of code starting at 11 will take $n^2$ time to run in the worst case. This means that if we double the number of nodes, then the running time will be quadrupled. The worst case for Dijkstra&rsquo;s algorithm is characterized by being a very dense graph, meaning each node has a lot of neighbors. If the graph is sparse and our priority queue is efficient, we could expect this running time to be more along the lines of $(n + e) \times log_2(n)$, where $e$ is the number of edges.</li>
<li><strong>Space</strong>: The required space for Dijkstra&rsquo;s algorithm will be linear with respect to the number of nodes. We have 4 variables which have linear size with respect to the number of nodes. We say that this is linear because if we were to double the number of nodes, we would roughly double the space requirement.
<ul>
<li><code>SIZE</code>: 1</li>
<li><code>DISTS</code>: linear with respect to the number of nodes</li>
<li><code>PREVIOUS</code>: linear with respect to the number of nodes</li>
<li><code>PQ</code>: linear with respect to the number of nodes</li>
<li><code>IDX</code>: 1</li>
<li><code>MIN</code>: 1</li>
<li><code>NODE</code>: 1</li>
<li><code>NEIGHBORS</code>: linear with respect to the number of nodes</li>
<li><code>WEIGHT</code>: 1</li>
<li><code>CALC</code>: 1</li>
<li><code>PQIDX</code>: 1</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<h1>310 Structure Performance Summary</h1>
<h2 id="stacks">Stacks</h2>
<p>A stack is a data structure with two main operations that are simple in concept. One is the <code>push</code> operation that lets you put data into the data structure and the other is the <code>pop</code> operation that lets you get data out of the structure.</p>
<p>A stack is what we call a Last In First Out (LIFO) data structure. That means that when we <code>pop</code> a piece of data off the stack, we get the last piece of data we put on the stack.</p>
<h2 id="queues">Queues</h2>
<p>A queue data structure organizes data in a First In, First Out (FIFO) order: the first piece of data put into the queue is the first piece of data available to remove from the queue.</p>
<h2 id="lists">Lists</h2>
<p>A list is a data structure that holds a sequence of data, such as the shopping list shown below. Each list has a head item and a tail item, with all other items placed linearly between the head and the tail.</p>
<h2 id="sets">Sets</h2>
<p>A set is a collection of elements that are usually related to each other.</p>
<h2 id="hash-tables">Hash Tables</h2>
<p>A hash table is an unordered collection of key-value pairs, where each key is unique.</p>
<p>The following table compares the best- and worst-case processing time for many common data structures and operations, expressed in terms of $N$, the number of elements in the structure. </p>
<table>
<thead>
<tr>
<th style="text-align:center">Data Structure</th>
<th style="text-align:center">Insert Best</th>
<th style="text-align:center">Insert Worst</th>
<th style="text-align:center">Access Best</th>
<th style="text-align:center">Access Worst</th>
<th style="text-align:center">Find Best</th>
<th style="text-align:center">Find Worst</th>
<th style="text-align:center">Delete Best</th>
<th style="text-align:center">Delete Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Unsorted Array</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Array</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Array Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Array Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Unsorted Linked List</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Linked List</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Hash Table</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
</tr>
</tbody>
</table>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        </div>
      </main>
    
<div class="git-footer">
<p>Last modified by: 
            <i class='fas fa-user'></i> Emily Alfs
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cc/315/generic/textbook/-/commit/499f4d824a58536af610d92fd6aa49d60ed20d97">Oct 21, 2021</a>
</p>
</div>

    
    </div>
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">
<a id="logo" href="https://ksu-cs-textbooks.github.io/cc315/">
    <img src="https://ksu-cs-textbooks.github.io/cc315/images/0/core-logo-on-purple.png" alt="Logo" style="width: 100%">
</a>
        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/auto-complete.js?1660069144" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/lunr.min.js?1660069144" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/lunr.stemmer.support.min.js?1660069144" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/lunr.multi.min.js?1660069144" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/lunr.en.min.js?1660069144" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cc315/js/search.js?1660069144" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/00-introduction/" title="Introductory Material" class="dd-item"><input type="checkbox" id="section-e09e6fbbf0ca5ef01f39bc627e73497e" class="toggle"/><label for="section-e09e6fbbf0ca5ef01f39bc627e73497e" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/00-introduction/"><b>0  </b>Introductory Material</a><ul>
          <li data-nav-id="/00-introduction/04-syllabus/" title="CC 315 Syllabus" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/00-introduction/04-syllabus/">1. CC 315 Syllabus</a></li></ul></li>
          <li data-nav-id="/i-strings/" title="Strings and StringBuilders" class="dd-item"><input type="checkbox" id="section-1089729412becebb57855dd7d743dc58" class="toggle"/><label for="section-1089729412becebb57855dd7d743dc58" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/"><b>I  </b>Strings and StringBuilders</a><ul>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/" title="Strings and StringBuilders" class="dd-item"><input type="checkbox" id="section-3eb376ab16f2d8dfad24b5d54557bbe1" class="toggle"/><label for="section-3eb376ab16f2d8dfad24b5d54557bbe1" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/"><b>1  </b>Strings and StringBuilders</a><ul>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/01-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/01-introduction/">1. Introduction</a></li>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/02-theory/" title="Theory" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/02-theory/">2. Theory</a></li>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/03-memory-example/" title="Memory Example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/03-memory-example/">3. Memory Example</a></li>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/04-j-memory-example/" title="Limitations Java" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/04-j-memory-example/">4. Limitations Java</a></li>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/04-p-memory-example/" title="Limitations Python" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/04-p-memory-example/">5. Limitations Python</a></li>
          <li data-nav-id="/i-strings/1-strings-and-stringbuilders/05-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/i-strings/1-strings-and-stringbuilders/05-summary/">6. Summary</a></li></ul></li></ul></li>
          <li data-nav-id="/ii-trees/" title="Trees" class="dd-item"><input type="checkbox" id="section-a212d9ee4f313a0399cdddbb36b1b1a7" class="toggle"/><label for="section-a212d9ee4f313a0399cdddbb36b1b1a7" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/"><b>II  </b>Trees</a><ul>
          <li data-nav-id="/ii-trees/2-introduction-trees/" title="Introduction to Trees" class="dd-item"><input type="checkbox" id="section-06f71d9f01abf11ab6eb6e5d86c2d9d7" class="toggle"/><label for="section-06f71d9f01abf11ab6eb6e5d86c2d9d7" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/"><b>2.  </b>Introduction to Trees</a><ul>
          <li data-nav-id="/ii-trees/2-introduction-trees/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/ii-trees/2-introduction-trees/2-general-terms/" title="General Terms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/2-general-terms/">2. General Terms</a></li>
          <li data-nav-id="/ii-trees/2-introduction-trees/3-what-makes-trees/" title="What Makes a Tree a Tree" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/3-what-makes-trees/">3. What Makes a Tree a Tree</a></li>
          <li data-nav-id="/ii-trees/2-introduction-trees/4-uml/" title="MyTree I" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/4-uml/">4. MyTree I</a></li>
          <li data-nav-id="/ii-trees/2-introduction-trees/5-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/2-introduction-trees/5-summary/">5. Summary</a></li></ul></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/" title="Tree Traversal" class="dd-item"><input type="checkbox" id="section-0522cfed48fd5f3ed4d2599648d0cdf3" class="toggle"/><label for="section-0522cfed48fd5f3ed4d2599648d0cdf3" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/"><b>3.  </b>Tree Traversal</a><ul>
          <li data-nav-id="/ii-trees/3-tree-traversal/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/2-terms-i/" title="Terms I" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/2-terms-i/">2. Terms I</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/3-recursion-refresh/" title="Recursion Refresh" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/3-recursion-refresh/">3. Recursion Refresh</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/4-terms-ii/" title="Terms II" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/4-terms-ii/">4. Terms II</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/5-terms-iii/" title="Terms III" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/5-terms-iii/">5. Terms III</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/6-mytree-recursive-i/" title="MyTree Recursive I" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/6-mytree-recursive-i/">6. MyTree Recursive I</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/7-mytree-recursive-ii/" title="MyTree Recursive II" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/7-mytree-recursive-ii/">7. MyTree Recursive II</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/8-mytree-recursive-iii/" title="MyTree Recursive III" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/8-mytree-recursive-iii/">8. MyTree Recursive III</a></li>
          <li data-nav-id="/ii-trees/3-tree-traversal/9-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/3-tree-traversal/9-summary/">9. Summary</a></li></ul></li>
          <li data-nav-id="/ii-trees/4-tries/" title="Tries" class="dd-item"><input type="checkbox" id="section-0b20966faac9e07caecc4b2206818fd3" class="toggle"/><label for="section-0b20966faac9e07caecc4b2206818fd3" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/4-tries/"><b>4.  </b>Tries</a><ul>
          <li data-nav-id="/ii-trees/4-tries/1-tries/" title="Tries" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/4-tries/1-tries/">1. Tries</a></li>
          <li data-nav-id="/ii-trees/4-tries/2-trie-example/" title="Trie Example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/4-tries/2-trie-example/">2. Trie Example</a></li>
          <li data-nav-id="/ii-trees/4-tries/3-mytrie-i/" title="MyTrie I" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/4-tries/3-mytrie-i/">3. MyTrie I</a></li>
          <li data-nav-id="/ii-trees/4-tries/4-mytrie-ii/" title="MyTrie II" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/4-tries/4-mytrie-ii/">4. MyTrie II</a></li></ul></li>
          <li data-nav-id="/ii-trees/5-binary-trees/" title="Binary Trees" class="dd-item"><input type="checkbox" id="section-c355e16ddf3c8c8a2db497eeabe0aa03" class="toggle"/><label for="section-c355e16ddf3c8c8a2db497eeabe0aa03" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/"><b>5.  </b>Binary Trees</a><ul>
          <li data-nav-id="/ii-trees/5-binary-trees/1-binary-tree/" title="Binary Tree" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/1-binary-tree/">1. Binary Tree</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/2-binary-tree-examples/" title="Binary Tree Examples" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/2-binary-tree-examples/">2. Binary Tree Examples</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/3-traversals/" title="Traversals" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/3-traversals/">3. Traversals</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/4-in-order-traversal/" title="In-Order Traversal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/4-in-order-traversal/">4. In-Order Traversal</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/5-mybinarytree/" title="MyBinaryTree" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/5-mybinarytree/">5. MyBinaryTree</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/6-inserting-children/" title="Inserting Children" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/6-inserting-children/">6. Inserting Children</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/7-removing-children/" title="Removing Children" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/7-removing-children/">7. Removing Children</a></li>
          <li data-nav-id="/ii-trees/5-binary-trees/8-balance/" title="Balance" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/ii-trees/5-binary-trees/8-balance/">8. Balance</a></li></ul></li></ul></li>
          <li data-nav-id="/iii-graphs/" title="Iii-graphs" class="dd-item"><input type="checkbox" id="section-888c91f60de67a996d768a0b1361387b" class="toggle"/><label for="section-888c91f60de67a996d768a0b1361387b" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/">Iii-graphs</a><ul>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/" title="Graphs: Matrix Representation" class="dd-item"><input type="checkbox" id="section-85c95428968232f3b507718bb59b30bf" class="toggle"/><label for="section-85c95428968232f3b507718bb59b30bf" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/"><b>6.  </b>Graphs: Matrix Representation</a><ul>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/2-terms-i/" title="Terms I" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/2-terms-i/">2. Terms I</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/3-graph-features/" title="Graph Features" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/3-graph-features/">3. Graph Features</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/4-weighted-graphs/" title="Weighted Graphs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/4-weighted-graphs/">4. Weighted Graphs</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/5-directed-graphs/" title="Directed Graphs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/5-directed-graphs/">5. Directed Graphs</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/6-example/" title="Example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/6-example/">6. Example</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/7-matrix-representation/" title="Matrix Representation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/7-matrix-representation/">7. Matrix Representation</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/8-uml/" title="UML" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/8-uml/">8. UML</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/9-node-and-edge-functions/" title="Node and Edge Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/9-node-and-edge-functions/">9. Node and Edge Functions</a></li>
          <li data-nav-id="/iii-graphs/6-graphs-matrix-representation/10-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/6-graphs-matrix-representation/10-summary/">10. Summary</a></li></ul></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/" title="Graphs: List Representation" class="dd-item"><input type="checkbox" id="section-fbf4e23aed798d2efc0479884687b993" class="toggle"/><label for="section-fbf4e23aed798d2efc0479884687b993" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/"><b>7.  </b>Graphs: List Representation</a><ul>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/2-list-representation/" title="List Representation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/2-list-representation/">2. List Representation</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/3-dense-vs-sparse/" title="Dense VS Sparse" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/3-dense-vs-sparse/">3. Dense VS Sparse</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/4-uml-graph-node/" title="UML - Graph Node" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/4-uml-graph-node/">4. UML - Graph Node</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/5-uml-graph/" title="UML - Graph" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/5-uml-graph/">5. UML - Graph</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/6-node-and-edge-functions/" title="Node and Edge Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/6-node-and-edge-functions/">6. Node and Edge Functions</a></li>
          <li data-nav-id="/iii-graphs/7-graphs-list-representation/7-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/7-graphs-list-representation/7-summary/">7. Summary</a></li></ul></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/" title="Graphs: Searching and Traversing" class="dd-item"><input type="checkbox" id="section-8501f3e08af3fba8a5545c2db0c970dc" class="toggle"/><label for="section-8501f3e08af3fba8a5545c2db0c970dc" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/"><b>8.  </b>Graphs: Searching and Traversing</a><ul>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/2-depth-first/" title="Depth First" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/2-depth-first/">2. Depth First</a></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/3-breadth-first/" title="Breadth First" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/3-breadth-first/">3. Breadth First</a></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/4-limitations/" title="Limitations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/4-limitations/">4. Limitations</a></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/5-finding-a-path/" title="Finding a Path" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/5-finding-a-path/">5. Finding a Path</a></li>
          <li data-nav-id="/iii-graphs/8-graphs-searching-and-traversing/6-in-practice/" title="In Practice" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/8-graphs-searching-and-traversing/6-in-practice/">6. In Practice</a></li></ul></li>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/" title="Graphs: Minimum Spanning Trees" class="dd-item"><input type="checkbox" id="section-83a4a5d75e5d31f3cd62c66f20389355" class="toggle"/><label for="section-83a4a5d75e5d31f3cd62c66f20389355" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/"><b>9.  </b>Graphs: Minimum Spanning Trees</a><ul>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/2-minimum-spanning-trees/" title="Minimum Spanning Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/2-minimum-spanning-trees/">2. Minimum Spanning Trees</a></li>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/3-kruskal/" title="Kruskal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/3-kruskal/">3. Kruskal</a></li>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/4-prim/" title="Prim" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/4-prim/">4. Prim</a></li>
          <li data-nav-id="/iii-graphs/9-graphs-minimum-spanning-trees/5-traveling-salesperson/" title="Traveling Salesperson" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iii-graphs/9-graphs-minimum-spanning-trees/5-traveling-salesperson/">5. Traveling Salesperson</a></li></ul></li></ul></li>
          <li data-nav-id="/iv-priority-queues/" title="Iv-priority-queues" class="dd-item"><input type="checkbox" id="section-632ae6f8e00d68a204fd1702e3de6fa2" class="toggle"/><label for="section-632ae6f8e00d68a204fd1702e3de6fa2" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/">Iv-priority-queues</a><ul>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/" title="Heaps and Priority Queues" class="dd-item"><input type="checkbox" id="section-771b1743d239a3dd3749b1cd6c9e2d0e" class="toggle"/><label for="section-771b1743d239a3dd3749b1cd6c9e2d0e" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/"><b>10.  </b>Heaps and Priority Queues</a><ul>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/1-introduction/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/1-introduction/">1. Introduction</a></li>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/2-node-relationships/" title="Node Relationships" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/2-node-relationships/">2. Node Relationships</a></li>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/3-priority-queues/" title="Priority Queues" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/3-priority-queues/">3. Priority Queues</a></li>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/4-functionality/" title="Functionality" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/4-functionality/">4. Functionality</a></li>
          <li data-nav-id="/iv-priority-queues/10-heaps-and-priority-queues/5-dijkstras/" title="Dijkstras" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/iv-priority-queues/10-heaps-and-priority-queues/5-dijkstras/">5. Dijkstras</a></li></ul></li></ul></li>
          <li data-nav-id="/v-requirements-analysis/" title="V-requirements-analyses" class="dd-item parent"><input type="checkbox" id="section-683aa2a4c2e800902b4eb06800fc5442" class="toggle" checked/><label for="section-683aa2a4c2e800902b4eb06800fc5442" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/">V-requirements-analyses</a><ul>
          <li data-nav-id="/v-requirements-analysis/11-performance/" title="Performance" class="dd-item active parent"><input type="checkbox" id="section-27ea7ee9fceac9d5f375989c7653a29d" class="toggle" checked/><label for="section-27ea7ee9fceac9d5f375989c7653a29d" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/"><b>11.  </b>Performance</a><ul>
          <li data-nav-id="/v-requirements-analysis/11-performance/1-module-outline/" title="Module Outline" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/1-module-outline/">1. Module Outline</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/2-trees/" title="Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/2-trees/">2. Trees</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/3-graphs/" title="Graphs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/3-graphs/">3. Graphs</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/4-priority-queues/" title="Priority Queues" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/4-priority-queues/">4. Priority Queues</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/5-315-structure-performance-summary/" title="315 Structure Performance Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/5-315-structure-performance-summary/">5. 315 Structure Performance Summary</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/6-tree-algorithms/" title="Tree Algorithms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/6-tree-algorithms/">6. Tree Algorithms</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/7-graph-algorithms/" title="Graph Algorithms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/">7. Graph Algorithms</a></li>
          <li data-nav-id="/v-requirements-analysis/11-performance/8-310-structure-performance-summary/" title="310 Structure Performance Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/11-performance/8-310-structure-performance-summary/">8. 310 Structure Performance Summary</a></li></ul></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/" title="Requirements Analysis" class="dd-item"><input type="checkbox" id="section-2c7a269034fa2ec541d453663d344394" class="toggle"/><label for="section-2c7a269034fa2ec541d453663d344394" ></label><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/"><b>12.  </b>Requirements Analysis</a><ul>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/1-module-outline/" title="Module Outline" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/1-module-outline/">1. Module Outline</a></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/2-types-of-data/" title="Types of Data" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/2-types-of-data/">2. Types of Data</a></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/3-trees/" title="Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/3-trees/">3. Trees</a></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/4-graphs/" title="Graphs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/4-graphs/">4. Graphs</a></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/5-priority-queues/" title="Priority Queues" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/5-priority-queues/">5. Priority Queues</a></li>
          <li data-nav-id="/v-requirements-analysis/12-requirements-analysis/6-examples/" title="Examples" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/v-requirements-analysis/12-requirements-analysis/6-examples/">6. Examples</a></li></ul></li></ul></li>
          <li data-nav-id="/z-instructor-resources/" title="Z-instructor-resources" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cc315/z-instructor-resources/">Z-instructor-resources</a></li>
        </ul>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                    <option id="light-theme" value="light-theme" selected>Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>window.variants && variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
    #footer {
        font-size: 13px;
        margin-left: auto;
        margin-right: auto;
        padding: 2rem 1rem;
        min-width: 230px;
        max-width: 300px;
    }
    #footer p {
        margin: 0;
    }
    </style>
        
    <p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/ksu-cs-textbooks/hugo-theme-relearn">Hugo Relearn Theme</a>.</p>
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; margin: .5rem auto" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a> See <a href="https://core.cs.ksu.edu/license">License & Attribution</a> for details.</p>
        </div>
      </div>
    </aside>
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/clipboard.min.js?1660069144" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/perfect-scrollbar.min.js?1660069144" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/featherlight.min.js?1660069144" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc315/js/theme.js?1660069144" defer></script>
  </body>
</html>
