




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Path Searches 1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2. STACK = empty array 3. DISCOVERED = empty set 4. PARENT_MAP = empty dictionary 5. append SRC to STACK 6. while STACK is not empty 7. CURR = top of the stack 8. if CURR not in DISCOVERED 9. if CURR is TAR 10. PATH = empty array 11. TRACE = TAR 12. while TRACE is not SRC 13. append TRACE to PATH 14. set TRACE equal to PARENT_MAP[TRACE] 15.">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Graph Algorithms :: CC 315 Textbook">
    <meta name="twitter:description" content="Path Searches 1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2. STACK = empty array 3. DISCOVERED = empty set 4. PARENT_MAP = empty dictionary 5. append SRC to STACK 6. while STACK is not empty 7. CURR = top of the stack 8. if CURR not in DISCOVERED 9. if CURR is TAR 10. PATH = empty array 11. TRACE = TAR 12. while TRACE is not SRC 13. append TRACE to PATH 14. set TRACE equal to PARENT_MAP[TRACE] 15.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Graph Algorithms :: CC 315 Textbook">
    <meta property="og:description" content="Path Searches 1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2. STACK = empty array 3. DISCOVERED = empty set 4. PARENT_MAP = empty dictionary 5. append SRC to STACK 6. while STACK is not empty 7. CURR = top of the stack 8. if CURR not in DISCOVERED 9. if CURR is TAR 10. PATH = empty array 11. TRACE = TAR 12. while TRACE is not SRC 13. append TRACE to PATH 14. set TRACE equal to PARENT_MAP[TRACE] 15.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="V-Requirements-Analyses">
    <meta property="article:modified_time" content="2021-10-21T16:59:20-05:00">
    <meta itemprop="name" content="Graph Algorithms :: CC 315 Textbook">
    <meta itemprop="description" content="Path Searches 1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2. STACK = empty array 3. DISCOVERED = empty set 4. PARENT_MAP = empty dictionary 5. append SRC to STACK 6. while STACK is not empty 7. CURR = top of the stack 8. if CURR not in DISCOVERED 9. if CURR is TAR 10. PATH = empty array 11. TRACE = TAR 12. while TRACE is not SRC 13. append TRACE to PATH 14. set TRACE equal to PARENT_MAP[TRACE] 15.">
    <meta itemprop="dateModified" content="2021-10-21T16:59:20-05:00">
    <meta itemprop="wordCount" content="1900">
    <title>Graph Algorithms :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/" rel="canonical" type="text/html" title="Graph Algorithms :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/index.xml" rel="alternate" type="application/rss+xml" title="Graph Algorithms :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/tele.html" rel="alternate" type="text/html" title="Graph Algorithms :: CC 315 Textbook">
    <link href="/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/embed.html" rel="alternate" type="text/html" title="Graph Algorithms :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1737135054" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1737135054" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1737135054" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1737135054" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1737135054" rel="stylesheet">
    <link href="/cc315/css/print.css?1737135054" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1737135054" rel="stylesheet">
    <script src="/cc315/js/variant.js?1737135054"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1737135054" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/v-requirements-analysis/11-performance/7-graph-algorithms/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/v-requirements-analysis/"><span itemprop="name">V-Requirements-Analyses</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc315/v-requirements-analysis/11-performance/"><span itemprop="name">Performance</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Graph Algorithms</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/v-requirements-analysis/11-performance/6-tree-algorithms/" title="Tree Algorithms (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/v-requirements-analysis/11-performance/8-310-structure-performance-summary/" title="310 Structure Performance Summary (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graph-algorithms">Graph Algorithms</h1>

<h2 id="path-searches">Path Searches</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     STACK = empty array
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     append SRC to STACK
</span></span><span class="line"><span class="cl">6.     while STACK is not empty
</span></span><span class="line"><span class="cl">7.         CURR = top of the stack
</span></span><span class="line"><span class="cl">8.         if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">9.             if CURR is TAR
</span></span><span class="line"><span class="cl">10.                 PATH = empty array
</span></span><span class="line"><span class="cl">11.                 TRACE = TAR
</span></span><span class="line"><span class="cl">12.                 while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                     append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                     set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                 reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                 return PATH
</span></span><span class="line"><span class="cl">17.            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">18.            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">19.            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">20.                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">21.                append NODE to STACK
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.    return nothing</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time analysis for the depth first search can be a bit complex. Lines 1 through 5 would execute in near constant time. When we start the while loop on line 6, it is more difficult to analyze how many times this can execute as <code>STACK</code> can contain duplicates. In the case that we have a sparse graph, this would be bound by the number of nodes. For a dense graph however, the number of executions would be bound by the number of edges. The code within the while loop would be bound by the number of nodes because of the check that we have not already discovered the node in line 8. If we haven&rsquo;t discovered it, we would take either the logic of lines 8 through 16 or lines 17 through 23 but never both in the same iteration. Both of these blocks are bound by the number of nodes in our graph. Thus the worst case time requirement would be $n^2$.</li>
<li><strong>Space</strong>: Depending on the density of our graph, the space required will be linear with respect to the number of nodes or edges. This is due to the fact that <code>STACK</code> can contain duplicate nodes. If we have a sparse graph then it will be bound by the number of nodes. If we have a dense graph then the space is bound by the number of edges.
<ul>
<li><code>STACK</code>: linear with respect to the number of edges</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of neighbors</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function BREADTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     QUEUE = empty queue
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">6.     add SRC to QUEUE
</span></span><span class="line"><span class="cl">7.     while QUEUE is not empty
</span></span><span class="line"><span class="cl">8.         CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">9.         if CURR is TAR 
</span></span><span class="line"><span class="cl">10.            PATH = empty list 
</span></span><span class="line"><span class="cl">11.            TRACE = TAR
</span></span><span class="line"><span class="cl">12.            while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                    append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                    set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                return PATH
</span></span><span class="line"><span class="cl">17.        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">18.        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">19.            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">20.            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">21.                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.                append NODE to QUEUE
</span></span><span class="line"><span class="cl">25.    return nothing</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The run time expected for breadth first search is a bit more straight forward as <code>QUEUE</code> will never have duplicates. Lines 1 through 6 will all execute in constant time. The while loop will occur $n$ times where $n$ is the number of nodes. Based on the logic, either 9-16 will execute or 17-24 will execute. Both of these are bound by the number of nodes in terms of time. Each iteration of the while loop will take $n$ time and we do the while loop $n$ times; thus the running time will be $n^2$.</li>
<li><strong>Space</strong>: The space required for BFS will be linear with respect to the number of nodes. We have 5 variables which have size bound by the number of nodes. If the number of nodes doubles, then we expect the amount of space to roughly double.
<ul>
<li><code>QUEUE</code>: linear with respect to the number of nodes</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of nodes</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="msts">MSTs</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function KRUSKAL(GRAPH)
</span></span><span class="line"><span class="cl">2.     MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">3.     ALLSETS = an empty list which will contain the sets
</span></span><span class="line"><span class="cl">4.     for NODE in GRAPH NODES
</span></span><span class="line"><span class="cl">5.         SET = a set with element NODE
</span></span><span class="line"><span class="cl">6.         add SET to ALLSETS
</span></span><span class="line"><span class="cl">7.     EDGES = list of GRAPH&#39;s edges
</span></span><span class="line"><span class="cl">8.     SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span class="line"><span class="cl">9.     for EDGE in SORTEDEDGES
</span></span><span class="line"><span class="cl">10.        SRC = source node of EDGE
</span></span><span class="line"><span class="cl">11.        TAR = target node of EDGE
</span></span><span class="line"><span class="cl">12.        SRCSET = the set from SETS in which SRC is contained
</span></span><span class="line"><span class="cl">13.        TARSET = the set form SETS in which TAR is contained
</span></span><span class="line"><span class="cl">14.        if SRCSET not equal TARSET
</span></span><span class="line"><span class="cl">15.            UNIONSET = SRCSET union TARSET
</span></span><span class="line"><span class="cl">16.            add UNIONSET to ALLSETS
</span></span><span class="line"><span class="cl">17.            remove SRCSET from ALLSETS
</span></span><span class="line"><span class="cl">18.            remove TARSET from ALLSETS
</span></span><span class="line"><span class="cl">19.            add EDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">20.    return MST</span></span></code></pre></div><ul>
<li>
<p><strong>Time</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. Lines 4-6 would take linear time with respect to the number of nodes. Then lines 9-19 would take linear time with respect to the number of edges as it would execute $e$ times and each operation can be done in constant time, except for searching through the sets and performing set operations, which require $log_2(n)$ time. Thus, Kruskal&rsquo;s algorithm will take time on the order of $e \times log_2(n)$ in the worst case.</p>
</li>
<li>
<p><strong>Space</strong>:The required space for Kruskal&rsquo;s algorithm is dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.</p>
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>ALLSETS</code>: linear with respect to the number of nodes</li>
<li><code>NODE</code>: 1</li>
<li><code>GRAPH NODES</code>: linear with respect to the number of nodes</li>
<li><code>SET</code>: 1</li>
<li><code>EDGES</code>: linear with respect to the number of edges</li>
<li><code>SORTEDEDGES</code>: linear with respect to the number of edges</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
<li><code>SRCSET</code>: 1</li>
<li><code>TARSET</code>: 1</li>
<li><code>UNIONSET</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function PRIM(GRAPH, START)
</span></span><span class="line"><span class="cl">2.     MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">3.     VISITED = empty set
</span></span><span class="line"><span class="cl">4.     add START to VISITED
</span></span><span class="line"><span class="cl">5.     AVAILEDGES = list of edges where START is the source
</span></span><span class="line"><span class="cl">6.     sort AVAILEDGES
</span></span><span class="line"><span class="cl">7.     while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">8.         SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">9.         SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">10.        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">11.        if TAR not in VISITED
</span></span><span class="line"><span class="cl">12.            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">13.            add TAR to VISITED
</span></span><span class="line"><span class="cl">14.            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">15.        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">16.        sort AVAILEDGES
</span></span><span class="line"><span class="cl">17.    return MST</span></span></code></pre></div><ul>
<li><strong>Time without Priority Queue</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. With a matrix graph, setting up <code>AVAILEDGES</code> would take linear time with respect to the number of nodes. With a list graph, this would happen in constant time. Then, we need to get the smallest edge from the <code>AVAILEDGES</code> list, which would be a linear time operation based on the number of edges, and we must do that once for up to each edge in the graph. So, the worst case running time for Prim&rsquo;s algorithm is $e^2$. (Our implementation is actually a bit slower than this since we sort the list of available edges each time, but that is technically not necessary - our implementation is closer to $e^2 \times log_2(e)$!)</li>
<li><strong>Time with Priority Queue</strong>: We do get an improvement when we choose to implement this with a priority queue. For the most part, the performance is the same. Using a priority queue, heapify would optimize the sorting to happen in linear time with respect to the number of elements. In that case, we can reduce the total running time to on the order of $e \times log_2(n)$, which is the same as Kruskal&rsquo;s algorithm.</li>
<li><strong>Space</strong>: The required space for Prim&rsquo;s algorithm is also dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>VISITED</code>: linear with respect to the number of nodes</li>
<li><code>AVAILEDGES</code>: linear with respect to the number of edges</li>
<li><code>SMLEDGE</code>: 1</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="shortest-path">Shortest Path</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. DIJKSTRAS(GRAPH, SRC)
</span></span><span class="line"><span class="cl">2.    SIZE = size of GRAPH
</span></span><span class="line"><span class="cl">3.    DISTS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">4.    PREVIOUS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">5.    set all of the entries in PREVIOUS to none
</span></span><span class="line"><span class="cl">6.    set all of the entries in DISTS to infinity 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">7.    DISTS[SRC] = 0 
</span></span><span class="line"><span class="cl">8.    PQ = min-priority queue
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">9.    loop IDX starting at 0 up to SIZE
</span></span><span class="line"><span class="cl">10.        insert (DISTS[IDX],IDX) into PQ
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">11.    while PQ is not empty
</span></span><span class="line"><span class="cl">12.        MIN = REMOVE-MIN from PQ
</span></span><span class="line"><span class="cl">13.        for NODE in neighbors of MIN
</span></span><span class="line"><span class="cl">14.            WEIGHT = graph weight between MIN and NODE
</span></span><span class="line"><span class="cl">15.            CALC = DISTS[MIN] + WEIGHT
</span></span><span class="line"><span class="cl">16.            if CALC &lt; DISTS[NODE]
</span></span><span class="line"><span class="cl">17.                DISTS[NODE] = CALC
</span></span><span class="line"><span class="cl">18.                PREVIOUS[NODE] = MIN
</span></span><span class="line"><span class="cl">19.                PQIDX = index of NODE in PQ
</span></span><span class="line"><span class="cl">20.                PQ decrease-key (PQIDX, CALC)
</span></span><span class="line"><span class="cl">21.    return DISTS and PREVIOUS</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time required for Dijkstra&rsquo;s algorithm will be $n^2$ in the worst case. We would expect lines 1 through 8 to take constant time. The for loop on line 9 would be bound by the number of nodes. We would expect the for loop on line 13 to be bound by the number of nodes. This for loop will execute each time <code>PQ</code> is not empty (line 11), which is bound by the number of nodes. Thus, the block of code starting at 11 will take $n^2$ time to run in the worst case. This means that if we double the number of nodes, then the running time will be quadrupled. The worst case for Dijkstra&rsquo;s algorithm is characterized by being a very dense graph, meaning each node has a lot of neighbors. If the graph is sparse and our priority queue is efficient, we could expect this running time to be more along the lines of $(n + e) \times log_2(n)$, where $e$ is the number of edges.</li>
<li><strong>Space</strong>: The required space for Dijkstra&rsquo;s algorithm will be linear with respect to the number of nodes. We have 4 variables which have linear size with respect to the number of nodes. We say that this is linear because if we were to double the number of nodes, we would roughly double the space requirement.
<ul>
<li><code>SIZE</code>: 1</li>
<li><code>DISTS</code>: linear with respect to the number of nodes</li>
<li><code>PREVIOUS</code>: linear with respect to the number of nodes</li>
<li><code>PQ</code>: linear with respect to the number of nodes</li>
<li><code>IDX</code>: 1</li>
<li><code>MIN</code>: 1</li>
<li><code>NODE</code>: 1</li>
<li><code>NEIGHBORS</code>: linear with respect to the number of nodes</li>
<li><code>WEIGHT</code>: 1</li>
<li><code>CALC</code>: 1</li>
<li><code>PQIDX</code>: 1</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Emily Alfs
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/499f4d824a58536af610d92fd6aa49d60ed20d97">Oct 21, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1737135054" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1737135054" defer></script>
    <script src="/cc315/js/theme.js?1737135054" defer></script>
  </body>
</html>
