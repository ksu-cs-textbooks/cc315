




  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="CC 315 Textbook This is the textbook for CC 315.">
    <meta name="author" content="K-State CS Faculty">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Homepage :: CC 315 Textbook">
    <meta name="twitter:description" content="CC 315 Textbook This is the textbook for CC 315.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc315/">
    <meta property="og:site_name" content="CC 315 Textbook">
    <meta property="og:title" content="Homepage :: CC 315 Textbook">
    <meta property="og:description" content="CC 315 Textbook This is the textbook for CC 315.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Homepage :: CC 315 Textbook">
    <meta itemprop="description" content="CC 315 Textbook This is the textbook for CC 315.">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2022-08-08T16:44:41-05:00">
    <meta itemprop="wordCount" content="10">
    <title>Homepage :: CC 315 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc315/" rel="canonical" type="text/html" title="Homepage :: CC 315 Textbook">
    <link href="/cc315/index.xml" rel="alternate" type="application/rss+xml" title="Homepage :: CC 315 Textbook">
    <link href="/cc315/css/fontawesome-all.min.css?1719522769" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fontawesome-all.min.css?1719522769" rel="stylesheet"></noscript>
    <link href="/cc315/css/nucleus.css?1719522769" rel="stylesheet">
    <link href="/cc315/css/auto-complete.css?1719522769" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/auto-complete.css?1719522769" rel="stylesheet"></noscript>
    <link href="/cc315/css/perfect-scrollbar.min.css?1719522769" rel="stylesheet">
    <link href="/cc315/css/fonts.css?1719522769" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc315/css/fonts.css?1719522769" rel="stylesheet"></noscript>
    <link href="/cc315/css/theme.css?1719522769" rel="stylesheet">
    <link href="/cc315/css/theme-auto.css?1719522769" rel="stylesheet" id="R-variant-style">
    <link href="/cc315/css/chroma-auto.css?1719522769" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc315/css/variant.css?1719522769" rel="stylesheet">
    <link href="/cc315/css/print.css?1719522769" rel="stylesheet" media="print">
    <link href="/cc315/css/format-print.css?1719522769" rel="stylesheet">
    <script src="/cc315/js/variant.js?1719522769"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='.';
      window.relearn.relBaseUri='..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc315';
      window.index_js_url="/cc315/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc315/css/custom.css?1719522769" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc315/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><span class="topbar-control"><i class="fa-fw fas fa-chevron-left"></i></span>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc315/00-introduction/" title="Introductory Material (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable home" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="home">
            <header class="headline">
            </header>

<h1 id="homepage">Homepage</h1>

<h1 id="cc-315-textbook">CC 315 Textbook</h1>
<p>This is the textbook for CC 315.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Homepage</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 1</div>

<h1 id="introductory-material">Introductory Material</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for the introductory material.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introductory Material</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="cc-315-syllabus">CC 315 Syllabus</h1>

<h2 id="cc-315---data-structures--algorithms-ii">CC 315 - Data Structures &amp; Algorithms II</h2>
<p><a href="/cc315/00-introduction/04-syllabus/old/">Previous Versions</a></p>
<h3 id="instructor-contact-information">Instructor Contact Information</h3>
<ul>
<li>
<p><strong>Instructor:</strong> Safia Malallah (safia AT ksu DOT edu) _I use she/her pronouns. If you need assistance, please send an email to safia @ ksu.edu, cc&rsquo;ing <a href="mailto:cis115-help@KSUemailProd.onmicrosoft.com" rel="external" target="_blank">cis115-help@KSUemailProd.onmicrosoft.com</a>. Avoid using the Canvas email function, as emailing this way ensures that your message reaches all instructors for this course, guaranteeing a swifter response. You can expect a response by the end of the next business day; feel free to reach out again if you don&rsquo;t receive a response within 24 business hours.</p>
</li>
<li>
<p><strong>Office:</strong> DUE 2161</p>
</li>
<li>
<p><strong>Virtual Office Hours:</strong> Schedule a meeting with me: <a href="https://calendly.com/safiamalallah" rel="external" target="_blank">https://calendly.com/safiamalallah</a>
Appointments held via <a href="https://ksu.zoom.us/my/safiamalallah" rel="external" target="_blank">Zoom</a>.</p>
</li>
</ul>
<h3 id="graduate-teaching-assistants">Graduate Teaching Assistants</h3>
<ul>
<li>TBD</li>
</ul>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>CC 310 - Data Structures &amp; Algorithms I</li>
</ul>
<h3 id="course-overview">Course Overview</h3>
<p>Advanced data structures and related algorithms. Formal software development methods and software engineering fundamentals. Introduction to requirements analysis processes that provide the specification of algorithmic requirements.</p>
<h3 id="course-description">Course Description</h3>
<p>This course introduces advanced data structures, such as trees, graphs, and heaps. Several new algorithms using these data structures are covered. Students also learn software development methods and software engineering fundamentals and use those skills to develop projects of increasing size and scope effectively.</p>
<h3 id="major-course-topics">Major Course Topics</h3>
<ul>
<li>Data Structures
<ul>
<li>Trees</li>
<li>Graphs</li>
<li>Heaps</li>
</ul>
</li>
<li>Algorithms
<ul>
<li>Graph Searching</li>
<li>Shortest Path</li>
<li>Minimal Spanning Tree</li>
</ul>
</li>
<li>Requirements Analysis</li>
<li>Application to Domain Areas</li>
</ul>
<h3 id="course-structure">Course Structure</h3>
<p>These courses are being taught 100% online, and each module is self-paced. There may be some bumps in the road as we refine the overall course structure. Students will work at their own pace through a set of modules, with approximately one module being due each week. Material will be provided in the form of recorded videos, online tutorials, links to online resources, and discussion prompts. Each module will include a coding project or assignment, many of which will be graded automatically through Codio. Assignments may also include portions which will be graded manually via Canvas or other tools.</p>
<p>The assigments for this course is delivered through Python programming language.</p>
<p>All activities are individual effort.  &lsquo;Group&rsquo; work is not permitted.</p>
<h3 id="for-a-better-score">For a Better Score</h3>
<p>Students are granted the opportunity to</p>
<ul>
<li>Student can have the chance to redo One coding project for a better score.
<ul>
<li>Upon selecting the project for revision, students are required to send an email to the instructor.</li>
<li>A 24-hour window is provided for students to resubmit the improved work.</li>
<li>Requests for project redo will be accepted until week 15 of the course.</li>
</ul>
</li>
<li>One late penalty will be dropped</li>
</ul>
<h3 id="codio">Codio</h3>
<p>You are expected to use the Codio Editor.  It is deliberately feature poor to place the burden of programming syntax, vocabulary and logic flow on the student.  DO NOT CUT AND PASTE into the editor while coding your projects.</p>
<p>Exception, you may cut and paste from Codio, so if you accidently delete the starter code, or want to modify a section of code you made in the tutorial.  INCLUDE a comment stating from where you &lsquo;sourced&rsquo; the pasted section.</p>
<p>from Codio tutorial 3.4.P.7
with open(sys.argv[1]) as input_file:</p>
<pre><code>try:     

    reader = input_file.readlines()

except:

    reader = sys.stdin
</code></pre>
<h3 id="grading">Grading</h3>
<p>In theory, each student begins the course with an A. As you submit work, you can either maintain your A (for good work) or chip away at it (for less adequate or incomplete work). In practice, each student starts with 0 points in the gradebook and works upward toward a final point total earned out of the possible number of points. In this course, each assignment constitutes a portion of the final grade, as detailed below:</p>
<ul>
<li>70% - Codio Programming Projects</li>
<li>30% - Codio Tutorials and Quizzes</li>
</ul>
<p>Up to 5% of the total grade in the class is available as extra credit. See the <strong>Extra Credit - Bug Bounty</strong> assignment for details.</p>
<p>Letter grades will be assigned following the standard scale:</p>
<ul>
<li>90% - 100% â†’ A</li>
<li>80% - 89.99% â†’ B</li>
<li>70% - 79.99% â†’ C</li>
<li>60% - 69.99% â†’ D</li>
<li>00% - 59.99% â†’ F</li>
</ul>
<h3 id="how-project-grades-are-assigned">How Project Grades are Assigned</h3>
<p>The Projects you submit in Codio may have both an automatic and manual grading component.</p>
<p>Automatic Components:  Codio automatically checks certain aspects of your code&rsquo;s structure and functionality.  The grade assigned by Codio is generally the ceiling of the score you can receive.</p>
<p>Manual Components:  Once submitted your code may be reviewed and deductions take for:</p>
<p>Forbidden statements/Required statements: Some assignments may prohibit the use of certain built in functions and methods. Others may require the use of certain libraries and methods.  Using prohibited statements and or skipping required statements will result in a ZERO for the project.</p>
<p>Cutting and Pasting into the Codio IDE (Project assignments): You are expected to do your work in Codio. Cutting and pasting from outside Codio is prohibited,  may result in a zero and will trigger a closer plagiarism review.</p>
<p>Running from the terminal: Codio does not typically check for proper terminal input behavior. A project that does not compile and/or run from the terminal will result in a 25% reduction in your final score.  The project should work for the sample inputs, and should not crash or print extraneous  information.</p>
<p>Having extra methods/missing required methods:  up to 10% deduction</p>
<p>Style Guide: see Pages</p>
<h3 id="late-work">Late Work</h3>

  
  
<div class="box notices cstyle warning">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
  <div class="box-content">

<p>Read this late work policy very carefully! If you are unsure how to interpret it, please contact the instructors via the help email. Not understanding the policy does not mean that it won&rsquo;t apply to you!</p>
</div>
</div>
<p>Since this course is entirely online, students may work at any time and at their own pace through the modules. However, to keep everyone on track, there will be approximately one module due each week. Each graded item in the module will have a specific due date specified. <strong>All of the components of a module will be subject to the late policy if the module is submitted late. This penalty will be assessed via a single separate assignment entry in the gradebook, containing the sum of all grade reductions in the course for that student. Late assignments will not be accepted if they have been submitted more than 3 days after the due date, unless a special reason is provided and prior approval for an extension has been obtained before the due date.</strong></p>
<p>For the purposes of recordkeeping, the submission time of the confirmation quiz in each module will be used to establish the completion time of the entire module in case of a discrepancy. This is because Codio may update submission times when assignments are regraded, but the quiz in Canvas should only be completed once.</p>
<p>However, even if a module is not submitted on time, it must still be completed before a student is allowed to begin the next module. So, students should take care not to get too far behind, as it may be very difficult to catch up.</p>
<p>Finally, all course work must be submitted on or before the last day of the semester in which the student is enrolled in the course in order for it to be graded on time.</p>
<p>If you have extenuating circumstances, please discuss them with the instructor as soon as they arise so other arrangements can be made. If you find that you are getting behind in the class, you are encouraged to speak to the instructor for options to make up missed work.</p>
<h3 id="incomplete-policy">Incomplete Policy</h3>
<p>Students should strive to complete this course in its entirety before the end of the semester in which they are enrolled. However, since retaking the course would be costly and repetitive for students, we would like to give students a chance to succeed with a little help rather than immediately fail students who are struggling.</p>
<p>If you are unable to complete the course in a timely manner, please contact the instructor to discuss an incomplete grade. Incomplete grades are given solely at the instructor&rsquo;s discretion. See the official <a href="https://www.k-state.edu/registrar/students/academicpolicy/#GRADING" rel="external" target="_blank">K-State Grading Policy</a> for more information. In general, <em>poor time management alone is not a sufficient reason for an incomplete grade</em>.</p>
<p>Unless otherwise noted in writing on a signed <a href="https://www.k-state.edu/registrar/faculty-staff/forms/Incomplete%20agreement%20form.docx" rel="external" target="_blank">Incomplete Agreement Form</a>, the following stipulations apply to any incomplete grades given in Computational Core courses:</p>
<ol>
<li>Students may receive at most two incompletes in Computational Core courses throughout their time in the program</li>
<li>Students will be given 6 calendar weeks from the end of the enrolled semester&rsquo;s finals week to complete the course</li>
<li>Any modules in a future CC course which depend on incomplete work will not be accessible until the previous course is finished</li>
<li>For example, if a student is given an incomplete in CC 210, then all modules in CC 310 will be inaccessible until CC 210 is complete</li>
<li>Students understand that access to instructor and GTA assistance may be limited after the end of an academic semester due to holidays and other obligations</li>
<li>If a student fails to resolve an incomplete grade after 6 weeks, they will be assigned an &lsquo;F&rsquo; in the course. In addition, they will be dropped from any other Computational Core courses which require the failed course as a prerequisite or corequisite.</li>
</ol>
<h3 id="authorized-aid">Authorized Aid</h3>
<p>All graded work is individual effort. You are authorized  to use:</p>
<p>course&rsquo;s materials,
direct web-links from this course
the appropriate languages documentation (<a href="https://docs.python.org/3/" rel="external" target="_blank">https://docs.python.org/3/</a>  or <a href="https://docs.oracle.com/javase/Links" rel="external" target="_blank">https://docs.oracle.com/javase/Links</a> to an external site.)
Email help received through  315 help email, CC - Instructors, GTAs
Zoom/In-person help received from Instructors or GTA
ACM help session (an on campus only resource) Most Tuesdays in EH 1116, 6:30PM.
Tutors from the Academic Assistance Center or provided by K-State Athletics
Use of on-line solutions whether for reference or code is prohibited.  Use of previous semester&rsquo;s answers, whether your own or another student&rsquo;s is prohibited.  Use of code-completion/suggestion tool&rsquo;s, other than those we have installed in the Codio editor, is prohibitied.</p>
<h3 id="work-load">Work Load</h3>
<p>CC-315 is a three-hour course;  most students find it more time consuming than CC-310.</p>
<p>Modules have been assigned so that the average amount of work (hours), based on past student performance, is somewhat consistent.</p>
<p>You may work ahead, but modules must be worked strictly in order.  Also, if you are far ahead, it may take a bit longer to get help. We review the lessons every week so the support you get is not &rsquo;too advanced&rsquo;; if you are pretty far ahead, we will need to &lsquo;catch up&rsquo; to where you are to provide support.</p>
<p>Please note, modules are not equally weighted, some are worth far more than others.</p>
<h3 id="recommended-texts--supplies">Recommended Texts &amp; Supplies</h3>
<p>To participate in this course, students must have access to a modern web browser and broadband internet connection. All course materials will be provided via Canvas and Codio. Modules may also contain links to external resources for additional information, such as programming language documentation.</p>
<h3 id="subject-to-change">Subject to Change</h3>
<p>The details in this syllabus are not set in stone. Due to the flexible nature of this class, adjustments may need to be made as the semester progresses, though they will be kept to a minimum. If any changes occur, the changes will be posted on the Canvas page for this course and emailed to all students.</p>


<h2 id="standard-syllabus-statements">Standard Syllabus Statements</h2>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>The statements below are standard syllabus statements from K-State and our program. The latest versions are available online <a href="https://www.k-state.edu/provost/resources/teaching/course.html" rel="external" target="_blank">here</a>.</p>
</div>
</div>


<h3 id="academic-honesty">Academic Honesty</h3>
<p>Kansas State University has an Honor and Integrity System based on personal integrity, which is presumed to be sufficient assurance that, in academic matters, one&rsquo;s work is performed honestly and without unauthorized assistance. Undergraduate and graduate students, by registration, acknowledge the jurisdiction of the Honor and Integrity System. The policies and procedures of the <a href="https://www.k-state.edu/honor/" rel="external" target="_blank">Honor and Integrity System</a> apply to all full and part-time students enrolled in undergraduate and graduate courses on-campus, off-campus, and via distance learning. A component vital to the Honor and Integrity System is the inclusion of the Honor Pledge which applies to all assignments, examinations, or other course work undertaken by students. The Honor Pledge is implied, whether or not it is stated: &ldquo;On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.&rdquo; A grade of XF can result from a breach of academic honesty. The F indicates failure in the course; the X indicates the reason is an Honor Pledge violation.</p>
<p><strong>For this course, a violation of the Honor Pledge will result in sanctions such as a 0 on the assignment or an XF in the course, depending on severity. Actively seeking unauthorized aid, such as posting lab assignments on sites such as Chegg or StackOverflow, or asking another person to complete your work, even if unsuccessful, will result in an immediate XF in the course.</strong></p>
<p><strong>This course assumes that all your course work will be done by you. Use of AI text and code generators such as ChatGPT and GitHub Copilot in any submission for this course is strictly forbidden unless explicitly allowed by your instructor. Any unauthorized use of these tools without proper attribution is a violation of the <a href="https://www.k-state.edu/honor/basics/pledge.html" rel="external" target="_blank">K-State Honor Pledge</a>.</strong></p>
<p>We reserve the right to use various platforms that can perform automatic plagiarism detection by tracking changes made to files and comparing submitted projects against other students&rsquo; submissions and known solutions. That information may be used to determine if plagiarism has taken place.</p>
<!-- Verified Spring 2024 -->


<h3 id="students-with-disabilities">Students with Disabilities</h3>
<p>At K-State it is important that every student has access to course content and the means to demonstrate course mastery. Students with disabilities may benefit from services including accommodations provided by the Student Access Center. Disabilities can include physical, learning, executive functions, and mental health. You may register at the <a href="https://k-state.edu/accesscenter" rel="external" target="_blank">Student Access Center</a> or to learn more contact:</p>
<ul>
<li>Manhattan/Olathe/Global Campus â€“ Student Access Center
<ul>
<li><a href="mailto:accesscenter@k-state.edu" rel="external" target="_blank">accesscenter@k-state.edu</a></li>
<li>785-532-6441</li>
</ul>
</li>
<li>K-State Salina Campus â€“ Julie Rowe; Student Success Coordinator
<ul>
<li><a href="mailto:jarowe@k-state.edu" rel="external" target="_blank">jarowe@k-state.edu</a></li>
<li>785-820-7908</li>
</ul>
</li>
</ul>
<p>Students already registered with the Student Access Center please request your Letters of Accommodation early in the semester to provide adequate time to arrange your approved academic accommodations. Once SAC approves your Letter of Accommodation it will be e-mailed to you, and your instructor(s) for this course.  Please follow up with your instructor to discuss how best to implement the approved accommodations.</p>
<!-- Verified Spring 2024 -->


<h3 id="expectations-for-conduct">Expectations for Conduct</h3>
<p>All student activities in the University, including this course, are governed by the <a href="http://www.k-state.edu/sga/judicial/" rel="external" target="_blank">Student Judicial Conduct Code</a> as outlined in the Student Governing Association <a href="https://www.k-state.edu/provost/resources/teaching/syllabi-statements/KSU-SGA-By-Laws-Fall-2021.pdf" rel="external" target="_blank">By Laws</a>, Article V, Section 3, number 2. Students who engage in behavior that disrupts the learning environment may be asked to leave the class.</p>
<!-- Updated Spring 2024 -->


<h3 id="mutual-respect-and-inclusion-in-k-state-teaching--learning-spaces">Mutual Respect and Inclusion in K-State Teaching &amp; Learning Spaces</h3>
<p>At K-State, faculty and staff are committed to creating and maintaining an inclusive and supportive learning environment for students from diverse backgrounds and perspectives. K-State courses, labs, and other virtual and physical learning spaces promote equitable opportunity to learn, participate, contribute, and succeed, regardless of age, race, color, ethnicity, nationality, genetic information, ancestry, disability, socioeconomic status, military or veteran status, immigration status, Indigenous identity, gender identity, gender expression, sexuality, religion, culture, as well as other social identities.</p>
<p>Faculty and staff are committed to promoting equity and believe the success of an inclusive learning environment relies on the participation, support, and understanding of all students. Students are encouraged to share their views and lived experiences as they relate to the course or their course experience, while recognizing they are doing so in a learning environment in which all are expected to engage with respect to honor the rights, safety, and dignity of others in keeping with the <a href="https://www.k-state.edu/about/values/community/" rel="external" target="_blank">K-State Principles of Community</a>.</p>
<p>If you feel uncomfortable because of comments or behavior encountered in this class, you may bring it to the attention of your instructor, advisors, and/or mentors. If you have questions about how to proceed with a confidential process to resolve concerns, please contact the <a href="https://www.k-state.edu/diversity-inclusion/resources/student-ombudsperson/" rel="external" target="_blank">Student Ombudsperson Office</a>. Violations of the <a href="https://www.k-state.edu/sga/judicial/student-code-of-conduct.html" rel="external" target="_blank">student code of conduct</a> can be reported using the <a href="https://cm.maxient.com/reportingform.php?KansasStateUniv&layout_id=10" rel="external" target="_blank">Code of Conduct Reporting Form</a>. You can also report <a href="https://www.k-state.edu/report/discrimination/" rel="external" target="_blank">discrimination, harassment or sexual harassment</a>, if needed.</p>
<!-- Verified Spring 2024 -->


<h3 id="netiquette">Netiquette</h3>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>This is our personal policy and not a required syllabus statement from K-State. It has been adapted from <a href="https://global.k-state.edu/students/courses/netiquette/" rel="external" target="_blank">this statement</a> from K-State Global Campus, and the<a href="https://www.recurse.com/manual" rel="external" target="_blank">Recurse Center Manual</a>. We have adapted their ideas to fit this course.</p>
</div>
</div>
<p>Online communication is inherently different than in-person communication. When speaking in person, many times we can take advantage of the <em>context</em> and <em>body language</em> of the person speaking to better understand what the speaker <em>means</em>, not just what is said. This information is not present when communicating online, so we must be much more careful about what we say and how we say it in order to get our meaning across.</p>
<p>Here are a few general rules to help us all communicate online in this course, especially while using tools such as Canvas or Discord:</p>
<ul>
<li><strong>Use a clear and meaningful subject line to announce your topic.</strong> Subject lines such as &ldquo;Question&rdquo; or &ldquo;Problem&rdquo; are not helpful. Subjects such as &ldquo;Logic Question in Project 5, Part 1 in Java&rdquo; or &ldquo;Unexpected Exception when Opening Text File in Python&rdquo; give plenty of information about your topic.</li>
<li><strong>Use only one topic per message.</strong> If you have multiple topics, post multiple messages so each one can be discussed independently.</li>
<li><strong>Be thorough, concise, and to the point.</strong> Ideally, each message should be a page or less.</li>
<li><strong>Include exact error messages, code snippets, or screenshots, as well as any previous steps taken to fix the problem.</strong> It is much easier to solve a problem when the exact error message or screenshot is provided. If we know what you&rsquo;ve tried so far, we can get to the root cause of the issue more quickly.</li>
<li><strong>Consider carefully what you write before you post it.</strong> Once a message is posted, it becomes part of the permanent record of the course and can easily be found by others.</li>
<li><strong>If you are lost, don&rsquo;t know an answer, or don&rsquo;t understand something, speak up!</strong> Email and Canvas both allow you to send a message privately to the instructors, so other students won&rsquo;t see that you asked a question. Don&rsquo;t be afraid to ask questions anytime, as you can choose to do so without any fear of being identified by your fellow students.</li>
<li><strong>Class discussions are confidential.</strong> Do not share information from the course with anyone outside of the course without explicit permission.</li>
<li><strong>Do not quote entire message chains; only include the relevant parts.</strong> When replying to a previous message, only quote the relevant lines in your response.</li>
<li><strong>Do not use all caps.</strong> It makes it look like you are shouting. Use appropriate text markup (bold, italics, etc.) to highlight a point if needed.</li>
<li><strong>No feigning surprise.</strong> If someone asks a question, saying things like &ldquo;I can&rsquo;t believe you don&rsquo;t know that!&rdquo; are not helpful, and only serve to make that person feel bad.</li>
<li><strong>No &ldquo;well-actually&rsquo;s.&rdquo;</strong> If someone makes a statement that is not entirely correct, resist the urge to offer a &ldquo;well, actually&hellip;&rdquo; correction, especially if it is not relevant to the discussion. If you can help solve their problem, feel free to provide correct information, but don&rsquo;t post a correction just for the sake of being correct.</li>
<li><strong>Do not correct someone&rsquo;s grammar or spelling.</strong> Again, it is not helpful, and only serves to make that person feel bad. If there is a genuine mistake that may affect the meaning of the post, please contact the person privately or let the instructors know privately so it can be resolved.</li>
<li><strong>Avoid subtle -isms and microaggressions.</strong> Avoid comments that could make others feel uncomfortable based on their personal identity. See the syllabus section on Diversity and Inclusion above for more information on this topic. If a comment makes you uncomfortable, please contact the instructor.</li>
<li><strong>Avoid sarcasm, flaming, advertisements, lingo, trolling, doxxing, and other bad online habits.</strong> They have no place in an academic environment. Tasteful humor is fine, but sarcasm can be misunderstood.</li>
</ul>
<p>As a participant in course discussions, you should also strive to honor the diversity of your classmates by adhering to the <a href="https://www.k-state.edu/about/values/community/" rel="external" target="_blank">K-State Principles of Community</a>.</p>
<!-- Verified Spring 2024 -->


<h3 id="discrimination-harassment-and-sexual-harassment">Discrimination, Harassment, and Sexual Harassment</h3>
<p>Kansas State University is committed to maintaining academic, housing, and work environments that are free of discrimination, harassment, and sexual harassment. Instructors support the Universityâ€™s commitment by creating a safe learning environment during this course, free of conduct that would interfere with your academic opportunities. Instructors also have a <a href="https://www.k-state.edu/oie/faqs.html" rel="external" target="_blank">duty to report</a> any behavior they become aware of that potentially violates the Universityâ€™s policy prohibiting discrimination, harassment, and sexual harassment, as outlined by <a href="https://www.k-state.edu/policies/ppm/3000/3010.html" rel="external" target="_blank">PPM 3010</a>.</p>
<p>If a student is subjected to discrimination, harassment, or sexual harassment, they are encouraged to make a non-confidential report to the Universityâ€™s <a href="https://www.k-state.edu/oie/" rel="external" target="_blank">Office for Institutional Equity (OIE)</a> using the <a href="https://cm.maxient.com/reportingform.php?KansasStateUniv&layout_id=34" rel="external" target="_blank">online reporting form</a>. Incident disclosure is not required to receive resources at K-State. Reports that include domestic and dating violence, sexual assault, or stalking, should be considered for reporting by the complainant to the <a href="https://www.k-state.edu/police/suggest/" rel="external" target="_blank">Kansas State University Police Department</a> or the <a href="https://www.rileycountypolice.org/" rel="external" target="_blank">Riley County Police Department</a>. Reports made to law enforcement are separate from reports made to OIE. A complainant can choose to report to one or both entities. Confidential support and advocacy can be found with the <a href="https://www.k-state.edu/care/" rel="external" target="_blank">K-State Center for Advocacy, Response, and Education (CARE)</a>. Confidential mental health services can be found with <a href="https://www.k-state.edu/counseling/" rel="external" target="_blank">Lafene Counseling and Psychological Services (CAPS)</a>. Academic support can be found with the <a href="https://www.k-state.edu/studentlife/" rel="external" target="_blank">Office of Student Life (OSL)</a>. OSL is a non-confidential resource. OIE also provides a <a href="https://www.k-state.edu/oie/resources.html" rel="external" target="_blank">comprehensive list of resources</a> on their website. If you have questions about non-confidential and confidential resources, please contact OIE at <a href="mailto:equity@ksu.edu" rel="external" target="_blank">equity@ksu.edu</a> or (785) 532â€“6220.</p>
<!-- Verified Spring 2024 -->


<h3 id="academic-freedom-statement">Academic Freedom Statement</h3>
<p>Kansas State University is a community of students, faculty, and staff who work together to discover new knowledge, create new ideas, and share the results of their scholarly inquiry with the wider public. Although new ideas or research results may be controversial or challenge established views, the health and growth of any society requires frank intellectual exchange. Academic freedom protects this type of free exchange and is thus essential to any university&rsquo;s mission.</p>
<p>Moreover, academic freedom supports collaborative work in the pursuit of truth and the dissemination of knowledge in an environment of inquiry, respectful debate, and professionalism. Academic freedom is not limited to the classroom or to scientific and scholarly research, but extends to the life of the university as well as to larger social and political questions. It is the right and responsibility of the university community to engage with such issues.</p>
<!-- Verified Spring 2024 -->


<h3 id="campus-safety">Campus Safety</h3>
<p>Kansas State University is committed to providing a safe teaching and learning environment for student and faculty members. In order to enhance your safety in the unlikely case of a campus emergency make sure that you know where and how to quickly exit your classroom and how to follow any emergency directives. Current Campus Emergency Information is available at the <a href="https://www.k-state.edu/advisories/" rel="external" target="_blank">Universityâ€™s Advisory</a> webpage.</p>
<!-- Verified Spring 2024 -->


<h3 id="student-resources">Student Resources</h3>
<p>K-State has many resources to help contribute to student success. These resources include accommodations for academics, paying for college, student life, health and safety, and others. Check out the <a href="https://www.k-state.edu/onestop/" rel="external" target="_blank">Student Guide to Help and Resources: One Stop Shop</a> for more information.</p>
<!-- Verified Spring 2024 -->


<h3 id="student-academic-creations">Student Academic Creations</h3>
<p>Student academic creations are subject to Kansas State University and Kansas Board of Regents Intellectual Property Policies. For courses in which students will be creating intellectual property, the K-State policy can be found at <a href="https://www.k-state.edu/provost/universityhb/fhxr.html" rel="external" target="_blank">University Handbook, Appendix R: Intellectual Property Policy and Institutional Procedures (part I.E.)</a>. These policies address ownership and use of student academic creations.</p>
<!-- Verified Spring 2024 -->


<h3 id="mental-health">Mental Health</h3>
<p>Your mental health and good relationships are vital to your overall well-being. Symptoms of mental health issues may include excessive sadness or worry, thoughts of death or self-harm, inability to concentrate, lack of motivation, or substance abuse. Although problems can occur anytime for anyone, you should pay extra attention to your mental health if you are feeling academic or financial stress, discrimination, or have experienced a traumatic event, such as loss of a friend or family member, sexual assault or other physical or emotional abuse.</p>
<p>If you are struggling with these issues, do not wait to seek assistance.</p>
<ul>
<li><a href="https://www.k-state.edu/counseling/" rel="external" target="_blank">Kansas State University Counseling and Psychological Services</a> offers free and confidential services to assist you to meet these challenges.</li>
<li><a href="https://www.k-state.edu/lafene" rel="external" target="_blank">Lafene Health Center</a> has specialized nurse practitioners to assist with mental health.</li>
<li><a href="https://www.k-state.edu/studentlife" rel="external" target="_blank">The Office of Student Life</a> can direct you to additional resources.</li>
<li><a href="https://www.hhs.k-state.edu/familycenter/" rel="external" target="_blank">K-State Family Center</a> offers individual, couple, and family counseling services on a sliding fee scale.</li>
<li><a href="https://www.k-state.edu/care/" rel="external" target="_blank">Center for Advocacy, Response, and Education (CARE)</a> provides free and confidential assistance for those in our K-State community who have been victimized by violence.</li>
</ul>
<p>For Kansas State Salina Campus:</p>
<ul>
<li><a href="https://polytechnic.k-state.edu/studentlife/health/counseling.html" rel="external" target="_blank">Kansas State Salina Counseling Services</a> offers free and confidential services to assist you to meet these challenges.</li>
<li><a href="https://www.salina.k-state.edu/student-life/" rel="external" target="_blank">The Kansas State Salina Office of Student Life</a> can direct you to additional resources.</li>
<li><a href="https://www.k-state.edu/oie/documents/SalinaResourceSupportWheel.pdf" rel="external" target="_blank">The Kansas State Salina Campus</a> offers several services for students, including health services, counseling, and academic assistance.</li>
</ul>
<p>For Global Campus/K-State Online:</p>
<ul>
<li>K-State Online students have free access to mental health counseling with <a href="https://www.k-state.edu/lafene/programs/myssp.html" rel="external" target="_blank">My SSP</a> - 24/7 support via chat and phone.</li>
<li>The <a href="https://www.k-state.edu/studentlife/" rel="external" target="_blank">Office of Student Life</a> can direct you to additional resources.</li>
</ul>
<!-- Verified Spring 2024 -->


<h3 id="university-excused-absences">University Excused Absences</h3>
<p>K-State has a <a href="https://www.k-state.edu/provost/universityhb/fhsecf.html" rel="external" target="_blank">University Excused Absence policy (Section F62)</a>. Class absence(s) will be handled between the instructor and the student unless there are other university offices involved. For university excused absences, instructors shall provide the student the opportunity to make up missed assignments, activities, and/or attendance specific points that contribute to the course grade, unless they decide to excuse those missed assignments from the studentâ€™s course grade. Please see the policy for a complete list of university excused absences and how to obtain one. Students are encouraged to contact their instructor regarding their absences.</p>
<!-- Verified Spring 2024 -->


<h3 id="copyright-notice">Copyright Notice</h3>
<p>Â© The materials in this online course fall under the protection of all intellectual property, copyright and trademark laws of the U.S. The digital materials included here come with the legal permissions and releases of the copyright holders.  These course materials should be used for educational purposes only; the contents should not be distributed electronically or otherwise beyond the confines of this online course. The URLs listed here do not suggest endorsement of either the site owners or the contents found at the sites. Likewise, mentioned brands (products and services) do not suggest endorsement. Students own copyright to what they create.</p>
<!-- Verified Spring 2024 -->


            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of CC 315 Syllabus</h1>
    
    
          </section>
          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 5</div>

<h1 id="strings-and-stringbuilders">Strings and StringBuilders</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for the Strings and StringBuilders Section</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Strings and StringBuilders</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 5</div>

<h1 id="strings-and-stringbuilders">Strings and StringBuilders</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for the Strings and StringBuilders chapter</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Strings and StringBuilders</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=zcCtPamophM">YouTube Video</a>

<p><a href="/cc315/i-strings/1-strings-and-stringbuilders/01-introduction/video/">Video Materials</a></p>
<p>In CC310 we covered various data structures: stacks, sets, lists, queues, and hash tables. When we looked at these structures, we considered how to access elements within the structures, how we would create our own implementation of the structure, and tasks that these structures would be fitting for as well as ill fitting. Throughout this course we will introduce and implement a variety of data structures as we did in CC310.</p>
<p>We begin this course with an often overlooked structure: strings. By the end of this chapter, we will understand how strings are data structures, how we access elements, what types of tasks are appropriate for strings, and how we can improve on strings in our code.</p>
<h2 id="motivation">Motivation</h2>
<p>In many data science positions, programmers often work with text-based data. Some examples of text-based data include biology for DNA sequencing, social media for sentiment classification, online libraries for citation networks, and many other types of businesses for data analytics. Currently, strings are often used for word embeddings, which determine how similar or dissimilar words are to one another. An industry leading software for this application is Tensorflow for Python, which generated the image below.</p>
<p><a href="#R-image-f1bcedb37fc938b14a913f982b3d461e" class="lightbox-link"><img alt="Word Embeddings Near &lsquo;Python&rsquo;" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1_word_embedding.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f1bcedb37fc938b14a913f982b3d461e"><img alt="Word Embeddings Near &lsquo;Python&rsquo;" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1_word_embedding.png"></a></p>
<!--- https://projector.tensorflow.org/ I generated and took this screen shot. --->
<p>In an immense oversimplification, the process used for word embeddings is to read in a large amount of text and then use machine learning algorithms to determine similarity by using the words around each word. This impacts general users like us in search engines, streaming services, dating applications, and much more! For example, if you were to search Python topics in your search results may appear referring to the coding language, the reptile, the comedy troupe, and many more. When we use machine learning to determine word meanings, it is important that the data is first parsed correctly and stored in efficient ways so that we can access elements as needed. Understanding how to work with strings and problems that can arise with them is important to utilizing text successfully.</p>
<p>Reference: <a href="https://projector.tensorflow.org/" rel="external" target="_blank">https://projector.tensorflow.org/</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introduction</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="theory">Theory</h1>


<a href="https://www.youtube.com/watch?v=KII6o4G5I_U">YouTube Video</a>

<p><a href="/cc315/i-strings/1-strings-and-stringbuilders/02-theory/video/">Video Materials</a></p>
<h2 id="what-are-strings">What are Strings?</h2>
<p>Strings are data structures which store an ordered set of characters. Recall that a character can be a: letter, number, symbol, punctuation mark, or white space. Strings can contain any number and any combination of these. As such, strings can be single characters, words, sentences, and even more.</p>
<h2 id="how-do-we-work-with-strings">How do we work with Strings?</h2>
<p>Let&rsquo;s refresh ourselves on how strings work, starting with the example string: <code>s = &quot;Go Cats!&quot;</code>.</p>
<table>
<thead>
<tr>
<th><a href="/cc315/i-strings/1-strings-and-stringbuilders/02-theory/"></a></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Character</td>
<td>G</td>
<td>o</td>
<td></td>
<td>C</td>
<td>a</td>
<td>t</td>
<td>s</td>
<td>!</td>
</tr>
<tr>
<td>Index</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>As with other data structures, we can access elements within the string itself. Using the example above, <code>s[0]</code> would contain the character &lsquo;G&rsquo;, <code>s[1]</code> would contain the character &lsquo;o&rsquo;, <code>s[2]</code> would contain the character &rsquo; &lsquo;, and so on.</p>
<p>We can determine the size of a string by using length functions; in our example, the length of s would be 8. It is also important to note that when dealing with strings, null is not equivalent to &ldquo;&rdquo;. For string <code>s = &quot;&quot;</code>, the length of s would be 0. However for string <code>s = null</code>, accessing the length of s would return an error that null has no length property.</p>
<p>We can also add to strings or append on a surface level; though it is not that simple behind the scenes. The String class is <strong>immutable</strong>. This means that changes will not happen directly to the string; when appending or inserting, code will create a new string to hold that value. More concisely, the state of an immutable object cannot change.</p>
<p>We cannot assign elements of the string directly and more broadly for any immutable object. For example, if we wanted the string from our example to be &lsquo;Go Cat!!&rsquo;, we cannot assign the element through <code>s[6] = '!'</code>. This would result in an item assignment error.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<h1 id="try-it">Try it!</h1>
<p>For an example, consider string s = &lsquo;abc&rsquo;. If we then state in code s = s + &lsquo;123&rsquo;, this will create a new place in memory for the new definition of s. We can verify this in code by using the id() function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">string s = &#39;abc&#39;
</span></span><span class="line"><span class="cl">id(s)
</span></span><span class="line"><span class="cl">Output: 140240213073680 #may be different on your personal device
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">string s = s + &#39;123&#39;
</span></span><span class="line"><span class="cl">id(s)
</span></span><span class="line"><span class="cl">Output: 140239945470168 </span></span></code></pre></div></div>
</div>
<p>While on the surface it appears that we are working with the same variable, our code will actually refer to a different one. There are many other immutable data types as well as mutable data types.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<h1 id="mutable-vs-immutable">Mutable vs. Immutable</h1>
<p>On the topic of immutable, we can also discuss the converse: <strong>mutable</strong> objects. Being a mutable object means that the state of the object can change. In CC310, we often worked with arrays to implement various data structures. Arrays are mutable, so as we add, change, or remove elements from an array, the array changes its state to accommodate the change rather than creating a new location in memory.</p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>Immutable?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lists</td>
<td>â˜</td>
</tr>
<tr>
<td>Sets</td>
<td>â˜</td>
</tr>
<tr>
<td>Byte Arrays</td>
<td>â˜</td>
</tr>
<tr>
<td>Dictionaries</td>
<td>â˜</td>
</tr>
<tr>
<td>Strings</td>
<td>â˜‘</td>
</tr>
<tr>
<td>Ints</td>
<td>â˜‘</td>
</tr>
<tr>
<td>Floats</td>
<td>â˜‘</td>
</tr>
<tr>
<td>Booleans</td>
<td>â˜‘</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Reference: <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/strings/strings.html" rel="external" target="_blank">http://people.cs.ksu.edu/~rhowell/DataStructures/strings/strings.html</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Theory</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="memory-example">Memory Example</h1>

<p>Consider the following block of pseudocode:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><p>Lets step through the function call with <code>APPENDER(4,'abc')</code> and analyze the memory that the code takes.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that strings are reference variables. As such, string variables hold pointers to values and the value is stored in memory. For the following example, the <code>HEAP</code> refers to what is currently stored in memory and <code>VARIABLE</code> shows the current value of the variable <code>RESULT</code>.</p>
</div>
</div>
<ul>
<li>
<p>Initialization: In line two, we initialize <code>RESULT</code> as an empty string. In the heap, we have the empty string at memory location <code>0x1</code>. Thus, <code>RESULT</code> is holding the pointer <code>0x1</code>.
<a href="#R-image-7adbada2cba261ecea154103a8ea5d72" class="lightbox-link"><img alt="Initialize" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1mem_map1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7adbada2cba261ecea154103a8ea5d72"><img alt="Initialize" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1mem_map1.png"></a></p>
</li>
<li>
<p>I = 1: Now we have entered the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x2</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x2</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 1</code>, so we take the else branch. We again add characters to our string, resulting in a new entry in <code>0x3</code> and our variable <code>RESULT</code> containing the pointer <code>0x3</code>. In total, we have written 8 characters. We then increment <code>I</code> and move to the next iteration.
<a href="#R-image-5b3ed8843932da6b89c7fa2bca9093d7" class="lightbox-link"><img alt="After 1st loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1mem_map3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5b3ed8843932da6b89c7fa2bca9093d7"><img alt="After 1st loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1mem_map3.png"></a></p>
</li>
<li>
<p>I = 2: We continue the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x4</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x4</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 2</code>, so we take the if branch. We again add characters to our string, resulting in a new entry in <code>0x5</code> and our variable <code>RESULT</code> containing the pointer <code>0x5</code>. In this iteration, we have written 17 characters. We then increment <code>I</code> and move to the next iteration of the loop.
<a href="#R-image-34fd3ab4da162c1a484cccdb81931f9d" class="lightbox-link"><img alt="After 2nd loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1mem_map5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34fd3ab4da162c1a484cccdb81931f9d"><img alt="After 2nd loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1mem_map5.png"></a></p>
</li>
<li>
<p>I = 3: We continue the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x6</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x6</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 3</code>, so we take the if branch. We again add characters to our string, resulting in a new entry in <code>0x7</code> and our variable <code>RESULT</code> containing the pointer <code>0x7</code>. In this iteration, we have written 26 characters. We then increment <code>I</code> and thus <code>I = 4</code> breaking out of the loop.
<a href="#R-image-5a64e21a083b154b1b74684987896342" class="lightbox-link"><img alt="After 3rd loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1mem_map7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5a64e21a083b154b1b74684987896342"><img alt="After 3rd loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1mem_map7.png"></a></p>
</li>
</ul>
<p>We can do some further analysis of the memory that is required for this particular block.</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Memory Entries</th>
<th>Total Character Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>8 + 17 = 25</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>25 + 26 = 51</td>
</tr>
<tr>
<td>4</td>
<td>9</td>
<td>51 + 35 = 86</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>n</td>
<td>2n + 1</td>
<td>(9n<sup>2</sup> + 7n)/2</td>
</tr>
</tbody>
</table>
<p>You need not worry about creating the equations! Based on this generalization, if the user wanted to do 100K iterations, say for gene sequencing, there would be (2x100,000 - 1) = 200,001 memory entries and (9x100,000<sup>2</sup> + 7x100,000)/2 = 45 billion character copies. This behavior is not exclusive to strings; this will occur for any immutable type.</p>
<p>While this example is contrived, it is not too far off the mark. Another caveat to this analysis is that, depending on our programming language, there will be a periodic &lsquo;memory collection&rsquo;; there wont be 200K memory addresses occupied at one time. Writing to memory in this way can be costly in terms of time, which in industry is money.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="limitations-java">Limitations Java</h1>


<a href="https://www.youtube.com/watch?v=mHOqqh-M2us">YouTube Video</a>

<p><a href="/cc315/i-strings/1-strings-and-stringbuilders/04-j-memory-example/video/">Video Materials</a></p>
<p>As a result of being immutable, strings can be cumbersome to work with in certain applications. When long strings or strings that we are continually appending to, such as in the memory example, we end up creating a lot of sizable copies.</p>
<p>Recall from the memory example the block of pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><p>In this example, what if we changed <code>RESULT</code> to a mutable type, say a list of strings for Python or a StringBuilder in Java. Once the loop is done, we can cast <code>RESULT</code> to a string. By changing just the one aspect of the code, we would make only one copy of <code>RESULT</code> and have far less character copies.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Java specifically has a <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" rel="external" target="_blank">StringBuilder class</a> which was created for this precise reason.</p>
</div>
</div>
<p>Consider the following, and note the slight changes on lines 2, 4, 6, 8 and the additional line 10.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER<span class="nb">_</span>LIST(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = []
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT.APPEND(BASE) 
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT.APPEND(&#34; &#34;) 
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT.APPEND(&#34;, &#34;)  
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    RESULT = &#34;&#34;.JOIN(RESULT)
</span></span><span class="line"><span class="cl">11.    return RESULT
</span></span><span class="line"><span class="cl">12. end function</span></span></code></pre></div><p>Now consider APPENDER_LIST(4,&lsquo;abc&rsquo;)</p>
<ul>
<li>
<p>Initialization: We start by initializing the empty array. <code>RESULT</code> will hold the pointer <code>0x1</code>.
<a href="#R-image-068c2b83edc61bc90ebbed438dd28a93" class="lightbox-link"><img alt="Initialize" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-068c2b83edc61bc90ebbed438dd28a93"><img alt="Initialize" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map1.png"></a></p>
</li>
<li>
<p>I = 1: Now we have entered the loop and on line 4, we add more characters to our array. At this point, we would have only entry <code>0x1</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x1</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 1</code>, so we take the else branch. We again add characters to our array.  In total, we have written 5 characters. We then increment I and move to the next iteration.<br>
<a href="#R-image-843000e4070faf08b274eda7cd7cbe6f" class="lightbox-link"><img alt="After 1st Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-843000e4070faf08b274eda7cd7cbe6f"><img alt="After 1st Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map3.png"></a></p>
</li>
<li>
<p>I = 2: We continue the loop and on line 4, we add more characters to our array. We still have just one entry in memory and our pointer is still <code>0x1</code>. In this iteration, we have written 4 characters. We then increment <code>I</code> and move to the next iteration of the loop.
<a href="#R-image-2b498ca5c801188c9bb7a88172f45fb2" class="lightbox-link"><img alt="After 2nd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b498ca5c801188c9bb7a88172f45fb2"><img alt="After 2nd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map5.png"></a></p>
</li>
<li>
<p>I = 3: We continue the loop and on line 4, we add more characters to our array.  In this iteration, we have written 5 characters. We then increment <code>I</code> and thus <code>I = 4</code> breaking out of the loop.
<a href="#R-image-9cd619779908463d12225791a3747aec" class="lightbox-link"><img alt="After 3rd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9cd619779908463d12225791a3747aec"><img alt="After 3rd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map7.png"></a></p>
</li>
<li>
<p>Post-Loop: Once the loop breaks, we join the array to create the final string. This creates a new place in memory and changes RESULT to contain the pointer <code>0x2</code>.
<a href="#R-image-facf5ca03e0c0dbbde1ee4c3f948213c" class="lightbox-link"><img alt="After Loop Breaks" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-facf5ca03e0c0dbbde1ee4c3f948213c"><img alt="After Loop Breaks" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map8.png"></a></p>
</li>
</ul>
<p>We can do some further analysis of the memory that is required for this particular block.</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Memory Entries</th>
<th>Character Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>17</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>26</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>35</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>n</td>
<td>2</td>
<td>9n - 1</td>
</tr>
</tbody>
</table>
<p>Again, you need not worry about creating these equations for this course. To illustrate the improvement even more explicitly, let&rsquo;s consider our previous example with 100K iterations. For APPENDER there were (2x100,000 - 1) = 200,001 memory entries and (9x100,000<sup>2</sup> + 7x100,000)/2 = 45 billion character copies. For APPENDER_LIST we now have just 2 memory entries and (9x100,000 - 1) = 899,999 character copies. This dramatic improvement was a result of changing our data structure ever so slightly.</p>
<p>Reference: <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html" rel="external" target="_blank">http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Limitations Java</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="limitations-python">Limitations Python</h1>


<a href="https://www.youtube.com/watch?v=gsE16hh3iQQ">YouTube Video</a>

<p><a href="/cc315/i-strings/1-strings-and-stringbuilders/04-p-memory-example/video/">Video Materials</a></p>
<p>As a result of being immutable, strings can be cumbersome to work with in certain applications. When working with long strings or strings that we are continually appending to, such as in the memory example, we end up creating a lot of sizable copies.</p>
<p>Recall from the memory example the block of pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><p>In this example, what if we changed <code>RESULT</code> to a mutable type, such as a StringBuilder in Java. Once the loop is done, we can cast <code>RESULT</code> to a string. By changing just the one aspect of the code, we would make only one copy of <code>RESULT</code> and have far less character copies.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Java specifically has a <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" rel="external" target="_blank">StringBuilder class</a> which was created for this precise reason.</p>
</div>
</div>
<p>Consider the following, and note the slight changes on lines 2, 4, 6, 8 and the additional line 10.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER<span class="nb">_</span>LIST(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = []
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT.APPEND(BASE) 
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT.APPEND(&#34; &#34;) 
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT.APPEND(&#34;, &#34;)  
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    RESULT = &#34;&#34;.JOIN(RESULT)
</span></span><span class="line"><span class="cl">11.    return RESULT
</span></span><span class="line"><span class="cl">12. end function</span></span></code></pre></div><p>Now consider APPENDER_LIST(4,&lsquo;abc&rsquo;)</p>
<ul>
<li>
<p>Initialization: We start by initializing the empty array. <code>RESULT</code> will hold the pointer <code>0x1</code>.
<a href="#R-image-fc14fb3e0d8c52adcd9dbb6547cf1fbc" class="lightbox-link"><img alt="Initialize" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc14fb3e0d8c52adcd9dbb6547cf1fbc"><img alt="Initialize" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map1.png"></a></p>
</li>
<li>
<p>I = 1: Now we have entered the loop and on line 4, we add more characters to our array. At this point, we would have only entry <code>0x1</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x1</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 1</code>, so we take the else branch. We again add characters to our array.  In total, we have written 5 characters. We then increment I and move to the next iteration.<br>
<a href="#R-image-226f2ad08ffb8e375737b854ca7b3ddd" class="lightbox-link"><img alt="After 1st Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-226f2ad08ffb8e375737b854ca7b3ddd"><img alt="After 1st Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map3.png"></a></p>
</li>
<li>
<p>I = 2: We continue the loop and on line 4, we add more characters to our array. We still have just one entry in memory and our pointer is still <code>0x1</code>. In this iteration, we have written 4 characters. We then increment <code>I</code> and move to the next iteration of the loop.
<a href="#R-image-de51f81781563456831619e6a7251783" class="lightbox-link"><img alt="After 2nd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de51f81781563456831619e6a7251783"><img alt="After 2nd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map5.png"></a></p>
</li>
<li>
<p>I = 3: We continue the loop and on line 4, we add more characters to our array.  In this iteration, we have written 5 characters. We then increment <code>I</code> and thus <code>I = 4</code> breaking out of the loop.
<a href="#R-image-1ff40e1617b11b69665bf129f8e9a8fa" class="lightbox-link"><img alt="After 3rd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ff40e1617b11b69665bf129f8e9a8fa"><img alt="After 3rd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map7.png"></a></p>
</li>
<li>
<p>Post-Loop: Once the loop breaks, we join the array to create the final string. This creates a new place in memory and changes RESULT to contain the pointer <code>0x2</code>.
<a href="#R-image-7cc3cdc854e91607785f5165adba32ea" class="lightbox-link"><img alt="After Loop Breaks" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/1SB_mem_map8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7cc3cdc854e91607785f5165adba32ea"><img alt="After Loop Breaks" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/1SB_mem_map8.png"></a></p>
</li>
</ul>
<p>We can do some further analysis of the memory that is required for this particular block.</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Memory Entries</th>
<th>Character Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>17</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>26</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>35</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>n</td>
<td>2</td>
<td>9n - 1</td>
</tr>
</tbody>
</table>
<p>Again, you need not worry about creating these equations for this course. To illustrate the improvement even more explicitly, let&rsquo;s consider our previous example with 100K iterations. For APPENDER there were (2x100,000 - 1) = 200,001 memory entries and (9x100,000<sup>2</sup> + 7x100,000)/2 = 45 billion character copies. For APPENDER_LIST we now have just 2 memory entries and (9x100,000 - 1) = 899,999 character copies. This dramatic improvement was a result of changing our data structure ever so slightly.</p>
<p>Reference: <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html" rel="external" target="_blank">http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Limitations Python</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>


<a href="https://www.youtube.com/watch?v=MJ1tkFIDEAA">YouTube Video</a>

<p><a href="/cc315/i-strings/1-strings-and-stringbuilders/05-summary/video/">Video Materials</a></p>
<p>To start this course, we have looked into strings. They are a very natural way to represent data, especially in real world applications. Often though, the datapoints can be very large and require multiple modifications. We also examined how strings work: element access, retrieving the size, and modifying them. We looked into some alternatives which included StringBuilders for Java and character arrays for Python.</p>
<p>To really understand this point, we have included a comparison. We have implemented the APPENDER and APPENDER_LIST functions in both Python and Java. For the Java implementation, we utilized StringBuilders.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER<span class="nb">_</span>LIST(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = []
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT.APPEND(BASE) 
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT.APPEND(&#34; &#34;) 
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT.APPEND(&#34;, &#34;)  
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    RESULT = &#34;&#34;.JOIN(RESULT)
</span></span><span class="line"><span class="cl">11.    return RESULT
</span></span><span class="line"><span class="cl">12. end function</span></span></code></pre></div>
  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For the tests of 10<sup>8</sup> and 10<sup>9</sup> in Java, the string implementation took over 24 hours and the StringBuilder implementation ran out of memory. For these reasons, they are omitted from the figure.</p>
</div>
</div>
<p><a href="#R-image-b6e0cd3d8f46c0e55b924f7835ff169d" class="lightbox-link"><img alt="Python Time" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/315_stringsTime_python.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b6e0cd3d8f46c0e55b924f7835ff169d"><img alt="Python Time" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/315_stringsTime_python.png"></a>
<a href="#R-image-a7bafe927e26824d1bd830a89d313a80" class="lightbox-link"><img alt="Java Time" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/1/315_stringsTime_java.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a7bafe927e26824d1bd830a89d313a80"><img alt="Java Time" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/1/315_stringsTime_java.png"></a></p>
<p>These figures compare  Strings and lists for Python and Strings and StringBuilders for Java. The intention of these is not to compare Python and Java.</p>
<p>In both languages, we see that the string function and the respective alternative performed comparably until approximately 10<sup>6</sup> (1,000,000 characters). Again, these are somewhat contrived examples with the intention of understanding side effects of using strings.</p>
<p>As we have discussed, modern coding languages will have clean up protocols and memory management strategies. With the intention of this class in mind, we will not discuss the memory analysis in practice.</p>
<p>When modifying strings we need to be cognizant of how often we will be making changes and how large those changes will be. If we are just accessing particular elements or only doing a few modifications then using plain strings is a reasonable solution. However, if we are looking to build our own DNA sequence this is not a good way to go as strings are immutable.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Summary</h1>
    
    
          </section>
          </section>
          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 5</div>

<h1 id="trees">Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for the Trees Section. This section has chapters which cover:</p>
<ol start="2">
<li>Basic Trees</li>
<li>Recursive Trees</li>
<li>Tries</li>
<li>Binary Trees</li>
</ol>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Trees</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 10</div>

<h1 id="introduction-to-trees">Introduction to Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Introduction to Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introduction to Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=As_g6_ozRkU">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/1-introduction/video/">Video Materials</a></p>
<p>For the next data structure in the course, we will cover trees, which are used to show hierarchical data. Trees can have many shapes and sizes and there is a wide variety of data that can be organized using them. Real world data that is appropriate for trees can include: family trees, management structures, file systems, biological classifications, anatomical structures and much more.</p>
<hr>
<p>We can look at an example of a tree and the relationships they can show. Consider this file tree; it has folders and files in folders.
<a href="#R-image-fb3d20c28d0f4a7961842080e812a18a" class="lightbox-link"><img alt="File Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2FileTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb3d20c28d0f4a7961842080e812a18a"><img alt="File Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2FileTree.png"></a></p>
<p>If we wanted to access the file <code>elm.txt</code>, we would have to follow this file path: <code>Foo/B/Q/E/elm.txt</code>. We can similarly store the file structure as a tree like we below. As before, if we wanted to get to the file <code>elm.txt</code> we would navigate the tree in the order: <code>Foo -&gt; B -&gt; Q -&gt; E -&gt; elm.txt</code>. As mentioned before, trees can be used on very diverse data sets; they are not limited to file trees!
<a href="#R-image-98cd143c7c3402659922d637ef16c0cd" class="lightbox-link"><img alt="File Tree as Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_FileTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-98cd143c7c3402659922d637ef16c0cd"><img alt="File Tree as Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_FileTree.png"></a></p>
<h2 id="what-are-trees">What are trees?</h2>
<p>In the last module we talked about strings which are a linear data structure. To be explicit, this means that the elements in a string form a line of characters. A tree, by contrast, is a <strong>hierarchal structure</strong> which is utilized best in multidimensional data. Going back to our file tree example, folders are not limited to just one file, there can be multiple files contained in a single folder- thus making it multidimensional.</p>
<p>Consider the string &ldquo;abc123&rdquo;; this is a linear piece of data where there is exactly one character after another. We can use trees to show linear data as well.
<a href="#R-image-c35261af58d2db65b915a142f052d7af" class="lightbox-link"><img alt="String as Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_String.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c35261af58d2db65b915a142f052d7af"><img alt="String as Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_String.png"></a></p>
<p>While trees <em>can</em> be used for linear data, it would be excessive and inefficient to implement them for single strings. In an upcoming module, we will see how we can use trees to represent any number of strings! For example, this tree below contains 7 words: &lsquo;a&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;any&rsquo;, &lsquo;all&rsquo;, and &lsquo;alp&rsquo;.
<a href="#R-image-87fde7959b04941b0d9500d38510cc31" class="lightbox-link"><img alt="Small Words" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87fde7959b04941b0d9500d38510cc31"><img alt="Small Words" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a></p>
<p>In the next sections, we will discuss the properties of a tree data structure and how we would design one ourselves. Once we have a good understanding of trees and the properties of trees, we will implement our own.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Introduction</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="general-terms">General Terms</h1>


<a href="https://www.youtube.com/watch?v=JvbXXm_KEDY">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/2-general-terms/video/">Video Materials</a></p>
<p>To get ourselves comfortable in working with trees, we will outline some standard vocabulary. Throughout this section, we will use the following tree as a guiding example for visualizing the definitions.<br>
<a href="#R-image-39b1f76535100a24ee75f564976a1c07" class="lightbox-link"><img alt="Blank" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Blank.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39b1f76535100a24ee75f564976a1c07"><img alt="Blank" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Blank.png"></a></p>
<h2 id="definitions">Definitions</h2>
<ul>
<li><code>Node</code> - the general term for a structure which contains an item, such as a character or even another data structure.</li>
<li><code>Edge</code> - the connection between two nodes. In a tree, the edge will be pointing in a downward direction.</li>
</ul>
<p><a href="#R-image-f70d697b371b56cbd93c4a4a59f3f59f" class="lightbox-link"><img alt="Nodes and Edges" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_NodeEdge.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f70d697b371b56cbd93c4a4a59f3f59f"><img alt="Nodes and Edges" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_NodeEdge.png"></a>
This tree has five edges and six nodes. There is no limit to the number of nodes in a tree. The only stipulation is that the tree is <code>fully connected</code>. This means that there cannot be disjoint portions of the tree. We will look at examples in the next section.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A rule of thumb for discerning trees is this: if you imagine holding the tree up by the root and gravity took effect, then all edges must be pointing downward. If an edge is pointing upward, we will have a <code>cycle</code> within our structure so it will not be a tree.</p>
</div>
</div>
<hr>
<ul>
<li><code>Root</code> - the topmost node of the tree</li>
</ul>
<p><a href="#R-image-4f8a023f22cba0e5e99b14a90dbe4dda" class="lightbox-link"><img alt="Root" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Root.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4f8a023f22cba0e5e99b14a90dbe4dda"><img alt="Root" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Root.png"></a>
To be a tree, there must be exactly one root. Having multiple roots, will result in a <code>cycle</code> or a tree that is not <code>fully connected</code>. In short, a <code>cycle</code> is a loop in the tree.</p>
<hr>
<ul>
<li><code>Parent</code> - a node with an edge that connects to another node further from the root. We can also define the root of a tree with respect to this definition; <code>Root</code>: a node with no parent.</li>
<li><code>Child</code> - a node with an edge that connects to another node closer to the root.
<ul>
<li>In a general tree, the children of a node are an unordered set. There is not a fixed or defined order for generic trees.
<a href="#R-image-a9c996891c3d54cd11d367602c837c5b" class="lightbox-link"><img alt="Parent and Child" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a9c996891c3d54cd11d367602c837c5b"><img alt="Parent and Child" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild1.png"></a>
<a href="#R-image-b6f9788f948ae0fac4f078c154eb50f0" class="lightbox-link"><img alt="Parent and Child" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b6f9788f948ae0fac4f078c154eb50f0"><img alt="Parent and Child" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_ParentChild2.png"></a>
In a tree, child nodes must have exactly one parent node. If a child node has more than one parent, then a <code>cycle</code> will occur. If there is a node without a parent node, then this is necessarily the root node. There is no limit to the number of child nodes a parent node can have, but to be a parent node, the node must have at least one child node.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>Leaf</code> - a node with no children.
<a href="#R-image-99e38f4919e25ced28b090625d924977" class="lightbox-link"><img alt="Leaf" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Leaf.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-99e38f4919e25ced28b090625d924977"><img alt="Leaf" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Leaf.png"></a>
This tree has four leaves. There is no limit to how many leaves can be in a tree.</li>
</ul>
<hr>
<ul>
<li><code>Degree</code>
<ul>
<li><code>Degree of a node</code> - the number of children a node has. The degree of a leaf is zero.</li>
<li><code>Degree of a tree</code> - the number of children the root of the tree has.
<a href="#R-image-acbb6291a1c26000221f04860f622b79" class="lightbox-link"><img alt="Degree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Degree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acbb6291a1c26000221f04860f622b79"><img alt="Degree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Degree.png"></a>
The degree of the nodes are shown as the values on the nodes in this example. The degree of the tree is equal to the degree of the root. Thus, the degree for this tree is 2.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>A <code>tree</code> is defined recursively. This means that each child of the root is the root of another tree and the children of those are roots to trees as well. Again, this is a recursive definition so it will continue to the leaves. The leaves are also trees with just a single node as the root.<br>
<a href="#R-image-ff620c9f247c4d40aed18b3f7f596cda" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff620c9f247c4d40aed18b3f7f596cda"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a>
In our example tree, we have six trees. Each tree is outlined in a red dashed circle:
<ul>
<li>the main tree,
<ul>
<li>the tree off the left of the main root,
<ul>
<li>the tree off the left of this root,</li>
<li>the tree in the center of this root,</li>
<li>the tree off the right of this root, and</li>
</ul>
</li>
<li>the tree off the right of the main root with a single node</li>
</ul>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of General Terms</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="what-makes-a-tree-a-tree">What Makes a Tree a Tree</h1>


<a href="https://www.youtube.com/watch?v=zZ7vDmZEEIo">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/3-what-makes-trees/video/">Video Materials</a></p>
<p>Trees can come in many shapes and sizes. There are, however some constraints to making a valid tree.</p>
<ul>
<li>A tree has a single root</li>
<li>A child has exactly one parent</li>
<li>A tree is fully connected (IE a single tree)</li>
<li>A tree has no cycles (IE no loops)</li>
</ul>
<h2 id="valid-trees">Valid Trees</h2>
<p>Any combination of the following represents a valid tree:</p>
<ul>
<li>
<p>A tree with a single node; just a root,
<a href="#R-image-8bbbe831e86adeb0d605cb353a7e9ff4" class="lightbox-link"><img alt="Single" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Simple.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8bbbe831e86adeb0d605cb353a7e9ff4"><img alt="Single" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Simple.png"></a></p>
</li>
<li>
<p>A tree where each node has a single child, or
<a href="#R-image-12a24f514dc159d913561f758a84ee37" class="lightbox-link"><img alt="Linear" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Linear.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-12a24f514dc159d913561f758a84ee37"><img alt="Linear" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Linear.png"></a></p>
</li>
<li>
<p>A tree where nodes have many children.
<a href="#R-image-c310a935572317f0a709afd61232d11e" class="lightbox-link"><img alt="Linear" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Wide.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c310a935572317f0a709afd61232d11e"><img alt="Linear" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Wide.png"></a></p>
</li>
</ul>
<h2 id="invalid-trees">Invalid Trees</h2>
<p>Below are some examples of invalid trees.</p>
<ul>
<li>
<p>A cycle
<a href="#R-image-7acd38065f31e688b1a1fb4ca50089a6" class="lightbox-link"><img alt="Cycle" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7acd38065f31e688b1a1fb4ca50089a6"><img alt="Cycle" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle.png"></a>
Again, cycles are essentially loops that occur in our tree. In this example, we see that our leaf has two parents. One way to determine whether your data structure has a cycle is if there is more than one way to get from the root to any node.</p>
</li>
<li>
<p>A cycle
<a href="#R-image-5092dfbaf6969b2d98c4d5e9b2ff2bf0" class="lightbox-link"><img alt="Cycle" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5092dfbaf6969b2d98c4d5e9b2ff2bf0"><img alt="Cycle" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Cycle2.png"></a>
Here we can see another cycle. In this case, the node immediately after the root has two parents, which is a clue that a cycle exists. Another test</p>
</li>
<li>
<p>Two Roots
<a href="#R-image-5f59bb80af2c014c603f9cc1869fcfcc" class="lightbox-link"><img alt="Two Roots" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_TwoRoots.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f59bb80af2c014c603f9cc1869fcfcc"><img alt="Two Roots" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_TwoRoots.png"></a>
Trees must have a single root. In this instance, it may look like we have a tree with two roots. Working through this, we also see that the node in the center has two parents.</p>
</li>
<li>
<p>Two Trees
<a href="#R-image-0cedc3945cf7f380a6e66a39bffa7019" class="lightbox-link"><img alt="Double Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_DoubleTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0cedc3945cf7f380a6e66a39bffa7019"><img alt="Double Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_DoubleTree.png"></a>
This example would be considered two trees, not a tree with two parts. In this figure, we have two fully connected components. Since they are not connected to each other, this is not a single tree.</p>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of What Makes a Tree a Tree</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-i">MyTree I</h1>


<a href="https://www.youtube.com/watch?v=y02_6lWMVnQ">YouTube Video</a>

<p><a href="/cc315/ii-trees/2-introduction-trees/4-uml/video/">Video Materials</a></p>
<p>Along with understanding how trees work, we want to also be able to implement a tree of our own. We will now outline key components of a tree class.</p>
<hr>
<h3 id="mytree">MyTree</h3>
<p>Recall that trees are defined recursively so we can build them from the leaves up where each leaf is a tree itself. Each tree will have three properties: the item it contains as an object, its parent node of type MyTree, and its children as a list of MyTrees. Upon instantiation of a new MyTree, we will set the item value and initialize the parent node to None and the children to an empty list of type MyTree.
<a href="#R-image-d491d3afa941c26ebb1e80c83ce01202" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/tree_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d491d3afa941c26ebb1e80c83ce01202"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/tree_uml.png"></a></p>
<p>Suppose that we wanted to construct the following tree.
<a href="#R-image-fedd72e340c07715681bfda36a22d635" class="lightbox-link"><img alt="Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fedd72e340c07715681bfda36a22d635"><img alt="Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.png"></a>
We would start by initializing each node as a tree with no parent, no children, and the item in this instance would be the characters. Then we build it up level by level by add the appropriate children to the respective parent.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Disclaimer:</strong> This implementation will not prevent all cycles. In the next module, we will introduce steps to prevent cycles and maintain true tree structures.</p>
</div>
</div>
<hr>
<h3 id="finding-a-child">Finding a child</h3>
<p>In this method, we will take a value as input and then check if that value is the item of a child of the current node. If the value is not the item for any of the node&rsquo;s children then we should return none.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FINDCHILD(VALUE)
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        IF CHILD&#39;s ITEM is VALUE
</span></span><span class="line"><span class="cl">            return  CHILD
</span></span><span class="line"><span class="cl">    return NONE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="getting--children-item-parent-or-degree">Getting  children, item, parent, or degree</h3>
<p>Each of these will be rather straight forward; children, item, and parent are all attributes of our node, so we can have a getter function that returns the respective values. The slightly more involved task will be getting the degree. Recall that the degree of a node is equal to the number of children. Thus, we can simply count the number of children and return this number for the degree.</p>
<hr>
<h3 id="checking-node-type">Checking node type</h3>
<p>We will have two functions to check the node type: one to determine if the node is a leaf and one to determine if it is a root. The definition of a leaf is a node that has no children. Thus, to check if a node is a leaf, we can simply check if the number of children is equal to zero. Similarly, since the definition of a root is a node with no parent, we can check that the parent attribute of the node is None.</p>
<hr>
<h3 id="adding-a-child">Adding a child</h3>

<a href="https://www.youtube.com/watch?v=T5gy1Q7hx1w">YouTube Video</a>

<p>When we wish to add a child, we must fisrt make sure we are able to add the child.</p>
<ol>
<li>Check that the child is an instance of <code>MyTree</code></li>
<li>Make sure the child doesn&rsquo;t already have a parent</li>
<li>Make sure the child isn&rsquo;t already a child of the parent</li>
</ol>
<p>We will return true if the child was successfully added and false otherwise while raising the appropriate errors.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDCHILD(CHILD)
</span></span><span class="line"><span class="cl">    IF CHILD has PARENT
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    IF CHILD is CHILD of PARENT
</span></span><span class="line"><span class="cl">        return FALSE
</span></span><span class="line"><span class="cl">    ELSE
</span></span><span class="line"><span class="cl">        append CHILD to PARENT&#39;s children
</span></span><span class="line"><span class="cl">        set CHILD&#39;s parent to PARENT
</span></span><span class="line"><span class="cl">        return TRUE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As an example, lets walk through the process of building the tree above:</p>
<ol>
<li>Instantiate MyTree <code>a</code> with item &lsquo;A&rsquo;</li>
<li>Instantiate MyTree <code>b</code> with item &lsquo;B&rsquo;</li>
<li>Instantiate MyTree <code>c</code> with item &lsquo;C&rsquo;</li>
<li>Instantiate MyTree <code>d</code> with item &lsquo;D&rsquo;</li>
<li>Instantiate MyTree <code>e</code> with item &lsquo;E&rsquo;</li>
<li>Instantiate MyTree <code>f</code> with item &lsquo;F&rsquo;</li>
<li>Instantiate MyTree <code>g</code> with item &lsquo;G&rsquo;</li>
<li>Instantiate MyTree <code>h</code> with item &lsquo;H&rsquo;</li>
<li>Instantiate MyTree <code>i</code> with item &lsquo;I&rsquo;</li>
<li>Add child tree <code>g</code> to tree <code>d</code></li>
<li>Add child tree <code>h</code> to tree <code>d</code></li>
<li>Add child tree <code>i</code> to tree <code>d</code></li>
<li>Add child tree <code>e</code> to tree <code>b</code></li>
<li>Add child tree <code>f</code> to tree <code>b</code></li>
</ol>
<p>Once we have completed that, visually, we would have the tree above and in code we would have:</p>
<ul>
<li>MyTree <code>a</code> with parent_node = None, item = &lsquo;A&rsquo;, children = {<code>b</code>,<code>c</code>,<code>d</code>}</li>
<li>MyTree <code>b</code> with parent_node = <code>a</code>, item = &lsquo;B&rsquo;, children = {<code>e</code>,<code>f</code>}</li>
<li>MyTree <code>c</code> with parent_node = <code>a</code>, item = &lsquo;C&rsquo;, children = { }</li>
<li>MyTree <code>d</code> with parent_node = <code>a</code>, item = &lsquo;D&rsquo;, children = {<code>g</code>,<code>h</code>,<code>i</code>}</li>
<li>MyTree <code>e</code> with parent_node = <code>b</code>, item = &lsquo;E&rsquo;, children = { }</li>
<li>MyTree <code>f</code> with parent_node = <code>b</code>, item = &lsquo;F&rsquo;, children = { }</li>
<li>MyTree <code>g</code> with parent_node = <code>d</code>, item = &lsquo;G&rsquo;, children = { }</li>
<li>MyTree <code>h</code> with parent_node = <code>d</code>, item = &lsquo;H&rsquo;, children = { }</li>
<li>MyTree <code>i</code> with parent_node = <code>d</code>, item = &lsquo;I&rsquo;, children = { }</li>
</ul>
<p><strong>Note:</strong> When adding a child we must currently be at the node we want to be the parent. Much like when you want to add a file to a folder, you must specify exactly where you want it. If you don&rsquo;t, this could result in a wayward child.</p>
<hr>
<h3 id="removing-a-child">Removing a child</h3>

<a href="https://www.youtube.com/watch?v=QtfZIUMPrJY">YouTube Video</a>

<p>In the case of removing a child, we first need to check that the child we are attempting to remove is an instance of <code>MyTree</code>. We will return true if we successfully remove the child and false otherwise.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVECHILD(CHILD)
</span></span><span class="line"><span class="cl">    IF CHILD in PARENT&#39;S children
</span></span><span class="line"><span class="cl">        REMOVE CHILD from PARENT&#39;s children
</span></span><span class="line"><span class="cl">        SET CHILD&#39;s PARENT to NONE
</span></span><span class="line"><span class="cl">        return TRUE
</span></span><span class="line"><span class="cl">    ELSE
</span></span><span class="line"><span class="cl">        return FALSE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As with adding a child, we need to ensure that we are in the &lsquo;right place&rsquo; when attempting to remove a child. When removing a child, we are not &rsquo;erasing&rsquo; it, we are just cutting the tie from parent to child and child to parent. Consider removing <code>d</code> from <code>a</code>. Visually, we would have two disjoint trees, shown below:
<a href="#R-image-0ce31eb319ac049c958fde6c7946a7ca" class="lightbox-link"><img alt="Tree 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ce31eb319ac049c958fde6c7946a7ca"><img alt="Tree 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation2.png"></a></p>
<p>In code, we would have:</p>
<ul>
<li>MyTree <code>a</code> with parent_node = None, item = &lsquo;A&rsquo;, children = {<code>b</code>,<code>c</code>}</li>
<li>MyTree <code>b</code> with parent_node = <code>a</code>, item = &lsquo;B&rsquo;, children = {<code>e</code>,<code>f</code>}</li>
<li>MyTree <code>c</code> with parent_node = <code>a</code>, item = &lsquo;C&rsquo;, children = { }</li>
<li>MyTree <code>d</code> with parent_node = None, item = &lsquo;D&rsquo;, children = {<code>g</code>,<code>h</code>,<code>i</code>}</li>
<li>MyTree <code>e</code> with parent_node = <code>b</code>, item = &lsquo;E&rsquo;, children = { }</li>
<li>MyTree <code>f</code> with parent_node = <code>b</code>, item = &lsquo;F&rsquo;, children = { }</li>
<li>MyTree <code>g</code> with parent_node = <code>d</code>, item = &lsquo;G&rsquo;, children = { }</li>
<li>MyTree <code>h</code> with parent_node = <code>d</code>, item = &lsquo;H&rsquo;, children = { }</li>
<li>MyTree <code>i</code> with parent_node = <code>d</code>, item = &lsquo;I&rsquo;, children = { }</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of MyTree I</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this module we have introduce vocabulary related to trees and what makes a tree a tree. To recap, we have introduced the following:</p>
<ul>
<li><code>Child</code> - a node with an edge that connects to another node closer to the root.</li>
<li><code>Degree</code>
<ul>
<li><code>Degree of a node</code> - the number of children a node has. The degree of a leaf is zero.</li>
<li><code>Degree of a tree</code> - the number of children the root of the tree has.</li>
</ul>
</li>
<li><code>Edge</code> - connection between two nodes. In a tree, the edge will be pointing in a downward direction.</li>
<li><code>Leaf</code> - a node with no children.</li>
<li><code>Node</code> - the general term for a structure which contains an item, such as a character or even another data structure.</li>
<li><code>Parent</code> - a node with an edge that connects to another node further from the root. We can also define the root of a tree with respect to this definition;</li>
<li><code>Root</code> - the topmost node of the tree; a node with no parent.</li>
</ul>
<p>Now we will work on creating our own implementation of a tree. These definitions will serve as a resource to us when we need refreshing on meanings; feel free to refer back to them as needed.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 15</div>

<h1 id="tree-traversal">Tree Traversal</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Tree Traversal</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Tree Traversal</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>

<p>In the last module, we covered the underlying vocabulary of trees and how we can implement our own tree. To recall, we covered: node, edge, root, leaf, parent, child, and degree.</p>
<p>For this module we will expand on trees and gain a better understanding of how powerful trees can be. As before, we will use the same tree throughout the module for a guiding visual example.</p>
<p><a href="#R-image-7f7731fde8ed320b0f1e968541abe01a" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f7731fde8ed320b0f1e968541abe01a"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-i">Terms I</h1>


<a href="https://www.youtube.com/watch?v=uSagfd4L2D8">YouTube Video</a>

<p>Many of the terms used in trees relate to terms used in family trees. Having this in mind can help us to better understand some of the terminology involved with abstract trees. Here we have a sample family tree.
<a href="#R-image-febd9f56c4ed5f96f0a59aa36fe0dd3b" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-febd9f56c4ed5f96f0a59aa36fe0dd3b"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>
<ul>
<li><code>Ancestor</code> - The ancestors of a node are those reached from child to parent relationships. We can think of this as our parents and our parent&rsquo;s parents, and so on.
<ul>
<li>Let&rsquo;s look at all of the ancestors of each of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s ancestors: <u>Uzzi, Joe, Myra</u>. This is because, <strong>Uzzi</strong> is the parent of Ava, <strong>Joe</strong> is the parent of Uzzi, and <strong>Myra</strong> is the parent of Joe. Try to work out the following and click the name to reveal the ancestors.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>Zia, Myra</u> - **Zia** is the parent of Uma and **Myra** is the parent of Zia. </details>
  <details><summary markdown="span">Myra:</summary><u>None</u> - Myra does not have a parent node.</details>
  <details><summary markdown="span">Raju:</summary> <u>Myra</u> - **Myra** is the parent of Raju.</details>
  <details><summary markdown="span">Bev:</summary> <u>Uzzi, Joe, Myra</u> - **Uzzi** is the parent of Bev, **Joe** is the parent of Uzzi, and **Myra** is the parent of Joe.</details>
</li>
</ul>
</li>
<li><code>Descendant</code> - The descendants of a node are those reached from parent to child relationships. We can think of this as our children and our children&rsquo;s children and so on.
<ul>
<li>Let&rsquo;s look at all of the descendants of each of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s descendants: <u>None</u>. Ava has no child nodes and thus, no descendants. Try to work out the following and click the name to reveal the descendants.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>Ang</u> - **Ang** is the child of Uma</details>
  <details><summary markdown="span">Myra:</summary><u>Raju, Joe, Zia, Uzzi, Bert, Uma, Bev, Ava, Ang, Isla, Eoin</u> - All of the nodes in a tree will be descendants of the root. To work it out: **Raju, Joe** and **Zia** are the children of Myra, **Uma** is the child of Zia, **Ang** is the child of Uma, and we can work the rest out for Joe's children. </details>
  <details><summary markdown="span">Raju:</summary><u>None</u> - Raju has no child nodes.</details>
  <details><summary markdown="span">Bev:</summary><u>Isla, Eoin</u> - **Isla** is the child of Bev and **Eoin** is the child of Isla.</details>
</li>
</ul>
</li>
<li><code>Siblings</code> - Nodes which share the same parent
<ul>
<li>We can think about the siblings of all of our nodes in the family tree.
<ul>
<li>Ava&rsquo;s siblings: <u>Bev</u> - Uzzi is the parent node of Ava; Uzzi has two child nodes, Ava and <strong>Bev</strong>. Try to work out the following and click the name to reveal the siblings.</li>
</ul>
  <details><summary markdown="span">Uma:</summary><u>None</u> - Zia is the parent node of Uma; Zia has only one child node, Uma.</details>
  <details><summary markdown="span">Myra:</summary><u>None</u> - Myra is the root and thus does not have a parent node resulting in no siblings.</details>
  <details><summary markdown="span">Raju:</summary><u>Joe, Zia</u> -  Myra is the parent node of Raju; Myra has three child nodes, **Joe**, **Zia**, and Raju</details>
  <details><summary markdown="span">Bev:</summary><u>Ava</u> - Uzzi is the parent node of Bev; Uzzi has two child nodes, Bev and **Ava**.</details>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursion-refresh">Recursion Refresh</h1>


<a href="https://www.youtube.com/watch?v=7ee0C0v2L1w">YouTube Video</a>

<p><a href="#R-image-04e296bb907aecede5905d29b32ea2dc" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04e296bb907aecede5905d29b32ea2dc"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<p>In principle, the recursive case breaks the problem down into smaller portions until we reach the base case. Recursion presents itself in many ways when dealing with trees.</p>
<p>Trees are defined recursively with the base case being a single node. Then we recursively build the tree up. With this basis for our trees, we can define many properties using recursion rather effectively.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-ii">Terms II</h1>


<a href="https://www.youtube.com/watch?v=86uWWXaanCo">YouTube Video</a>

<p>We can describe the sizes of trees and position of nodes using different terminology, like level, depth, and height.</p>
<p><a href="#R-image-f96b44317340952d0a13df9c54f93de3" class="lightbox-link"><img alt="Family Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f96b44317340952d0a13df9c54f93de3"><img alt="Family Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_FamilyTree.png"></a></p>
<ul>
<li><code>Level</code> - The level of a node characterizes the distance between the node and the root. The root of the tree is considered level 1. As you move away from the tree, the level increases by one.
<ul>
<li>For our family tree example, what nodes are in the following levels? Think about the answer and then click corresponding arrow.
  <details><summary markdown="span">Level 1:</summary><u>Myra</u> - Level 1 is always the root</details>
  <details><summary markdown="span">Level 2:</summary><u>Raju, Joe, Zia</u> - These are the nodes which are 1 edge away from the root.</details>
  <details><summary markdown="span">Level 3:</summary><u>Uzzi, Bert, Uma</u> - These are the nodes which are 2 edges away from the root. </details>
  <details><summary markdown="span">Level 4:</summary><u>Bev, Ava, Ang</u> - These are the nodes which are 3 edges away from the root. </details>
  <details><summary markdown="span">Level 5:</summary><u>Isla</u> - This is the only node which is 4 edges away from the root. </details>
  <details><summary markdown="span">Level 6:</summary><u>Eoin</u> - This is the only node which is 5 edges away from the root. </details>
</li>
</ul>
</li>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero. <code>Level</code> and <code>depth</code> are related in that: <code>level = 1 + depth</code>.
<ul>
<li>For our family tree example, what nodes have the following depths?
  <details><summary markdown="span">Depth 0:</summary><u>Myra</u> - The root will always be at depth 0.</details>
  <details><summary markdown="span">Depth 1:</summary><u>Raju, Joe, Zia</u> - These are the nodes which are 1 edge away from the root.</details>
  <details><summary markdown="span">Depth 2:</summary><u>Uzzi, Bert, Uma</u> - These are the nodes which are 2 edge away from the root.</details>
  <details><summary markdown="span">Depth 3:</summary><u>Bev, Ava, Ang</u> - These are the nodes which are 3 edge away from the root.</details>
  <details><summary markdown="span">Depth 4:</summary><u>Isla</u> - This is the only node which is 4 edges away from the root.</details>
  <details><summary markdown="span">Depth 5:</summary><u>Eoin</u> - This is the only node which is 5 edges away from the root.</details>
</li>
</ul>
</li>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.
<ul>
<li>For our family tree example, what nodes have the following heights?
  <details><summary markdown="span">Height 0:</summary><u>Raju, Eoin, Ava, Bert, Ang</u> - The leaves always have height 0. </details>
  <details><summary markdown="span">Height 1:</summary><u>Isla, Uma</u> - `Isla -> Eoin`  and `Uma -> Ang` </details>
  <details><summary markdown="span">Height 2:</summary><u>Bev, Zia</u> - `Bev -> Isla -> Eoin` and `Zia -> Uma -> Ang` </details>
  <details><summary markdown="span">Height 3:</summary><u>Uzzi</u> - `Uzzi -> Bev -> Isla -> Eoin`</details>
  <details><summary markdown="span">Height 4:</summary><u>Joe</u> - `Joe -> Uzzi -> Bev -> Isla -> Eoin`</details>
  <details><summary markdown="span">Height 5:</summary><u>Myra</u> - `Myra -> Joe -> Uzzi -> Bev -> Isla -> Eoin`</details>
</li>
</ul>
</li>
<li><code>Height of a Tree</code> - The height of a tree is equal to the height of the root.
<ul>
<li>Our family tree would have height 5</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-iii">Terms III</h1>


<a href="https://www.youtube.com/watch?v=Jurg4tZKCwI">YouTube Video</a>

<p>When working with multidimensional data structures, we also need to consider how they would be stored in a linear manner. Remember, pieces of data in computers are linear sequences of binary digits. As a result, we need a standard way of storing trees as a linear structure.</p>
<p><a href="#R-image-9bbc9fa07c0e8d5adff6c7222fb9470f" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bbc9fa07c0e8d5adff6c7222fb9470f"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png"></a></p>
<ul>
<li>
<p><code>Path</code> - a path is a sequence of nodes and edges, which connect a node with its descendant. We can look at some paths in the tree above:</p>
<ul>
<li>From <code>Q</code> to <code>O</code>: <code>QRO</code></li>
</ul>
  <details><summary markdown="span">From `Q` to `Y`:</summary>`QWY`</details>
  <details><summary markdown="span">From `R` to `P`:</summary>`RP`</details>
</li>
<li>
<p><code>Traversal</code> is a general term we use to describe going through a tree. The following traversals are defined recursively.</p>
</li>
</ul>
<h2 id="preorder-traversal">Preorder Traversal</h2>
<ol>
<li>Access the root, record its value.</li>
<li>Run the preorder traversal each of the children</li>
</ol>

<a href="https://www.youtube.com/watch?v=JthdRshLJP0">YouTube Video</a>

<ul>
<li>The <code>Pre</code> refers to the root, meaning the root goes before the children.</li>
<li>Remember: Root Children</li>
<li>For the above tree, the preorder traversal could result in: <code>QWYUERIOPTA</code>
<a href="#R-image-d10cc6aca9e90f246a271328056c99de" class="lightbox-link"><img alt="Preorder Traversal" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Preorder.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d10cc6aca9e90f246a271328056c99de"><img alt="Preorder Traversal" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Preorder.gif"></a></li>
</ul>
<h2 id="postorder-traversal">Postorder Traversal</h2>
<ol>
<li>Run the postorder traversal on each of the children</li>
<li>Access the root, record its value</li>
</ol>

<a href="https://www.youtube.com/watch?v=eEZmsK-loUU">YouTube Video</a>

<ul>
<li>The <code>Post</code> refers to the root, meaning the root goes after the children.</li>
<li>Remember: Children Root</li>
<li>For the above tree, the postorder traversal could result in: <code>YUWEIOPRATQ</code>
<a href="#R-image-6449c7232da04e5552a152a3ca116b3e" class="lightbox-link"><img alt="Postorder Traversal" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Postorder.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6449c7232da04e5552a152a3ca116b3e"><img alt="Postorder Traversal" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Postorder.gif"></a></li>
</ul>
<hr>
<p>When we talk about traversals for general trees we have used the phrase &rsquo;the traversal <em>could</em> result in&rsquo;. We would like to expand on why &lsquo;could&rsquo; is used here. Each of these general trees are the same but their traversals could be different. The key concept in this is that for a general tree, the children are an unordered set of nodes; they do not have a defined or fixed order. The relationships that are fixed are the parent/child relationships.
<a href="#R-image-17ba51bea2422ff831cef49ef5a9676c" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17ba51bea2422ff831cef49ef5a9676c"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal.png"></a>
<a href="#R-image-a37c761c29bd0d2436b6e4ceea502759" class="lightbox-link"><img alt="Traversal Tree1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a37c761c29bd0d2436b6e4ceea502759"><img alt="Traversal Tree1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal1.png"></a>
<a href="#R-image-2b76ad5015095107981ba22723106ce4" class="lightbox-link"><img alt="Traversal Tree2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b76ad5015095107981ba22723106ce4"><img alt="Traversal Tree2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/3Tree_Traversal2.png"></a></p>
<table>
<thead>
<tr>
<th>Tree</th>
<th>Preorder</th>
<th>Postorder</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tree 1</td>
<td><code>QWYUERIOPTA</code></td>
<td><code>YUWEIOPRATQ</code></td>
</tr>
<tr>
<td>Tree 2</td>
<td><code>QETARIOPWUY</code></td>
<td><code>EATIOPRUYWQ</code></td>
</tr>
<tr>
<td>Tree 3</td>
<td><code>QROPITAEWUY</code></td>
<td><code>OPIRATEUYWQ</code></td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-i">MyTree Recursive I</h1>

<p>Again, we want to be able to implement a working version of a tree. From the last module, we had functions to add children, remove children, get attributes, and instantiate MyTree. We will now build upon that implementation to create a true tree.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<hr>
<h3 id="mytree-with-recursion">MyTree with recursion</h3>
<p>Recall that in the previous module, we were not yet able to enforce the no cycle rule. We will now enforce this and add other tree functionality.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Disclaimer:</strong> In the previous module we had a disclaimer that stated our implementation would not prevent cycles. The following functions and properties will implement recursion. Thus, we can maintain legal tree structures!</p>
</div>
</div>
<p>In the first module, we discussed how we can define trees recursively, meaning a tree consists of trees. We looked at the following example. Each red dashed line represented a distinct tree, thus we had five trees within the largest tree making six trees in total.
<a href="#R-image-7f017b0c0b6d92ad46b3dca0bb311b42" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f017b0c0b6d92ad46b3dca0bb311b42"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SubTree.png"></a></p>
<p>We will use our existing implementation from the first module. Now to make our tree recursive, we will include more getter functions as well as functions for traversals and defining node relationships.</p>
<p><a href="#R-image-c7f5b04934654c2f691f2f4f57c3ad0e" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/3/rec_tree_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7f5b04934654c2f691f2f4f57c3ad0e"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/3/rec_tree_uml.png"></a></p>
<hr>
<h3 id="get-depth-height-size-and-root">Get depth, height, size, and root</h3>
<p>We can define each of these recursively.</p>

<a href="https://www.youtube.com/watch?v=3mFKHgv6bhk">YouTube Video</a>

<h5 id="get-depth">Get Depth</h5>
<ul>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero.</li>
</ul>
<p>We can define the depth of a node recursively:</p>
<ul>
<li>Base case: we are at the root and the depth is zero</li>
<li>Recursive case: for any other node, the depth is 1 plus the depth of the parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETDEPTH()
</span></span><span class="line"><span class="cl">    if ROOT
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return 1 + PARENT.GETDEPTH()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-height">Get Height</h5>
<ul>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.</li>
</ul>
<p>We can define the height of a node recursively:</p>
<ul>
<li>Base case: we are at the leaf and the height is zero</li>
<li>Recursive case: for any other node, return 1 plus the maximum height of its children</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETHEIGHT()
</span></span><span class="line"><span class="cl">    if LEAF
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        MAX = 0
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            CURR<span class="nb">_</span>HEIGHT = CHILD.GETHEIGHT()
</span></span><span class="line"><span class="cl">            if CURR<span class="nb">_</span>HEIGHT &gt; MAX
</span></span><span class="line"><span class="cl">                MAX = CURR<span class="nb">_</span>HEIGHT
</span></span><span class="line"><span class="cl">        return 1 + MAX
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-root">Get Root</h5>
<ul>
<li><code>Root</code> - the topmost node of the tree; a node with no parent.</li>
</ul>
<p>We can define returning the root recursively:</p>
<ul>
<li>Base case: we are at the root so return it</li>
<li>Recursive case: for any other node, return the root of the nodes parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETROOT()
</span></span><span class="line"><span class="cl">    if ISROOT()
</span></span><span class="line"><span class="cl">        return this tree
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.GETROOT()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-size">Get Size</h5>
<p>We define the size of a tree as the total number of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETSIZE()
</span></span><span class="line"><span class="cl">    SIZE = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        SIZE += CHILD.GETSIZE()
</span></span><span class="line"><span class="cl">    return SIZE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="find-a-value">Find a Value</h4>
<p>To find a value within our tree, we will traverse down a branch as far as we can until we find the value. This will return the tree that has the value as the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FIND(VALUE)
</span></span><span class="line"><span class="cl">	if ITEM is VALUE
</span></span><span class="line"><span class="cl">		return this node
</span></span><span class="line"><span class="cl">	for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">		FOUND = CHILD.FIND(VALUE)
</span></span><span class="line"><span class="cl">		if FOUND is not NONE
</span></span><span class="line"><span class="cl">			return FOUND
</span></span><span class="line"><span class="cl">	return NONE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-ii">MyTree Recursive II</h1>

<h3 id="determine-relationships-ancestor-descendant-sibling">Determine relationships (Ancestor, Descendant, Sibling)</h3>
<p>We can determine many relationships within the tree. For example, given a node is it an ancestor of another node, a descendant, or a sibling?</p>

<a href="https://www.youtube.com/watch?v=hr73fsl8RzM">YouTube Video</a>

<h5 id="is-ancestor">Is Ancestor?</h5>
<p>For this function, we are asking: is this node an ancestor of the current instance? In this implementation, we will start at our instance and <strong>work down</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at a leaf so return false.</li>
<li>Recursive case: run the method from each of the children of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at LEAF
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            FOUND = CHILD.ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">            if FOUND
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-descendant">Is Descendant?</h5>
<p>For this function, we are asking: is this node a descendant of the current instance? In this implementation, we will start at our instance and <strong>work up</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at the root so return false.</li>
<li>Recursive case: run the method from the parent of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return PARENT.ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-sibling">Is Sibling?</h5>
<p>For this function, we are asking: is this node a sibling of the current instance? To determine this, we can get the parent of the current instance and then get the parents children. Finally, we check if the node in question is in that set of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISSIBLING(TREE)
</span></span><span class="line"><span class="cl">    if TREE in PARENT&#39;s CHILDREN
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="lowest-common-ancestor">Lowest common ancestor</h3>
<p>In any tree, we can say that the root is a common ancestor to all of the nodes. We would like to get more information about the common ancestry of two nodes. For this function, we are asking: which node is the first place where this instance and the input node&rsquo;s ancestries meet? Similar to our ISDESCENDANT, we will work our way up the tree to find the point where they meet</p>
<ul>
<li>Base case: we are at our tree so return the tree OR we are at an ancestor of our tree so return the instance OR we are at the root so return nothing</li>
<li>Recursive case: run the method from the parent.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return TREE
</span></span><span class="line"><span class="cl">    else if ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">        return instance
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return NONE
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="path-from-the-root">Path from the root</h3>
<p>This function will generate the path which goes from the root to the current instance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    if NOT ROOT
</span></span><span class="line"><span class="cl">        PARENT.PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    append ITEM to PATH
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-iii">MyTree Recursive III</h1>

<h3 id="traversals">Traversals</h3>
<p>In this module we have talked about two traversals: preorder and postorder. Both of these are defined recursively and the prefix refers to the order of the root.</p>
<h5 id="preorder">Preorder</h5>
<p>In a preorder traversal, first we access the root and then run the preorder traversal on the children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PREORDER(RESULT)
</span></span><span class="line"><span class="cl">    append ITEM to RESULT
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.PREORDER(RESULT)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="postorder">Postorder</h5>
<p>In a postorder traversal, first we run the postorder traversal on the children then we access the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   append ITEM to RESULT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this section, we discussed more terminology related to trees as well as tree traversals. To recap the new vocabulary:</p>
<ul>
<li><code>Ancestor</code> - The ancestors of a node are those reached from child to parent relationships. We can think of this as our parents and the parents of our parents, and so on.</li>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero. <code>Level</code> and <code>depth</code> are related in that: <code>level = 1 + depth</code>.</li>
<li><code>Descendant</code> - The descendants of a node are those reached from parent to child relationships. We can think of this as our children and our children&rsquo;s children and so on.</li>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.</li>
<li><code>Height of a Tree</code> - The height of a tree is equal to the height of the root.</li>
<li><code>Level</code> - The level of a node characterizes the distance the node is from the root. The root of the tree is considered level 1. As you move away from the tree, the level increases by one.</li>
<li><code>Path</code> - a sequence of nodes and edges which connect a node with its descendant.</li>
<li><code>Siblings</code> - Nodes which share the same parent</li>
<li><code>Traversal</code> is a general term we use to describe going through a tree. The following traversals are defined recursively.
<ul>
<li>Preorder Traversal (Remember: Root Children):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the children</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Children Root):
<ol>
<li>Run the postorder traversal on the children</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 20</div>

<h1 id="tries">Tries</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Tries</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Tries</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tries">Tries</h1>


<a href="https://www.youtube.com/watch?v=BNA3tbURiZk">YouTube Video</a>

<p>Recall that in the beginning of our discussions about trees, we looked at a small tree which contained seven strings as motivation for trees. This was a small example of a trie (pronounced &rsquo;try&rsquo;) which is a type of tree that can represent sets of words.
<a href="#R-image-9c67db900d77ef7545a210124e0ffab9" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9c67db900d77ef7545a210124e0ffab9"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a></p>
<p>Tries can be used for a variety of tasks ranging from leisurely games to accessibility applications. One example is &lsquo;Boggle&rsquo; where players have a set of random letters and try to make as many words as possible. To code this game, we could create a vocabulary with a trie then traverse it to determine if players have played legal words. We can also use tries to provide better typing accessibility. Users could type a few letters of a word and our code could traverse the trie and suggest what letters or words they may be trying to enter.</p>
<p>A trie is a type of tree with some special characteristics. First it must follow the guidelines of being a tree:</p>
<ul>
<li>There must be a single root,</li>
<li>Each child node has a single parent node,</li>
<li>It must be fully connected (no disjoint parts), and</li>
<li>There can be no cycles (no loops).</li>
</ul>
<p>The special characteristics for tries are:</p>
<ul>
<li>By starting at the root and traversing parent to children relationships we can build user-defined words, and</li>
<li>Each node has a boolean property to indicate if it is the end of a word.</li>
</ul>
<p>In this course, we will display nodes with two circles as a convention to show which nodes are the end of words. Looking at this small trie as an example, we can determine which words are contained in our trie.
<a href="#R-image-7ea7ca22ed24175c761bac67189dbf8a" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ea7ca22ed24175c761bac67189dbf8a"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_SmallWords.png"></a>
We start at the root, which will typically be an empty string, and traverse to a double lined node. <code>&quot;&quot; -&gt; a -&gt; l -&gt; l</code>. Thus, the word &lsquo;all&rsquo; is contained in our trie. Words within our tries do not have to end at leaves. For example, we can traverse <code>&quot;&quot; -&gt; a</code> for the word &lsquo;a&rsquo;. We say this trie &lsquo;contains&rsquo; seven words: &lsquo;a&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;any&rsquo;, &lsquo;all&rsquo;, and &lsquo;alp&rsquo;.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="trie-example">Trie Example</h1>

<p>Let&rsquo;s look at another example of a trie. Here we have a larger trie. Think about how many words are captured by the tree; click the tree to see how many!</p>
<details><summary markdown="span">![Trie Example](images/4/4Trie_Example.png)</summary> This tree contains **12** words: 'ate', 'an', 'and', 'ant', 'app', 'apple', 'cat', 'can', 'cup', 'by', 'be', and 'been'. </details>
<p>While the &lsquo;a&rsquo;, &lsquo;at&rsquo;, and &lsquo;bee&rsquo; are words in the English language, they are not recognized by our trie. Depending on what the user intended, this could be by design. When we build our tries, users will input words that are valid for their vocabulary. Tries are not limited to the English language and can be created for any vocabulary.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-i">MyTrie I</h1>

<p>To implement our own trie, we will build off of MyTree that we built recursively. We will add an attribute to our tree to reinforce which nodes are words and which ones are not.</p>
<p><a href="#R-image-53ec4f036b50aad3722e780e0aaa159c" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/trie_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53ec4f036b50aad3722e780e0aaa159c"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/trie_uml.png"></a></p>
<h3 id="attributes">Attributes</h3>
<p>We have the existing attributes of MyTree: parent, children, and item. For MyTrie, we introduce the boolean attribute <code>is_word</code> to delineate if our trie is a word.</p>
<h3 id="adding-a-word">Adding a Word</h3>

<a href="https://www.youtube.com/watch?v=kasaXiMbj9A">YouTube Video</a>

<p>To add a word to our trie, we traverse through the trie letter by letter. We can define this recursively.</p>
<ul>
<li>Base Case: length of the word is zero and it was already a word in our trie, return false (because we did not add the word) OR length of the word is zero and it is not already a word in our trie, set the boolean for the node at the end of the word to true and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string; if it does not exist create it, then run the add word function on the remainder of the string.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to true
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            NODE = new MyTrie with item equal FIRST
</span></span><span class="line"><span class="cl">            insert NODE into our existing trie 
</span></span><span class="line"><span class="cl">            CHILD = NODE
</span></span><span class="line"><span class="cl">        return CHILD.ADDWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="removing-a-word">Removing a Word</h3>

<a href="https://www.youtube.com/watch?v=ZcrqD8nlLjc">YouTube Video</a>

<p>Similar to adding a word, we traverse our trie letter by letter. Once we get to the end of the word set <code>is_word</code> to false. If the word ends at a leaf, we will remove the leaf (then if the second to last character is a leaf, we remove the leaf and so on). If the word does not end in a leaf, meaning another word uses that node, we will not remove the node.</p>
<ul>
<li>Base Case: length of the word is zero and it was not a word in our trie, return false (because we did not remove the word) OR length of the word is zero and it is  already a word in our trie, set the boolean for the node at the end of the word to false and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string, if that node does not exist, return false (because we did not remove the word). If the node does exist run remove word on the child for the remainder of the word. After that, if the node&rsquo;s <code>is_word</code> is false and it is a leaf, remove the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already not a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to false
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RET = CHILD.REMOVEWORD(REMAIN)
</span></span><span class="line"><span class="cl">            if CHILD is not a word AND CHILD is a leaf
</span></span><span class="line"><span class="cl">                REMOVECHILD(CHILD)
</span></span><span class="line"><span class="cl">            return RET
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="check-if-trie-contains-word">Check if trie contains word</h3>

<a href="https://www.youtube.com/watch?v=zG1aSR1iivI">YouTube Video</a>

<p>Again, we will traverse the trie letter by letter. Once we get to the last letter, we can return that nodes <code>is_word</code> attribute. There is a chance that somewhere in our word, the letter is not a child of the previous node. If that is the case, then we return false.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function CONTAINSWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        return `is<span class="nb">_</span>word`
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return CHILD.CONTAINSWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-ii">MyTrie II</h1>

<h3 id="getters">Getters</h3>

<a href="https://www.youtube.com/watch?v=su-hJ1CDY3M">YouTube Video</a>

<h4 id="getting-word-count">Getting word count</h4>
<p>For this function, we want to get the total number of words that are contained within our trie. We will fan out through all of the children and count all of the nodes that have their <code>is_word</code> attribute equal to true.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function WORDCOUNT()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        COUNT = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        COUNT += CHILD.WORDCOUNT()
</span></span><span class="line"><span class="cl">    return COUNT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-max-word-length">Get max word length</h4>
<p>Next, we want to get the longest word contained in our trie. To do this, we will recurse each child and find the maximum length of the child.</p>
<ul>
<li>Base Case: we are at a leaf and it is a word, return 0</li>
<li>Recursive Case: declare a maximum of -1 for a tracker and then for each child run the maximum word length function on it. If the value returned from the child is greater than our maximum tracker, set the tracker equal to the value. Once we have iterated all of the children, return the maximum tracker plus one.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function MAXWORD()
</span></span><span class="line"><span class="cl">    if LEAF and is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        MAX = -1
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            COUNT = CHILD.MAXWORD()
</span></span><span class="line"><span class="cl">            if COUNT greater than MAX
</span></span><span class="line"><span class="cl">                MAX = COUNT
</span></span><span class="line"><span class="cl">        return MAX + 1
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-completions">Get completions</h4>

<a href="https://www.youtube.com/watch?v=urFTpJwqRVY">YouTube Video</a>

<p>This function will act as an auto-complete utility of sorts. A user will input a string of characters and we will return all of the possible words that are contained in our trie. This will happen in two phases. First, we traverse the trie to get to the end of the input string (lines 1-12). The second portion then gets all of the words that are contained after that point in our trie (lines 14-21).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function COMPLETIONS(WORD)
</span></span><span class="line"><span class="cl">1.    if WORD length greater than 0
</span></span><span class="line"><span class="cl">2.        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">3.        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">4.        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">5.        if CHILD is none
</span></span><span class="line"><span class="cl">6.            return []
</span></span><span class="line"><span class="cl">7.        else
</span></span><span class="line"><span class="cl">8.            COMPLETES = CHILD.COMPLETIONS(REMAIN)
</span></span><span class="line"><span class="cl">9.            OUTPUT = []
</span></span><span class="line"><span class="cl">10.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">11.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">12.            return OUTPUT
</span></span><span class="line"><span class="cl">13.    else
</span></span><span class="line"><span class="cl">14.        OUTPUT = []
</span></span><span class="line"><span class="cl">15.        if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">16.            append ITEM to OUTPUT
</span></span><span class="line"><span class="cl">17.        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">18.            COMPLETES = CHILD.COMPLETIONS(&#34;&#34;)
</span></span><span class="line"><span class="cl">19.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">20.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">21.        reutrn OUTPUT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 25</div>

<h1 id="binary-trees">Binary Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Binary Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Binary Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-tree">Binary Tree</h1>


<a href="https://www.youtube.com/watch?v=FugxsgsFu9I">YouTube Video</a>

<p><a href="#R-image-00bcf2df3e2652d3adaf57cf7ee8977b" class="lightbox-link"><img alt="Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Tree_Binary.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-00bcf2df3e2652d3adaf57cf7ee8977b"><img alt="Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Tree_Binary.png"></a></p>
<p>A binary tree is a type of tree with some special conditions. First, it must follow the guidelines of being a tree:</p>
<ul>
<li>There must be single root,</li>
<li>each child node must have a single parent node,</li>
<li>it must be fully connected (no disjoint parts), and</li>
<li>there can be no cycles (no loops).</li>
</ul>
<p>The special conditions that we impose on binary trees are the following:</p>
<ul>
<li>Each node has at most 2 children (nodes can have 0, 1, or 2 children), and</li>
<li>unlike general trees, the children in a binary tree are not an unordered set. The children must be ordered such that:
<ul>
<li>all of the descendants in the left tree are less than the parent&rsquo;s value, and</li>
<li>all of the descendants in the right tree are greater than the parent&rsquo;s value</li>
</ul>
</li>
</ul>
<p>To reinforce these concepts, we will look at examples of binary trees and examples that are not binary trees.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-tree-examples">Binary Tree Examples</h1>


<a href="https://www.youtube.com/watch?v=8uSNprLBCpE">YouTube Video</a>

<hr>
<h3 id="valid-binary-trees">Valid Binary Trees</h3>
<p><a href="#R-image-bf6fdf5fba3a26e2e8f21bb02fb720c4" class="lightbox-link"><img alt="Single Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Single.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf6fdf5fba3a26e2e8f21bb02fb720c4"><img alt="Single Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Single.png"></a>
This is a valid binary tree. We have a single node, the root, with no children. As with general trees, binary trees are built recursively. Thus, each node and its child(ren) are trees themselves.</p>
<p><a href="#R-image-881cbb926fed47e4d03496e8f5b347ee" class="lightbox-link"><img alt="Unbalanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-881cbb926fed47e4d03496e8f5b347ee"><img alt="Unbalanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png"></a>
This is also a valid binary tree. All of the left children are less than their parent. The node with item &lsquo;10&rsquo; is also in the correct position as it is less than 12, 13, and 14 but greater than 9.</p>
<p><a href="#R-image-d35b59b27f1b4002f132e63bba3f562a" class="lightbox-link"><img alt="Balanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d35b59b27f1b4002f132e63bba3f562a"><img alt="Balanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png"></a>
We have the same nodes but our root is now 12 whereas before it was 14. This is also a valid binary tree.</p>
<p><a href="#R-image-7c975af70c928218b9093fde5a6f0e87" class="lightbox-link"><img alt="Alphabet Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Alpha.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c975af70c928218b9093fde5a6f0e87"><img alt="Alphabet Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Alpha.png"></a>
Here we have an example of a binary tree with alphabetical items. As long as we have items which have a predefined order, we can organize them using a binary tree.</p>
<hr>
<h3 id="invalid-binary-trees">Invalid Binary Trees</h3>
<p><a href="#R-image-aca4906e644346e7dc9aa546a8cb7872" class="lightbox-link"><img alt="Alphabet Non-Binary Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_NOTAlpha.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aca4906e644346e7dc9aa546a8cb7872"><img alt="Alphabet Non-Binary Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_NOTAlpha.png"></a>
We may be inclined to say that this is a binary tree: each node has 0, 1, or 2 children and amongst children and parent nodes, the left child is smaller than the parent and the right child is greater than the parent. However, in binary trees, all of the nodes in the left tree must be smaller than the root and all of the nodes in the right tree must be larger than the root. In this tree, <code>D</code> is out of place. Node <code>D</code> is less than node <code>T</code> but it is also less than node <code>Q</code>. Thus, node <code>D</code> must be on the right of node <code>Q</code>.</p>
<p><a href="#R-image-de4267d49551c41713c83998d2c1fda5" class="lightbox-link"><img alt="Too Many Children" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_ManyChildren.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de4267d49551c41713c83998d2c1fda5"><img alt="Too Many Children" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_ManyChildren.png"></a>
In this case, we do not have a binary tree. This does fit all of the criteria for being a tree but not the criteria for a binary tree. Nodes in binary trees can have at most 2 children. Node <code>30</code> has three children.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="traversals">Traversals</h1>


<a href="https://www.youtube.com/watch?v=TNkWt307y84">YouTube Video</a>

<p>In the first module we discussed two types of traversals: preorder and postorder. Within that discussion, we noted that for general trees, the preorder and postorder traversal may not be unique. This was due to the fact that children nodes are an unordered set.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>We are now working with binary trees which have a defined child order. As a result, the preorder and postorder traversals will be <strong>unique</strong>! These means that for a binary tree when we do a preorder traversal there is exactly one string that is possible. The same applies for postorder traversals as well.</p>
</div>
</div>
<p>Recall that these were defined as such:</p>
<ul>
<li>Preorder Traversal (Remember: Root Children):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the children</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Children Root):
<ol>
<li>Run the postorder traversal on the children</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
<p>Now for binary trees, we can modify their definitions to be more explicit:</p>
<ul>
<li>Preorder Traversal (Remember: Root Left Right):
<ol>
<li>Access the root</li>
<li>Run the preorder traversal on the left child</li>
<li>Run the preorder traversal on the right child</li>
</ol>
</li>
<li>Postorder Traversal (Remember: Left Right Root):
<ol>
<li>Run the postorder traversal on the left child</li>
<li>Run the postorder traversal on the right child</li>
<li>Access the root.</li>
</ol>
</li>
</ul>
<p>Let&rsquo;s practice traversals on the following binary tree.
<a href="#R-image-fda8577c84307dbfb0d80cdd12d9a138" class="lightbox-link"><img alt="Traversal Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Traversal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fda8577c84307dbfb0d80cdd12d9a138"><img alt="Traversal Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Traversal.png"></a></p>
<h2 id="preorder-traversal">Preorder Traversal</h2>
<p><a href="#R-image-c6a96080a7ba6db01fa3f13ea61b7ea4" class="lightbox-link"><img alt="Preorder" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Pre.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c6a96080a7ba6db01fa3f13ea61b7ea4"><img alt="Preorder" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Pre.gif"></a></p>
<h2 id="postorder-traversal">Postorder Traversal</h2>
<p><a href="#R-image-2ab170ee94790c3f8fb210491a54152a" class="lightbox-link"><img alt="Postorder" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Post.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ab170ee94790c3f8fb210491a54152a"><img alt="Postorder" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Post.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="in-order-traversal">In-Order Traversal</h1>


<a href="https://www.youtube.com/watch?v=uyM6L6xqn_8">YouTube Video</a>

<p>Since we have fixed order on the children, we can introduce another type of traversal: in-order traversal.</p>
<ul>
<li>
<p>In-order Traversal:</p>
<ol>
<li>Run the in-order traversal on the left child</li>
<li>Access the root, write its value</li>
<li>Run the in-order traversal on the right child</li>
</ol>
<ul>
<li>Remember: Left Root Right</li>
</ul>
</li>
</ul>
<p><a href="#R-image-42f7588c465a7cbfca3faf3a1f58b849" class="lightbox-link"><img alt="In-order" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_In.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42f7588c465a7cbfca3faf3a1f58b849"><img alt="In-order" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_In.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mybinarytree">MyBinaryTree</h1>


<a href="https://www.youtube.com/watch?v=0U5EXtcHcsU">YouTube Video</a>

<p>Our implementation of binary trees will inherit from our MyTree implementation as binary trees are types of trees. Thus, MyBinaryTree will have the functionality of MyTree in addition to the following.</p>
<p><a href="#R-image-faf38c031bfd03a2a5a008d4dd581eb8" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/binary_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-faf38c031bfd03a2a5a008d4dd581eb8"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/binary_uml.png"></a></p>
<h2 id="attributes">Attributes</h2>
<p>The binary tree has two attributes</p>
<ul>
<li>Left Child: an instance of <code>MyBinaryTree</code>, the item should be less than the item of the parent.</li>
<li>Right Child: an instance of <code>MyBinaryTree</code>, the item should be greater than the item of the parent.</li>
</ul>
<h2 id="miscellaneous-functions">Miscellaneous Functions</h2>
<ul>
<li>
<p>Get Size</p>
<ul>
<li>Will override the <code>MyTree</code> size function. If the tree is empty then we return zero. If the tree is not empty then call the <code>MyTree</code> size function.</li>
</ul>
</li>
<li>
<p>Is Empty</p>
<ul>
<li>Will return true if the node we have called the function from is empty and false if otherwise.</li>
</ul>
</li>
<li>
<p>To Sorted List</p>
<ul>
<li>Will get all of the nodes items and sort them</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function TOSORTEDLIST()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    if there`s LEFTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + LEFTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    LIST = LIST + ITEM
</span></span><span class="line"><span class="cl">    if there`s RIGHTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + RIGHTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="inserting-children">Inserting Children</h1>


<a href="https://www.youtube.com/watch?v=qFalue24DdE">YouTube Video</a>

<p>When inserting children to a binary tree, we must take some special considerations. All of the node items in the left tree must be less than the parent node item and all of the node items in the right tree must be greater than the parent node item.</p>
<p>The general procedure for adding a child is the following:
<a href="#R-image-2e3fe8b8a13e3897196e831b2f9dd9e0" class="lightbox-link"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_AddFlowChart.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e3fe8b8a13e3897196e831b2f9dd9e0"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_AddFlowChart.png"></a></p>
<p>Suppose that we have the following tree and we want to add a node with item &lsquo;85&rsquo;. Click the binary tree to see the resulting tree.</p>
<details><summary markdown="span">![Tree To Add To](images/4/4Binary_Add.png)</summary> ![Tree Adding](images/4/4Binary_AddChild.gif) </details>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function INSERT(VALUE)
</span></span><span class="line"><span class="cl">    if node is empty:
</span></span><span class="line"><span class="cl">        set nodes item to value
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else if node.ITEM &gt; VALUE 
</span></span><span class="line"><span class="cl">            LC = node`s left child
</span></span><span class="line"><span class="cl">            if LC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.LEFTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return LC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RC = node`s right child
</span></span><span class="line"><span class="cl">            if RC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.RIGHTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return RC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="removing-children">Removing Children</h1>


<a href="https://www.youtube.com/watch?v=uyhC6GcyBW4">YouTube Video</a>

<p>Removing children is not as straightforward as inserting them. The general procedure for removing a child is to replace that nodes value with its smallest right descendant. First we will traverse the binary tree until we find the node with the value we are trying to remove (lines 18-32 below). Then we have three separate cases, discussed in detail below.</p>
<h2 id="removing-a-leaf">Removing a Leaf</h2>
<p>Removing a leaf is the most straightforward. We remove the value from the node and then sever the connection between parent and child. (lines 5-7 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>5</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove Leaf](images/4/4Bin_Remove.png)</summary> ![Result of Remove Leaf](images/4/4Bin_Remove2.png) </details>
<h2 id="removing-a-node-without-right-child">Removing a Node without Right Child</h2>
<p>When we remove a value from a node that does not have a right child, we cannot replace the value with the smallest right child. In this instance we will instead replace the value with the smallest left child then prune the tree to clean it up. Once we replace the value, we must switch the node&rsquo;s left child to be the right child in order to maintain proper binary tree structure. (lines 8-13 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>4</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove w/o RightChild](images/4/4Bin_Remove2.png)</summary> ![Result of Remove w/o RightChild](images/4/4Bin_Remove3.png) </details>
<h2 id="removing-a-node-with-right-child">Removing a Node with Right Child</h2>
<p>When we remove a value from a node that has a right child, we can replace the value with the nodes smallest right child. (Lines 14-17 Below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>10</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>
<details><summary markdown="span">![Tree to Remove with RightChild](images/4/4Bin_Remove.png)</summary> ![Result of Remove with RightChild](images/4/4Bin_Remove1.png) </details>
<h2 id="complete-pseudocode">Complete Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function REMOVE(VALUE)
</span></span><span class="line"><span class="cl">2.    if node is empty:
</span></span><span class="line"><span class="cl">3.        error
</span></span><span class="line"><span class="cl">4.    if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">5.        if node is a leaf
</span></span><span class="line"><span class="cl">6.            set node.ITEM to none
</span></span><span class="line"><span class="cl">7.            return TRUE
</span></span><span class="line"><span class="cl">8.        else if node has no right child
</span></span><span class="line"><span class="cl">9.            node.ITEM = LEFTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">10.           prune left-side
</span></span><span class="line"><span class="cl">11.           store left child in right child
</span></span><span class="line"><span class="cl">12.           set left child to none    
</span></span><span class="line"><span class="cl">13.           return TRUE
</span></span><span class="line"><span class="cl">14.        else
</span></span><span class="line"><span class="cl">15.            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">16.            prune right-side
</span></span><span class="line"><span class="cl">17.            return TRUE
</span></span><span class="line"><span class="cl">18.    else
</span></span><span class="line"><span class="cl">19.        if node.ITEM &gt; VALUE
</span></span><span class="line"><span class="cl">20.            if node has LEFTCHILD
</span></span><span class="line"><span class="cl">21.                SUCCESS = LEFTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">22.                prune left-side
</span></span><span class="line"><span class="cl">23.                return SUCCESS
</span></span><span class="line"><span class="cl">24.            else
</span></span><span class="line"><span class="cl">25.                return FALSE
</span></span><span class="line"><span class="cl">26.        else
</span></span><span class="line"><span class="cl">27.            if node has RIGHTCHILD
</span></span><span class="line"><span class="cl">28.                SUCCESS = RIGHTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">29.                prune right-side
</span></span><span class="line"><span class="cl">30.                return SUCCESS
</span></span><span class="line"><span class="cl">31.            else
</span></span><span class="line"><span class="cl">32.                return FALSE
</span></span><span class="line"><span class="cl">33. end function</span></span></code></pre></div><h2 id="extras-for-removal">Extras for Removal</h2>
<p>We use the pruning functions to severe the tie between parent and child nodes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNERIGHT()
</span></span><span class="line"><span class="cl">    if RIGHTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes RIGHTCHILD former RIGHTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if RIGHTCHLID is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNELEFT()
</span></span><span class="line"><span class="cl">    if LEFTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes LEFTCHILD former LEFTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if LEFTCHILD is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We use the remove smallest function to retrieve the smallest value in the binary tree which will replace our value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVESMALLEST()
</span></span><span class="line"><span class="cl">    if node has left child
</span></span><span class="line"><span class="cl">        REPLACEMENT = LEFTCHILD.REMOVESMALLEST
</span></span><span class="line"><span class="cl">        prune left-side
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        REPLACEMENT = node.ITEM
</span></span><span class="line"><span class="cl">        if node has right child
</span></span><span class="line"><span class="cl">            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">            prune right-side
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            node.ITEM = NONE
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="balance">Balance</h1>

<p><a href="#R-image-91ee92a23b29fd3c80b3fe776b1cb8e4" class="lightbox-link"><img alt="Unbalanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91ee92a23b29fd3c80b3fe776b1cb8e4"><img alt="Unbalanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_UnBal.png"></a>
While this is a valid binary tree, it is not balanced. Let&rsquo;s look at the following tree.</p>
<p><a href="#R-image-88bc3849baad1d5ecfe97d90f9882571" class="lightbox-link"><img alt="Balanced" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-88bc3849baad1d5ecfe97d90f9882571"><img alt="Balanced" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/4/4Binary_Bal.png"></a>
We have the same nodes but our root is now 12 whereas before it was 14. This is a valid binary tree. We call this a <code>balanced</code> binary tree. A balanced binary tree looks visually even amongst the left and right trees in terms of number of nodes.</p>
<p><strong>Note:</strong> Balancing is not necessary for a valid binary tree. It is, however, important in terms of time efficiency to have a balanced tree. For example, the number of actions when inserting an element is about the same as the number of levels in the tree. If we tried to add the value 11 into the unbalanced tree, we would traverse 5 nodes. If we tried to add the value 11 in to the balanced tree, we would traverse just 3 nodes.</p>
<p>We believe that balancing binary trees is out of the scope of this course. If you are interested in how we might balance a tree, feel free to check out these videos by Dr. Joshua Weese.</p>

<a href="https://www.youtube.com/watch?v=Em9-Rr6PEBc">YouTube Video</a>


<a href="https://www.youtube.com/watch?v=N7g8vn5sJoI">YouTube Video</a>


            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="iii-graphs">Iii-Graphs</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Iii-Graphs</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 30</div>

<h1 id="graphs-matrix-representation">Graphs: Matrix Representation</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Matrix Representation</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Matrix Representation</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=lVIlBepiPEc">YouTube Video</a>

<p>The next data structure we will introduce is a graph.</p>
<p><a href="#R-image-a5f6ebc42bdd6bf8e8994fdf9a072e0f" class="lightbox-link"><img alt="Graph Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphex1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a5f6ebc42bdd6bf8e8994fdf9a072e0f"><img alt="Graph Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphex1.svg"></a></p>
<p>Graphs are multidimensional data structures that can represent many different types of data. We can use graphs to represent electronic circuits and wiring, transportation routes, and networks such as the Internet or social groups.</p>
<p>A popular and fun use of graphs is to build connections between people such as Facebook friends or even connections between performers. One example is the parlor game <a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon" rel="external" target="_blank">Six Degrees of Kevin Bacon</a>. Players attempt to connect Kevin Bacon to other performers through movie roles in six people or less.</p>
<p><a href="#R-image-bf6ee9b75714d374d2506a4d9af24f3c" class="lightbox-link"><img alt="Six Degrees of Kevin Bacon" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/actors.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf6ee9b75714d374d2506a4d9af24f3c"><img alt="Six Degrees of Kevin Bacon" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/actors.svg"></a></p>
<p>For example, Laurence Fishburne and Kevin Bacon are directly connected via &lsquo;Mystic River&rsquo;. Keanu Reeves and Kevin Bacon have never performed in the same film, but Keanu Reeves and Laurence Fishburne are connected via &lsquo;The Matrix&rsquo;. Thus, Keanu and Kevin are connected via Laurence.</p>
<p>In this module we will discuss graphs in more detail and build our own implementation of graphs.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terms-i">Terms I</h1>


<a href="https://www.youtube.com/watch?v=QIX78W3GUpc">YouTube Video</a>

<p>We will discuss some of the basic terminology associated with graphs. Some of this vocabulary should feel familiar from the trees section; trees are a specific type of graph!</p>
<ul>
<li><code>Nodes</code>: Node is the general term for a structure which contains an item.
<ul>
<li><code>Size</code>: The size of a graph is the number of nodes.</li>
<li><code>Capacity</code>: The capacity of a graph is the maximum number of nodes.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Nodes</strong> can be, but are not limited to the following examples:
- physical locations (IE Manhattan, Topeka, Salina),
- computer components (IE CPU, GPU, RAM), or
- people (IE Kevin Bacon, Laurence Fishburne, Emma Stone)</p>
</div>
</div>
<ul>
<li><code>Edges</code>: Edges are the connection between two nodes. Depending on the data, edges can represent physical distance, films, cost, and much more.
<ul>
<li><code>Adjacent</code>: Node A and node B are said to be adjacent if there is an edge from node A to node B.</li>
<li><code>Neighbors</code>: The neighbors of a node are nodes which are adjacent to the node.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Edges</strong> can be, but are not limited to:
- physical distances, like the distance between cities or wiring between computer components,
- cost, like bus fares, and
- films, like the Six Degrees of Kevin Bacon example</p>
</div>
</div>
<ul>
<li><code>Cycles</code>: A cycle is a path where the first and last node are the only repeated nodes. More explicitly, this means that we start at node A and are able to end up back at node A.</li>
</ul>
<h2 id="example">Example</h2>
<p>For example, we can translate the <a href="https://www.amtrak.com/content/dam/projects/dotcom/english/public/documents/Maps/Amtrak-System-Map-1018.pdf" rel="external" target="_blank">Amtrak Train Station Connections</a> into a graph where the edges represent direct train station connections.</p>
<p><a href="#R-image-22f1ec1721f0bff876eb2608185fbb85" class="lightbox-link"><img alt="Amtrak Train Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/amtrak.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22f1ec1721f0bff876eb2608185fbb85"><img alt="Amtrak Train Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/amtrak.svg"></a>^[Generated using the Amtrak system map from 2018. This graph does not include all stations or connections.]</p>
<p>Within this context, we could say that Little Rock and Fort Worth are <code>adjacent</code>. The <code>neighbors</code> of San Antonio are Fort Worth, Los Angeles, and New Orleans. The Amtrak Train Graph has multiple <code>cycles</code>. One of these is <code>Kansas City -&gt; St. Louis -&gt; Chicago -&gt; Kansas City</code>.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graph-features">Graph Features</h1>


<a href="https://www.youtube.com/watch?v=F_mNd-CIFpc">YouTube Video</a>

<p>While trees are a type of graph, graphs can have more functionality than trees. For example, recall that to be a single tree, there could be no disconnected pieces.</p>
<ul>
<li><code>Connectedness</code>: Graphs do not require being fully connected. There can be disconnected portions within a graph. For example, the following graph shows all of the students in a sophomore biology class. There is an edge between two student nodes if they are Facebook friends.</li>
</ul>
<p><a href="#R-image-927cff487cbbe57c2b82e25baf3916df" class="lightbox-link"><img alt="Friends Group" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/friends.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-927cff487cbbe57c2b82e25baf3916df"><img alt="Friends Group" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/friends.svg"></a></p>
<p>Graphs can also have loops. In a tree, this would be like a node being its own parent, which is not an allowable condition.</p>
<ul>
<li><code>Loops</code>: Loops are edges which connect a node to itself. These can be useful in depicting graphs that show control flow in programming. In this example, node A is connected to node B and node A is connected to itself.</li>
</ul>
<p><a href="#R-image-927c2e909438d2fcf4f6aa8ac63786d9" class="lightbox-link"><img alt="With a Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/loop2.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-927c2e909438d2fcf4f6aa8ac63786d9"><img alt="With a Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/loop2.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="weighted-graphs">Weighted Graphs</h1>


<a href="https://www.youtube.com/watch?v=x4_myCOtFnk">YouTube Video</a>

<p>A <strong>weighted</strong> graph is a graph which has weights associated with the edges. These weights quantify the relationships, so they can represent dollars, minutes, miles, and many other factors which our data may depend upon.</p>
<p>Weights are not limited to physical quantities; they can also be our own defined similarity in text, product types, and anything for which we can create a similarity measure for. Let&rsquo;s look at concrete weights using the Amtrak example.</p>
<p>We are able to expand the Amtrak graph from the previous page to include approximate distances in miles between cities.</p>
<p><a href="#R-image-91c7fdb1158377d3e5cb3e10d45a7c8b" class="lightbox-link"><img alt="Amtrak Train Graph with Weights" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/amtrak_dist.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91c7fdb1158377d3e5cb3e10d45a7c8b"><img alt="Amtrak Train Graph with Weights" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/amtrak_dist.svg"></a>^[Generated using the Amtrak system map from 2018. This graph does not include all stations or connections. Distance was calculated approximately &lsquo;as the crow flies&rsquo;.]</p>
<p>Now that we have weights defined on our edges, we can compare paths in a different way. When we discussed trees, we just looked at the number of edges it took to get to another node. We can also determine the shortest path between nodes with respect to distance. If we wanted to travel from San Antonio to Kansas City, we may be tempted to travel <code>San Antoinio -&gt; Los Angeles -&gt; Albuquerque -&gt; Kansas City</code> as it has the fewest stops. This trip would take us 2,531 miles (1201+640+690). With the edge weights in mind, a much better route would be <code>San Antonio -&gt; Fort Worth -&gt; Little Rock -&gt; St. Louis -&gt; Kansas City</code> with a total of 1,089 miles(238+320+293+238) traveled.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="directed-graphs">Directed Graphs</h1>


<a href="https://www.youtube.com/watch?v=f7qyV9XOwzA">YouTube Video</a>

<p>A <strong>directed</strong> graph is a graph that has a direction associated with each edge. For example, trees are a directed graph. The edge orientation will imply a fixed direction that we can move about nodes. As with trees, the flat end of the arrow will represent the origin and the arrowhead will represent the destination. If an edge has no arrowheads, then it is assumed that we can traverse both directions.</p>
<p>In the following graph, we have an example distribution network where each store ends up with 5 units in its possession. For example, nine units go from the distribution center to Store A. The distribution center will never receive product from stores as it has no incoming edges.</p>
<p><a href="#R-image-3105b52e922cf8086447a45a820cbae0" class="lightbox-link"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/distribution-3.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3105b52e922cf8086447a45a820cbae0"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/distribution-3.svg"></a></p>
<p>Unlike trees, directed graphs can have nodes with multiple incoming edges. We can see an example of this at Store B. The distribution center and Store A both send units to Store B.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>In directed graphs, we must be cautious on how we define <strong>adjacent</strong>. For the following, we would say that the source is adjacent to the target. However, the target is not adjacent to the source.</p>
<p><a href="#R-image-4d192595dde8bcb4efb5106407daa98a" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d192595dde8bcb4efb5106407daa98a"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg"></a></p>
<p>Formally, node A and node B are said to be adjacent if there is an edge from node A to node B.</p>
</div>
</div>
<p>When discussing directed graphs, we must also talk about undirected graphs. An <strong>undirected</strong> graph is a graph in which none of the edges have an orientation. If there is at least one directed edge, then it is considered a directed graph.</p>
<ul>
<li><code>Undirected Edge</code>: An undirected edge is an edge which has no defined orientation (IE no arrowheads) which implies that we can traverse in either direction. If node A and node B are connected via an undirected edge then we say node A is adjacent to node B and node B is adjacent to node A.</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For the following undirected edge, we would say that the source is adjacent to the target and the target is adjacent to the source.</p>
<p><a href="#R-image-0c98a15cd30eb2c2775c1c6b67f5bd0e" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/undirected_edge.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c98a15cd30eb2c2775c1c6b67f5bd0e"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/undirected_edge.svg"></a></p>
</div>
</div>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Graph types and appearances can vary wildly. We are not limited to just weighted/unweighted or directed/undirected. We can also have combinations of weighted and directed.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example">Example</h1>

<p>In the following graph, we have an example of a weighted and directed map. This map represents a zoo train where each node represents a station and each edge is a part of the track. Zoo guests can get on and off wherever they desire.</p>
<p>This graph is weighted as guests must pay the associated fee for each part of the track. Our example train also has a one way direction in most cases. The exception to this is the entrance/exit to the aquarium, this part of the track can go either direction.</p>
<p>In this graph, we also have a couple of loops. This would allow for zoo-guests to ride the train around an expansive exhibit such as the elephants or giraffes.</p>
<p>One possible way to tour the zoo for a guest starting at the entrance could be: aquarium, primates, big cats, antelope, giraffes, loop around the giraffes, elephants, aquarium, then exit. Their total payment for just the train would be $14.</p>
<p><a href="#R-image-fce946f044218e873e418d793f466828" class="lightbox-link"><img alt="Zoo Train Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/zoo.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fce946f044218e873e418d793f466828"><img alt="Zoo Train Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/zoo.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="matrix-representation">Matrix Representation</h1>


<a href="https://www.youtube.com/watch?v=Uwd8YkQwoqM">YouTube Video</a>

<p>The first way that we can represent graphs is as matrices. In a matrix representation of a graph, we will have an array with all the nodes and a matrix to depict the edges. The matrix that depicts the edges is called the <code>adjacency matrix</code>.</p>
<p>To build the <code>adjacency matrix</code>, we go through the nodes and edges. If there is an edge with weight <code>w</code> going from <code>i</code> to <code>j</code>, then we put <code>w</code> in the <code>(i,j)</code> spot in our <code>adjacency matrix</code>. If there is no edge from <code>i</code> to <code>j</code> then we put infinity in the spot <code>(i,j)</code>. Let&rsquo;s look at some examples.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>An edge that starts at <code>source</code> and ends at <code>target</code> will result in an entry at <code>(source,target)</code> in the adjacency matrix.</p>
<p><a href="#R-image-e9e1d3c2adc740097e083df794987783" class="lightbox-link"><img alt="Source and Target Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e9e1d3c2adc740097e083df794987783"><img alt="Source and Target Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/src_tar_ex.svg"></a></p>
</div>
</div>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For an unweighted graph, we treat the weights as 1 for all edges in our adjacency matrix.</p>
<p>For an undirected edge between nodes <code>i</code> and <code>j</code>, we put an edge from <code>i</code> to <code>j</code> and an edge from <code>j</code> to <code>i</code>.</p>
</div>
</div>
<h2 id="example-1">Example 1</h2>
<p>Suppose that we have the following graph:</p>
<p><a href="#R-image-f849543f78a7634f2f8a9c6575657f6f" class="lightbox-link"><img alt="Matrix Representation Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f849543f78a7634f2f8a9c6575657f6f"><img alt="Matrix Representation Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>Across the top of the following, we have the array of nodes. This give us the index at which each node is located. For example, node A is in spot <code>1</code>, node B is in spot <code>2</code>, node C is in spot <code>3</code> and so on.</p>
<p>Below that we have the adjacency matrix. For the directed edge with weight 2 that goes from node B to node C, we have the value 2 at (2,3) in the adjacency matrix as B has index 2 and C has index 3. For the directed edge with weight 4 that goes from node A to node F, we have the value 4 at (1,6) in the adjacency matrix as A has index 1 and F has index 6.</p>
<p>Since there is no edge that connects from node A to node B, we have infinity in <code>(1,2)</code>.</p>
<p><a href="#R-image-7062da83465e8deee5175bf20d88c48a" class="lightbox-link"><img alt="Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7062da83465e8deee5175bf20d88c48a"><img alt="Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixA.svg"></a></p>
<h2 id="example-2">Example 2</h2>
<p>Now suppose we have this graph. We now have some loops present.
<a href="#R-image-6e7580f9f89acfc9a25702d12f171939" class="lightbox-link"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6e7580f9f89acfc9a25702d12f171939"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a></p>
<p>For example, we have a loop on node E with weight 12 so we will put the value 12 in spot (5,5) as E has index 5.</p>
<p><a href="#R-image-77d23e0f6f18d271d0cdb8e41bbf57ba" class="lightbox-link"><img alt="Matrix 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-77d23e0f6f18d271d0cdb8e41bbf57ba"><img alt="Matrix 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixB.svg"></a></p>
<h2 id="example-3">Example 3</h2>
<p>Now suppose we have this graph which is undirected and unweighted.
<a href="#R-image-55ef0840f03889fb04e283ee9e48baf2" class="lightbox-link"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphC.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-55ef0840f03889fb04e283ee9e48baf2"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphC.svg"></a></p>
<p>Since this graph is unweighted, we will treat all edges as though they have weight equal to one. Since this graph is undirected, each edge will essentially show up twice.</p>
<p>For example, for the edge that connects nodes A and B, we will have an entry in our adjacency matrix at <code>(1,2)</code> and <code>(2,1)</code>.</p>
<p><a href="#R-image-c8d04b7236e24fccdea2b276192a1b1a" class="lightbox-link"><img alt="Matrix 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixC.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c8d04b7236e24fccdea2b276192a1b1a"><img alt="Matrix 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixC.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml">UML</h1>


<a href="https://www.youtube.com/watch?v=Alyg8IEC0Os">YouTube Video</a>

<p><a href="#R-image-271d63586438d149adaf31775e6b1a07" class="lightbox-link"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphmatUML.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-271d63586438d149adaf31775e6b1a07"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphmatUML.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>edges</code>: This will keep track of the edges which are in our graph.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array of size <code>capacity</code>, <code>edges</code> to be an empty two-dimensional array with dimensions <code>capacity</code> by <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for ROW in EDGES
</span></span><span class="line"><span class="cl">        for COL in ROW
</span></span><span class="line"><span class="cl">            VALUE = entry at (ROW,COL)
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (ROW,COL,VALUE) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity.</p>
</li>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph. We will iterate through our edges and return the number of entries that were not infinity.</p>
</li>
<li>
<p><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    if IDX in range of NODES length
</span></span><span class="line"><span class="cl">        LIST = []
</span></span><span class="line"><span class="cl">        ROW = the IDX-th row of EDGES
</span></span><span class="line"><span class="cl">        for J in range  0 to ROW length
</span></span><span class="line"><span class="cl">            VALUE = J-th entry of ROW
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (J,VALUE) to LIST
</span></span><span class="line"><span class="cl">        return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>


<a href="https://www.youtube.com/watch?v=MNoJEn_EvBk">YouTube Video</a>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Procedurally, we will try to put the node in the first empty place we find. To do this, we start with <code>IDX</code> equal to negative one then loop through all of the indexes of the graphs <code>nodes</code> attribute. At each index, we check if that entry is equal to the value we are trying to add. This will check if the value is already in our graph. If there is nothing in that entry and the <code>IDX</code> variable is still negative one, then we will set <code>IDX</code> equal to that index. We continue looping through the <code>nodes</code> attribute until we reach the end. It is possible that there is more than one open space in the <code>nodes</code> attribute. Thus, by checking if <code>IDX</code> is still negative one we can make sure to put <code>value</code> in the first empty spot. Once we finish going through <code>nodes</code> we check to see if we ever found an open spot. If <code>IDX</code> is still negative one, this would indicate that there was no room. Otherwise, we put <code>value</code> into <code>nodes</code> at spot <code>IDX</code> and increment the size.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        add VALUE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty and remove any edges that may be attached to it.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for J in node indexes 
</span></span><span class="line"><span class="cl">                set EDGES (J,IDX) equal to infinity 
</span></span><span class="line"><span class="cl">                set EDGES (IDX,J) equal to infinity
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SOURCE, TARGET, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        set EDGES(SOURCE, TARGET) equal to WEIGHT
</span></span><span class="line"><span class="cl">        return true 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        if EDGES(SOURCE, TARGET) is not equal to infinity
</span></span><span class="line"><span class="cl">            set EDGES(SOURCE, TARGET) equal to infinity
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes. We can utilize the remove edge function on &lsquo;NODE1&rsquo; to &lsquo;NODE2&rsquo; and then on &lsquo;NODE2&rsquo; to &lsquo;NODE1&rsquo;.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this module, we have introduced the graph data structure. We also looked at how we would implement a graph using a matrix representation. We introduced the following new concepts in this module:</p>
<ul>
<li>
<p><code>Directed Graphs</code>: A directed graph is a graph that has a direction associated with each edge. The flat end of the arrow will represent the origin and the arrowhead will represent the destination. If an edge has no arrowheads, then it is assumed that we can traverse both directions.</p>
</li>
<li>
<p><code>Edges</code>: Edges are the connection between two nodes. Depending on the data, edges can represent physical distance, films, cost, and much more.</p>
<ul>
<li><code>Adjacent</code>: Node A and node B are said to be adjacent if there is an edge from node A to node B.</li>
<li><code>Neighbors</code>: The neighbors of a node are nodes which are adjacent to the node.</li>
<li><code>Undirected Edge</code>: An undirected edge is an edge which has no defined orientation (IE no arrowheads). If node A and node B are connected via an undirected edge then we say node A is adjacent to node B and node B is adjacent to node A.</li>
</ul>
</li>
<li>
<p><code>Loops</code>: Loops are edges which connect a node to itself.</p>
</li>
<li>
<p><code>Nodes</code>: Node is the general term for a structure which contains an item.</p>
<ul>
<li><code>Size</code>: The size of a graph is the number of nodes.</li>
<li><code>Capacity</code>: The capacity of a graph is the maximum number of nodes.</li>
</ul>
</li>
<li>
<p><code>Weighted Graphs</code>: A weighted graph is a graph which has weights associated with the edges. These weights will quantify the  relationships so they can represent dollars, minutes, miles, and many other factors which our data may depend on.</p>
</li>
</ul>
<p>In the next module, we will look at a list implementation of graphs and when we might use one implementation over the other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 35</div>

<h1 id="graphs-list-representation">Graphs: List Representation</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: List Representation</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: List Representation</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=DgN_qmbtK_M">YouTube Video</a>

<p>In the previous module, we introduced graphs and a matrix-based implementation. For this module, we will continue working with graphs and change our implementation to lists.</p>
<h2 id="why-another-implementation">Why Another Implementation?</h2>
<p>When using graphs, a lot of situational variation can occur. Some graphs can have a few nodes with many edges, many nodes with few edges, and so on. When we use the matrix implementation, we initialize a matrix with the number of columns and rows equal to the number of nodes. For example, if we have a graph with 20 nodes, our adjacency matrix would have 20 rows and 20 columns, resulting in 400 potential entries.</p>
<p>First let&rsquo;s look at the implementation and then we will discuss when one may be better than the other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-representation">List Representation</h1>


<a href="https://www.youtube.com/watch?v=MJqStsuqf_U">YouTube Video</a>

<p>In the matrix representation, we had an array of the node items. In the list representation, we will have an array of node objects. Each <strong>node object</strong> will keep track of the node item, the node index, and the outgoing edges.</p>
<p><a href="#R-image-ad2966a96c10df599119a0508373bc95" class="lightbox-link"><img alt="Set Up" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ad2966a96c10df599119a0508373bc95"><img alt="Set Up" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/list_graph_setup.svg"></a></p>
<p>The <code>item</code> can be any object and the <code>index</code> will be a value within our capacity. The <code>edges</code> will be a list of pairs where the first entry is the index of the target node and the second entry is the weight of the edge.</p>
<p>Since each node will track its neighbors, it is important that we are consistent in our indexing of nodes. If our nodes were to get out of order, then our edges would as well.</p>
<h2 id="example-1">Example 1</h2>
<p>Consider the following graph which we saw in the matrix representation.</p>
<p><a href="#R-image-7e054b8ff44dff4e13f295327f1e4ae7" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e054b8ff44dff4e13f295327f1e4ae7"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>The following list of nodes depicts the graph above. We can see that each node object has the item and index.</p>
<p>If we look closer at the <code>edges</code> of the node with item <code>A</code> and index <code>1</code>, we see that the set of edges is equal to <code>[(4, 3.0), (6, 4.0)]</code>. This corresponds to the fact that there are two edges with the source as node <code>1</code>. The first ordered pair, <code>(4, 3.0)</code>, means that there is an edge with source node <code>1</code> (<code>A</code>) and target node <code>4</code> (<code>D</code>) that has weight <code>3</code>. We can confirm that in our graph we do have an edge from <code>A</code> to <code>D</code> with weight <code>3</code>.</p>
<p><a href="#R-image-fee67b391c4908ef6c9dee335751bcab" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fee67b391c4908ef6c9dee335751bcab"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="example-2">Example 2</h2>
<p>The following includes a couple of examples of loops within our graph.</p>
<p><a href="#R-image-8965050892eadf0e38ee8bd830cbb160" class="lightbox-link"><img alt="Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8965050892eadf0e38ee8bd830cbb160"><img alt="Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a></p>
<p>We have loops on nodes <code>D</code>, <code>E</code>, and <code>F</code> in our graph. Recall that a loop is an edge where the source and target are the same. For example, we have an edge with source <code>D</code> and target <code>D</code> that has weight <code>12</code>. We see this in our list representation in the node object with item <code>D</code> and index <code>4</code>, where we have the entry <code>(4,12.0)</code> in the edges.</p>
<p><a href="#R-image-454897aa328877c782db8f28a370d8ff" class="lightbox-link"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-454897aa328877c782db8f28a370d8ff"><img alt="List Representation for Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphB_list_rep.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="dense-vs-sparse">Dense VS Sparse</h1>


<a href="https://www.youtube.com/watch?v=y4bCalShe_Y">YouTube Video</a>

<p>When considering which implementation to use, we need to consider the connectivity in our graph. The terms that we use to describe the connectedness are <strong>dense</strong> and <strong>sparse</strong>.</p>
<ul>
<li><code>Dense Graph</code>: A dense graph is a graph in which there is a large number of edges. Typically in a dense graph, the number of edges is close to the maximum number of edges.</li>
<li><code>Sparse Graph</code>: A sparse graph is a graph in which there is a small number of edges. In this case the number of edges is considerably less than the maximum number of edges.</li>
</ul>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Intuitively, we can think of dense and sparse in terms of populations. For example, if 100 people lived in a city block, we can consider that to be densely populated. If 100 people lived in 100 square miles we can consider that to be sparsely populated.</p>
</div>
</div>
<p>Let&rsquo;s look at some motivating examples to get an idea of how the different structures will handle these cases.</p>
<h2 id="dense">Dense</h2>
<p>The following is a dense graph. In this case, our graph does have the maximum number of edges. This means that every node is connected to every other node including itself.</p>
<p><a href="#R-image-6d4ea1f02ee50fd55d7760f132e8449d" class="lightbox-link"><img alt="Dense Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6d4ea1f02ee50fd55d7760f132e8449d"><img alt="Dense Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_graph.svg"></a>
<a href="#R-image-768af4272c2f51926bf1fe38f2313627" class="lightbox-link"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-768af4272c2f51926bf1fe38f2313627"><img alt="Dense Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_matrix.svg"></a>
<a href="#R-image-3ef576feed2815653adf48dce7587662" class="lightbox-link"><img alt="Dense Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/dense_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ef576feed2815653adf48dce7587662"><img alt="Dense Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/dense_list.svg"></a></p>
<h2 id="sparse">Sparse</h2>
<p>The following is a sparse graph.</p>
<p><a href="#R-image-9e85a5cc64d3c8fbd2371ef9d34a3ae1" class="lightbox-link"><img alt="Sparse Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9e85a5cc64d3c8fbd2371ef9d34a3ae1"><img alt="Sparse Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_graph.svg"></a>
<a href="#R-image-7e5a102ba691b47bf17bf288f3d10160" class="lightbox-link"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e5a102ba691b47bf17bf288f3d10160"><img alt="Sparse Graph as Matrix" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_matrix.svg"></a>
<a href="#R-image-18230ce7e9fa792ff602a4949a63dbaf" class="lightbox-link"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/sparse_list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18230ce7e9fa792ff602a4949a63dbaf"><img alt="Sparse Graph as List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/sparse_list.svg"></a></p>
<h2 id="list-or-matrix">List or Matrix?</h2>
<p>For dense graphs, the matrix representation will have better qualities as we are already setting aside space for the maximum number of edges. Sparse graphs are better represented in the list representation.</p>
<p>When we initialize the matrix implementation, we initialize the <code>nodes</code> attribute to have dimension equal to the capacity of the graph. The <code>edges</code> attribute is initialized to be a square matrix with dimension equal to capacity by capacity. Thus, if we have a sparse matrix, we are representing a lot of non-existent edges.</p>
<p>When we initialize the list implementation, we just have the <code>nodes</code> attribute which has dimension equal to the capacity and each node tracks its own edges. If we have a dense matrix and we are searching for an edge, we must loop through each edge from the target node to see if the edge exists. In the matrix representation, we can access that edge directly.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>If the proportion of edges to the maximum number of edges is greater than 1/64, then the matrix representation is better in terms of space.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph-node">UML - Graph Node</h1>


<a href="https://www.youtube.com/watch?v=BVgbAW7NZY8">YouTube Video</a>

<p>In this representation, we will have an array of graph node objects. We will first cover the UML for the graph node objects and then discuss the graph functions and attributes.</p>
<p><a href="#R-image-654037d7eb89bbc3f334547294de2a93" class="lightbox-link"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-654037d7eb89bbc3f334547294de2a93"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_node.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>item</code>: the value that the node contains.</li>
<li><code>index</code>: the index of the node.</li>
<li><code>edges</code>: ordered pairs <code>(e, w)</code> where this node is the source, <code>e</code> is the target node index, and <code>w</code> is the weight of the edge as a double.</li>
</ul>
<p>We will initialize a graph node with the given item and the given index. We initialize the <code>edges</code> attribute to be an empty list.</p>
<h2 id="getters">Getters</h2>
<ul>
<li>
<p><code>get item</code>: Returns the graph node&rsquo;s item.</p>
</li>
<li>
<p><code>get index</code>: Returns the graph node&rsquo;s index.</p>
</li>
<li>
<p><code>get edges</code>: Returns the graph node&rsquo;s edges.</p>
</li>
<li>
<p><code>get edge</code>: From the source node, we will call the get edge function with the index of the target node as input. This will return the edge weight.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            return the second element in EDGE
</span></span><span class="line"><span class="cl">    return infinity </span></span></code></pre></div><h2 id="edge-functions">Edge Functions</h2>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Working with the edges in our graph becomes slightly more complicated in the list representation. Previously, we were able to go right to the entry in our adjacency matrix and update it. Since each node keeps track of its own edges in no particular order, we must loop through each entry of the edges attribute to find a potential edge.</p>
</div>
</div>
<ul>
<li><code>add edge</code>: From the source node, we will call the add edge function with the target node as input as well as the weight. First, we will attempt to remove the edge. We need to do this as we do not want duplicate edges in our graph. Then we will add the ordered pair to the edges attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(TARINDEX, WEIGHT)
</span></span><span class="line"><span class="cl">    call REMOVEEDGE(TARINDEX) on this node
</span></span><span class="line"><span class="cl">    append (TARINDEX, WEIGHT) to this nodes EDGES </span></span></code></pre></div><ul>
<li><code>remove edge</code>: From the source node, we will call the remove edge function with the target node as input. This will return true if it was successful and false if not.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            remove EDGE from EDGES
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    return false </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph">UML - Graph</h1>


<a href="https://www.youtube.com/watch?v=A6HVJWM3VS4">YouTube Video</a>

<p><a href="#R-image-c52bdb7b38825b5c5c6641baa2341df7" class="lightbox-link"><img alt="List Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c52bdb7b38825b5c5c6641baa2341df7"><img alt="List Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphs_listUML_graph.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array with dimension <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes. This will be the same logic from our matrix graph.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                TAR = first entry of EDGE
</span></span><span class="line"><span class="cl">                WEIGHT = second entry of EDGE
</span></span><span class="line"><span class="cl">                append (NODE,TAR,WEIGHT) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity. From the source node object, we will call the graph node get edge function on the target index.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(SRC,TAR)
</span></span><span class="line"><span class="cl">    if SRC and TAR are between 0 and capacity
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        WEIGHT = call the graph node GETEDGE from SRCNODE on TAR
</span></span><span class="line"><span class="cl">        return WEIGHT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return infinity</span></span></code></pre></div><ul>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute. This will be the same logic from our matrix graph.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function NUMBEROFEDGES()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is not empty
</span></span><span class="line"><span class="cl">            for EDGE in NODE EDGES
</span></span><span class="line"><span class="cl">                increment COUNT by one
</span></span><span class="line"><span class="cl">    return COUNT</span></span></code></pre></div><ul>
<li><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    SRCNODE = the node at index IDX of the NODES attribute
</span></span><span class="line"><span class="cl">    if SRCNODE is not empty
</span></span><span class="line"><span class="cl">        return SRCNODE&#39;s edges 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return nothing
</span></span><span class="line"><span class="cl">        </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Finding a location for the node will be the same procedure as the matrix graph. If we find an open spot to add the node, we will instantiate a new graph node and insert it into the <code>nodes</code> attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        NEWNODE = graph node with VALUE and IDX for input
</span></span><span class="line"><span class="cl">        add NEWNODE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty. When we set the node to be empty, we clear all of the outgoing edges, so we just need to loop through the other nodes removing any possible incoming edges.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for NODE in NODES
</span></span><span class="line"><span class="cl">                if NODE has no entry
</span></span><span class="line"><span class="cl">                    from NODE call the graph node REMOVEEDGE function on IDX
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SRC, TAR, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE is not empty
</span></span><span class="line"><span class="cl">            from SRCNODE call the graph node ADDEDGE with TAR and WEIGHT as input
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE has no entry
</span></span><span class="line"><span class="cl">            RET = SRCNODE call the graph node REMOVEEDGE with TAR as input
</span></span><span class="line"><span class="cl">            return RET 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p><a href="#R-image-39446538ed180100088f67e263dade4c" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39446538ed180100088f67e263dade4c"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a></p>
<p>In this module, we introduced a new way to store the graph data structure. Thus, we now have two ways to work with graphs, in lists and in matrices:</p>
<h2 id="list-representation">List Representation</h2>
<p><a href="#R-image-4aa1b434e71acef47af8e9dbcf41b86c" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4aa1b434e71acef47af8e9dbcf41b86c"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<h2 id="matrix-representation">Matrix Representation</h2>
<p><a href="#R-image-096db50c0189056a00089dbdb39ab182" class="lightbox-link"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-096db50c0189056a00089dbdb39ab182"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixA.svg"></a></p>
<p>While these methods show the same information, there are cases when one way may be more desirable than the other.</p>
<p>We discussed how a sparse graph is better suited for a list representation and a dense graph is better suited for a matrix representation. We also touched on how working with the edges in a list representation can add complexity to our edge functions. If we are needing to access edge weights or update edges frequently, a matrix representation would be a good choice &ndash; especially if we have a lot of nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 40</div>

<h1 id="graphs-searching-and-traversing">Graphs: Searching and Traversing</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Searching and Traversing</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Searching and Traversing</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=rGiEVQE1hR4">YouTube Video</a>

<p>In the previous modules, we have introduced graphs and two implementations. This module will cover the traversals through graphs as well as path search techniques.</p>
<h2 id="motivation">Motivation</h2>
<p>As we have discussed previously, graphs can have many applications. Based on that, there are many things that we may want to infer from graphs. For example, if we have a graph that depicts a railroad or electrical network, we could determine what maximum flow of the network. The standard approach for this task is the <a href="https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/" rel="external" target="_blank">Ford-Fulkerson Algorithm</a>. In short, given a graph with edge weights that represent capacities the algorithm will determine the maximum flow throughout the graph.</p>
<p>From the matrix graph module, we used the following distribution network as an example.
<a href="#R-image-818b428ecdab0d593509728dc51e2c08" class="lightbox-link"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/distribution-3.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-818b428ecdab0d593509728dc51e2c08"><img alt="Sample Distribution Network" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/distribution-3.svg"></a></p>
<p>Conceptually, we would want to determine the maximum number of units that could leave the distribution center without having excess laying around stores. Using the maximum flow algorithm, we would determine that the maximum number of units would be 15.</p>
<p><a href="#R-image-398dd98b9caac71ea42d4d6661bc1002" class="lightbox-link"><img alt="Max Flow" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/distribution-3MAX.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-398dd98b9caac71ea42d4d6661bc1002"><img alt="Max Flow" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/distribution-3MAX.svg"></a></p>
<p>The driving force in the Ford-Fulkerson algorithm, as well as other maximum  flow algorithms, is the ability to find a path from a source to a target. Specifically, these algorithms use breadth first and depth first searches to discover possible paths.</p>
<h2 id="searches">Searches</h2>
<p>To get to introducing the searches, we will first discuss the basis of them. Those are the depth first traversal and the breadth first traversal. We will outline the premise of these traversals and then discuss how we can modify their algorithms for various tasks, such as path searches.</p>
<p>We can perform these traversals on any type of graph. Conceptually, it will help to have a tree-like structure in mind to differentiate between depth first and breadth first.</p>
<p><a href="#R-image-ea4d8a824cdf62b35cfb75c15ddba897" class="lightbox-link"><img alt="Breadth VS Depth" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/8search_breadthVSdepth.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ea4d8a824cdf62b35cfb75c15ddba897"><img alt="Breadth VS Depth" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/8search_breadthVSdepth.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="depth-first">Depth First</h1>

<p>
<a href="https://www.youtube.com/watch?v=3lalaxn0yNs">YouTube Video</a>

<a href="https://core.cs.ksu.edu/4-cc315/08-graph-traversal/02-graph-traversals-dfs-slides/#/" rel="external" target="_blank">Video Slides</a></p>
<p>First we will discuss Depth First Traversal. We can define the depth first traversal in two ways, iteratively or recursively. For this course, we will define it iteratively.</p>
<p>In the iterative algorithm, we will initialize an empty stack and an empty set. The stack will determine which node we search next and the set will track which nodes we have already searched.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that a stack is a &lsquo;Last In First Out&rsquo; (LIFO) structure. Based on this, the depth first traversal will traverse a nodes descendants before its siblings.</p>
</div>
</div>
<p>To do the traversal, we must pick a starting node; this can be an arbitrary node in our graph. If we were doing the traversal on a tree, we would typically select the root at a starting point. We start a while loop to go through the stack which we will be pushing and popping from. We get the top element of the stack, if the node has not been visited yet then we will add it to the set to note that we have now visited it. Then we get the neighbors of the node and put them onto the stack and continue the process until the stack is empty.</p>
<p><a href="#R-image-c62f3eedd675ac10f79b2a574b837c00" class="lightbox-link"><img alt="DFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/SEARCH_DFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c62f3eedd675ac10f79b2a574b837c00"><img alt="DFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/SEARCH_DFS.gif"></a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function DEPTHFIRST(GRAPH,SRC)
</span></span><span class="line"><span class="cl">    STACK = empty array
</span></span><span class="line"><span class="cl">    DISCOVERED = empty set
</span></span><span class="line"><span class="cl">    append SRC to STACK
</span></span><span class="line"><span class="cl">    while STACK is not empty
</span></span><span class="line"><span class="cl">        CURR = top of the stack
</span></span><span class="line"><span class="cl">        if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">                append NODE to STACK</span></span></code></pre></div><p>Since the order of the neighbors is not guaranteed, the traversal on the same graph with the same starting node can find nodes in different orders.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="breadth-first">Breadth First</h1>


<a href="https://www.youtube.com/watch?v=FViSRGbGn54">YouTube Video</a>

<p><a href="https://core.cs.ksu.edu/4-cc315/08-graph-traversal/03-graph-traversals-bfs-slides/#/" rel="external" target="_blank">Video Slides</a></p>
<p>We can also perform a breadth first traversal either iteratively or recursively. As with the depth first traversal, we will define it iteratively.</p>
<p>In the iterative algorithm, we initialize an empty queue and an empty set. Like depth first traversal, the set will track which nodes we have discovered. We now use a queue to track which node we will search next.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that a queue is a &lsquo;First In First Out&rsquo; (FIFO) structure. Based on this, the breadth first traversal will traverse a nodes siblings before its descendants.</p>
</div>
</div>
<p>Again, we must pick a starting node; this can be an arbitrary node in our graph. We add the starting node to our queue and the set of discovered nodes. We start a while loop to go through the queue which we will be enqueue  and dequeue from. We get the first element of the queue, then get the neighbors of the current node. We loop through each edge adding the neighbor to the discovered set and the queue if it has not already been discovered. We continue this process until the queue is empty.</p>
<p><a href="#R-image-012c767347453912dc7bc6689180230b" class="lightbox-link"><img alt="BFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/SEARCH_BFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-012c767347453912dc7bc6689180230b"><img alt="BFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/SEARCH_BFS.gif"></a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function BREADTHFIRST(GRAPH,SRC)
</span></span><span class="line"><span class="cl">    QUEUE = empty queue
</span></span><span class="line"><span class="cl">    DISCOVERED = empty set
</span></span><span class="line"><span class="cl">    add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">    add SRC to QUEUE
</span></span><span class="line"><span class="cl">    while QUEUE is not empty
</span></span><span class="line"><span class="cl">        CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">                append NODE to QUEUE</span></span></code></pre></div>
  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>It is important to remember in these implementations that a stack is used for depth first and a queue is used for a breadth first. The stack, being a LIFO structure, will proceed with the newest entry which will put us farther away from the source. The queue, being a FIFO structure, will proceed with oldest entry which will focus the algorithm more on the adjacent nodes. If we were to use say a queue for a depth first search, we would be traversing neighbors before descendants.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="limitations">Limitations</h1>


<a href="https://www.youtube.com/watch?v=sSz7UDs0cH8">YouTube Video</a>

<p>When introducing graphs, we discussed how the components of a graph didn&rsquo;t have to all be connected. If our goal is to visit each node, like in the searches, then we will need to perform the search from every node.</p>
<p>For example, the graph below has two separate components. Lets walk through which nodes we will discover by calling the traversals from each node.</p>
<p><a href="#R-image-3655264232911bcfa525ac848ecdb7d9" class="lightbox-link"><img alt="Disconnected Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/8search_dis.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3655264232911bcfa525ac848ecdb7d9"><img alt="Disconnected Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/8search_dis.svg"></a></p>
<table>
<thead>
<tr>
<th>Start</th>
<th>Visited (in alphabetical order)</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>{A, D, H}</td>
</tr>
<tr>
<td>B</td>
<td>{B, E, H, I}</td>
</tr>
<tr>
<td>C</td>
<td>{C}</td>
</tr>
<tr>
<td>D</td>
<td>{D}</td>
</tr>
<tr>
<td>E</td>
<td>{E, H, I}</td>
</tr>
<tr>
<td>F</td>
<td>{C, F}</td>
</tr>
<tr>
<td>G</td>
<td>{C, G}</td>
</tr>
<tr>
<td>H</td>
<td>{H}</td>
</tr>
<tr>
<td>I</td>
<td>{I}</td>
</tr>
<tr>
<td>J</td>
<td>{C, F, G, J}</td>
</tr>
</tbody>
</table>
<p>In this example, we would need to call either traversal on nodes A, B and J in order to visit all of the nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="finding-a-path">Finding a Path</h1>


<a href="https://www.youtube.com/watch?v=DKy-q1hWPpQ">YouTube Video</a>

<p>An important application for these traversals is the ability to find a path between two nodes. This has many applications in railroad networks as well as electrical wiring. With some modifications to the traversals, we can determine if electricity can flow from a source to a target. We will modify depth first and breadth first traversals in similar ways.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>There are three cases that can happen when we search for a path between nodes:</p>
<ul>
<li>No Path: will return nothing</li>
<li>One Path: will return the path</li>
<li>Multiple Paths: will return A path</li>
</ul>
<p>With these searches, we are not guaranteed to return the same path if there are multiple paths.</p>
</div>
</div>
<p>We will call these Depth First Search (DFS) and Breadth First Search (BFS). In both traversals, we have added the following extra lines: 4, 9-16, and 22 through the end.</p>
<p>First, we have the addition of <code>PARENT_MAP</code> which will be a dictionary to keep track of how we get from one node to another. We will use the convention of having the key be the child and the value be the parent. While we use the terms child and parent, this is not exclusive to trees.</p>
<p>The ending portion starting at line 22, will add entries to our dictionary. If we haven&rsquo;t already found an edge to <code>NODE</code>, then we will add the edge that we are currently on.</p>
<p>The other addition is the block of code from line 9 to 16. We will enter this <code>if</code> block if the node that we are currently at is the target. This means that we have finally found a path from the source node to the target node. The process in this segment of code will backtrack through the path and build the path.</p>
<h2 id="depth-first-search-dfs">Depth First Search (DFS)</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     STACK = empty array
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     append SRC to STACK
</span></span><span class="line"><span class="cl">6.     while STACK is not empty
</span></span><span class="line"><span class="cl">7.         CURR = top of the stack
</span></span><span class="line"><span class="cl">8.         if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">9.             if CURR is TAR
</span></span><span class="line"><span class="cl">10.                 PATH = empty array
</span></span><span class="line"><span class="cl">11.                 TRACE = TAR
</span></span><span class="line"><span class="cl">12.                 while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                     append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                     set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                 reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                 return PATH
</span></span><span class="line"><span class="cl">17.            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">18.            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">19.            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">20.                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">21.                append NODE to STACK
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.    return nothing</span></span></code></pre></div><h2 id="dfs-example">DFS Example</h2>
<p><a href="#R-image-11c452cd1e471013d775c68211213434" class="lightbox-link"><img alt="DFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/DFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11c452cd1e471013d775c68211213434"><img alt="DFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/DFS.gif"></a></p>
<h2 id="breadth-first-search-bfs">Breadth First Search (BFS)</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function BREADTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     QUEUE = empty queue
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">6.     add SRC to QUEUE
</span></span><span class="line"><span class="cl">7.     while QUEUE is not empty
</span></span><span class="line"><span class="cl">8.         CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">9.         if CURR is TAR 
</span></span><span class="line"><span class="cl">10.            PATH = empty list 
</span></span><span class="line"><span class="cl">11.            TRACE = TAR
</span></span><span class="line"><span class="cl">12.            while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                    append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                    set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                return PATH
</span></span><span class="line"><span class="cl">17.        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">18.        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">19.            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">20.            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">21.                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.                append NODE to QUEUE
</span></span><span class="line"><span class="cl">25.    return nothing</span></span></code></pre></div><h2 id="bfs-example">BFS Example</h2>
<p><a href="#R-image-e6811e5e6182c487ae91a5145e320ae1" class="lightbox-link"><img alt="BFS Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/BFS.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6811e5e6182c487ae91a5145e320ae1"><img alt="BFS Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/BFS.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="in-practice">In Practice</h1>

<h2 id="traveling">Traveling</h2>
<p>Finding a path in a graph is a very common application in many fields. One application that we benefit from in our day to day lives is traveling. Programs like Google Maps calculate various paths from point A to point B.</p>
<p><a href="#R-image-a970f92454517d78f20f43aa5a8f8df6" class="lightbox-link"><img alt="Google Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/Map.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a970f92454517d78f20f43aa5a8f8df6"><img alt="Google Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/Map.png"></a>^[google.com/maps]</p>
<p>In the context of graph data structures, we can think of each intersection as a node and each road as an edge. Google Maps, however, tracks more features of edges than we have discussed. Not only do they track the distance between intersections, they also track time, tolls, construction, road surface and much more. In the next module, we will discuss more details of how we can find the shortest path.</p>
<h2 id="map-coloring">Map Coloring</h2>
<p>Another application of the general searches is coloring maps. The premise is that we don&rsquo;t want two adjacent territories to have the coloring. These territories could be states, like in the United States map below, counties, provinces, countries, and much more.</p>
<p><a href="#R-image-c25f9901370f46e616518b25fae37b48" class="lightbox-link"><img alt="US Map" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/USMap.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c25f9901370f46e616518b25fae37b48"><img alt="US Map" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/USMap.png"></a>^[https://commons.wikimedia.org/wiki/File:Map_of_USA_showing_state_names.png]</p>
<p>The following was generated for this course using the breadth first search and <code>MyMatrixGraph</code> class that we have implemented in this course. To create the visual rendering, the Python library <code>NetworkX</code>^[https://networkx.github.io/] was used. In this rendering, the starting node was Utah. If we were to start from say Alabama or Florida, we would not have a valid four coloring scheme once we got to Nevada. Since Hawaii and Alaska have no land border with any of the states, they can be any color.</p>
<p><a href="#R-image-3ca9afb8983f47e371f2ee75dde0a392" class="lightbox-link"><img alt="Color Generation" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/8/UsMapColor.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ca9afb8983f47e371f2ee75dde0a392"><img alt="Color Generation" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/8/UsMapColor.gif"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 45</div>

<h1 id="graphs-minimum-spanning-trees">Graphs: Minimum Spanning Trees</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Graphs: Minimum Spanning Trees</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Graphs: Minimum Spanning Trees</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=Rtlwi7b_PF8">YouTube Video</a>

<p>We will continue to work with graph algorithms in this module, specifically with finding minimum spanning trees (MST). MSTs have many real world applications such as:</p>
<ul>
<li>Electrical wiring,</li>
<li>Distribution networks,</li>
<li>Telecommunication networks, and</li>
<li>Network routing</li>
</ul>
<p>Suppose we were building an apartment complex and wanted to determine the most cost-effective wiring schema. Below, we have the possible construction costs for wiring apartment to apartment. Wiring vertically adjacent apartments is cheaper than wiring horizontally adjacent units and those closest to the power closet have lower costs as well.
<a href="#R-image-8c9eda662054f301774efbaaaf955afd" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8c9eda662054f301774efbaaaf955afd"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/possibe_wiring.svg"></a></p>
<p>To find the best possible solution, we would find the MST. The final wiring schema may look something like the figure below.
<a href="#R-image-7c791a73f23544e8d38cbbdcb40cb830" class="lightbox-link"><img alt="Possible Wiring" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/mini_wire.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c791a73f23544e8d38cbbdcb40cb830"><img alt="Possible Wiring" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/mini_wire.svg"></a></p>
<p>Determining a MST can result in lower costs and time used in many applications, especially logistics.
To properly define a minimum spanning tree, we will first introduce the concept of a spanning tree.</p>
<h2 id="spanning-trees">Spanning Trees</h2>
<p>A <strong>spanning tree</strong> for a graph is a subset of the graphs edges such that each node is visited once, no cycles are present, and there are no disconnected components.</p>
<p>Let&rsquo;s look at this graph as an example. We have five nodes and seven edges.</p>
<p><a href="#R-image-ecdc14a437842a41d31faeab54e7235b" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ecdc14a437842a41d31faeab54e7235b"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below, we have valid examples of spanning trees. In each of the examples, we visit each node and there are no cycles. Recall that a cycle is a path in which the starting node and ending node are the same.</p>
<p><a href="#R-image-90ae3da7dad329ec12862d3fe0dd86c1" class="lightbox-link"><img alt="Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90ae3da7dad329ec12862d3fe0dd86c1"><img alt="Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STs.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>To be a spanning tree of a graph, it must:</p>
<ul>
<li><strong>span</strong> the graph, meaning all nodes must be visited, and</li>
<li>be a <strong>tree</strong>, meaning there are no cycles and no disconnected components.</li>
</ul>
<p>Further, we can imagine selecting a node in a spanning tree as the root and letting gravity take effect. This gives us a visual motivation as to why they are called spanning trees. In these examples, we have selected node A for the root for each of the spanning trees above.</p>
<p><a href="#R-image-76c03edbdf7d2140997804f67ebdc553" class="lightbox-link"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76c03edbdf7d2140997804f67ebdc553"><img alt="Spanning Trees as Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1STsTREES.svg"></a></p>
</div>
</div>
<h2 id="counterexamples">Counterexamples</h2>
<p>Below, we have invalid examples of spanning trees. In the left column, the examples are where all of the nodes are not connected in the same component. In the right column, the examples contain cycles. For example in the top right, we have the cycle <code>B-&gt;C-&gt;D-&gt;E-&gt;B</code></p>
<p><a href="#R-image-7faf8765855090da021267d078230949" class="lightbox-link"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7faf8765855090da021267d078230949"><img alt="Not Spanning Trees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1notSTs.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="minimum-spanning-trees">Minimum Spanning Trees</h1>


<a href="https://www.youtube.com/watch?v=sMo3sTRoVrE">YouTube Video</a>

<p>Now that we have an understanding of general spanning trees, we will introduce the concept of minimum spanning trees. First let&rsquo;s introduce the concept of the cost of a tree.</p>
<p>The <strong>cost</strong> that is associated with a tree, is the sum of its edges weights. Let&rsquo;s look at this spanning tree which is from the previous page. The cost associated with this spanning tree is: <code>2+6+10+14=32</code>.
<a href="#R-image-5099f22c686b1cab603cd3dae07a4eea" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5099f22c686b1cab603cd3dae07a4eea"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_cost.svg"></a></p>
<h2 id="minimum-spanning-trees-mst">Minimum Spanning Trees (MST)</h2>
<p>A <strong>minimum spanning tree</strong> is a spanning tree that has the smallest cost. Recall the graph from the previous page.</p>
<p><a href="#R-image-5172e5eb1cf105c85eb4586da8b53598" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5172e5eb1cf105c85eb4586da8b53598"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1.svg"></a></p>
<p>Below on the left is a minimum spanning tree for the graph above. On the right is an example of a spanning tree, though it does not have the minimum cost.</p>
<p><a href="#R-image-414e86b34ccfb3b8efec15cf6e32933a" class="lightbox-link"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-414e86b34ccfb3b8efec15cf6e32933a"><img alt="Minimum Spanning Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_tree1MST.svg"></a></p>
<p>In this small example, it is rather straightforward to find the minimum spanning tree. We can use a bit of trial and error to determine if we have the minimum spanning tree or not. However, once the graphs start to get more nodes and more edges it quickly becomes more complicated.</p>
<p><a href="#R-image-2008a6cfe70e9469d9dd97b34968c2bd" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2008a6cfe70e9469d9dd97b34968c2bd"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9lrgTree.svg"></a></p>
<p>There are two algorithms that we will introduce to give us a methodical way of finding the minimum spanning tree. The first that we will look at is Kruskal&rsquo;s algorithm and then we will look at Prim&rsquo;s algorithm.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="kruskal">Kruskal</h1>


<a href="https://www.youtube.com/watch?v=av-r-orP56g">YouTube Video</a>

<p>As graphs get larger, it is important to go about finding the MST in a methodical way. In the mid 1950&rsquo;s, there was a desire to form an algorithmic approach for solving the &rsquo;traveling salesperson&rsquo; problem^[We will describe this problem in a future section of this module]. Joseph Kruskal first published this algorithm in 1956 in the Proceedings of the American Mathematical Society^[https://www.ams.org/journals/proc/1956-007-01/S0002-9939-1956-0078686-7/S0002-9939-1956-0078686-7.pdf]. The algorithms prior to this were, as Kruskal said, &ldquo;unnecessarily elaborate&rdquo; thus the need for a more succinct algorithm arose.</p>
<h2 id="algorithm">Algorithm</h2>
<p>In his original work, Kruskal outlined three different yet similar algorithms to finding a minimum spanning tree. The <code>Kruskal Algorithm</code> that we use is as follows:</p>
<ol>
<li>Start with only the nodes of the graph and an empty set for the edges</li>
<li>Order the edges based on weight</li>
<li>Make each node their own set</li>
<li>Go through the edges in ascending order</li>
<li>If nodes <code>u</code> and <code>v</code> are connected by the edge and they are not in the same set yet, then join the two sets and add the edge to your set of edges</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-b734a7c9f7af18ee25c84e32756ec81d" class="lightbox-link"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b734a7c9f7af18ee25c84e32756ec81d"><img alt="Kruskal Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-1d5354a10d54ddb2790a8b6b74e50dfa" class="lightbox-link"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/kruskal.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d5354a10d54ddb2790a8b6b74e50dfa"><img alt="Kruskal Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/kruskal.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-b3141efbf7258510661b9690e3976b12" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3141efbf7258510661b9690e3976b12"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></p>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function KRUSKAL(GRAPH)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    ALLSETS = an empty list which will contain the sets
</span></span><span class="line"><span class="cl">    for NODE in GRAPH NODES
</span></span><span class="line"><span class="cl">        SET = a set with element NODE
</span></span><span class="line"><span class="cl">        add SET to ALLSETS
</span></span><span class="line"><span class="cl">    EDGES = list of GRAPH&#39;s edges
</span></span><span class="line"><span class="cl">    SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span class="line"><span class="cl">    for EDGE in SORTEDEDGES
</span></span><span class="line"><span class="cl">        SRC = source node of EDGE
</span></span><span class="line"><span class="cl">        TAR = target node of EDGE
</span></span><span class="line"><span class="cl">        SRCSET = the set from SETS in which SRC is contained
</span></span><span class="line"><span class="cl">        TARSET = the set form SETS in which TAR is contained
</span></span><span class="line"><span class="cl">        if SRCSET not equal TARSET
</span></span><span class="line"><span class="cl">            UNIONSET = SRCSET union TARSET
</span></span><span class="line"><span class="cl">            add UNIONSET to ALLSETS
</span></span><span class="line"><span class="cl">            remove SRCSET from ALLSETS
</span></span><span class="line"><span class="cl">            remove TARSET from ALLSETS
</span></span><span class="line"><span class="cl">            add EDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="prim">Prim</h1>


<a href="https://www.youtube.com/watch?v=B9bG6FTj5pA">YouTube Video</a>

<p>The history of <code>Prim's Algorithm</code> is not as straight forward as Kruskal&rsquo;s. While we often call it <code>Prim's Algorithm</code>, it was originally developed in 1930 by VojtÄ›ch JarnÃ­k. Robert Prim later rediscovered and republished this algorithm in 1957, one year after Kruskals. To add to the naming confusion, Edsger Dijkstra also published this work again in 1959. Because of this, the algorithm can go by many names: <code>JarkÃ­k's Algorithm</code>, <code>JarnÃ­k-Prim's Algorithm</code>, <code>Prim-Dijkstra's Algorithm</code>, and <code>DJP Algorithm</code>.</p>
<p>Prim cited &ldquo;large-scale communication&rdquo; as the motivation for this algorithm, specifically the &ldquo;Bell System leased-line&rdquo;^[R.C. Prim, May 8, 1957 Shortest Connection Networks And Some Generalizations https://archive.org/details/bstj36-6-1389]. Leased lines were used primarily in a commercial setting which connected business offices that were geographically distant (IE in different cities or even states). Companies would want all offices to be connected but wanted to avoid having to lay an excessive amount of wire. Below is a figure which Prim used to motivate the need for the algorithm. This image depicts the minimum spanning tree which connect each of the US continental state capitals along with Washington D.C.</p>
<p><a href="#R-image-efe8bead36361e00448b13aa4dca0f39" class="lightbox-link"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim_US.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-efe8bead36361e00448b13aa4dca0f39"><img alt="Prim&rsquo;s Motivation" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim_US.png"></a></p>
<h2 id="algorithm">Algorithm</h2>
<p>The basis of the algorithm is to start with only the nodes of the graph, then we do the following</p>
<ol>
<li>Choose a random node</li>
<li>Grow your tree by one edge, selecting the smallest edge to connect to a node that is not yet in the tree. Repeat until all the nodes have been visited</li>
</ol>
<h2 id="starting-graph">Starting Graph</h2>
<p><a href="#R-image-5a0aadd8df5cd9ff84398aa895c86390" class="lightbox-link"><img alt="Prim Example Start" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5a0aadd8df5cd9ff84398aa895c86390"><img alt="Prim Example Start" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Lex.svg"></a></p>
<p><a href="#R-image-ff7645d235f2596ae894d47222ce3062" class="lightbox-link"><img alt="Prim Example GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/prim.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff7645d235f2596ae894d47222ce3062"><img alt="Prim Example GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/prim.gif"></a></p>
<h2 id="resulting-mst">Resulting MST</h2>
<p><a href="#R-image-a7d5cc2bf1fc4cec24a684c4fa510dc0" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a7d5cc2bf1fc4cec24a684c4fa510dc0"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Uniqueness</strong></p>
<p>You may have noticed that the minimum spanning tree that resulted from Kruskal&rsquo;s algorithm differed from Prim&rsquo;s algorithm. We have displaying them both below for reference.</p>
<table>
<thead>
<tr>
<th>Kruskal</th>
<th>Prim</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#R-image-0f0d9a4d8a0d2b88a98ddd5fce068d14" class="lightbox-link"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f0d9a4d8a0d2b88a98ddd5fce068d14"><img alt="Kruskal Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Kdone.svg"></a></td>
<td><a href="#R-image-eeeb8c54d5312fd8bb5e2a24f7fa57ff" class="lightbox-link"><img alt="Prim Example Result" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-eeeb8c54d5312fd8bb5e2a24f7fa57ff"><img alt="Prim Example Result" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/315_9_Pdone.svg"></a></td>
</tr>
</tbody>
</table>
<p>While these are different, they are both valid. The trees both have cost 16. The MST of a graph will be unique, meaning there is only one, if none of the edges of the graph have the same weight.</p>
</div>
</div>
<h2 id="pseudocode">Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRIM(GRAPH, START)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    VISITED = empty set
</span></span><span class="line"><span class="cl">    add START to VISITED
</span></span><span class="line"><span class="cl">    AVAILEDGES = list of edges where START is the source
</span></span><span class="line"><span class="cl">    sort AVAILEDGES
</span></span><span class="line"><span class="cl">    while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">        SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">        SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">        if TAR not in VISITED
</span></span><span class="line"><span class="cl">            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">            add TAR to VISITED
</span></span><span class="line"><span class="cl">            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">        sort AVAILEDGES
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="traveling-salesperson">Traveling Salesperson</h1>


<a href="https://www.youtube.com/watch?v=txzR-tM6z7M">YouTube Video</a>


<a href="https://www.youtube.com/watch?v=OPvOpQ6w734">YouTube Video</a>

<p>While we won&rsquo;t outline algorithms suited for solving the traveling salesperson problem (TSP), we will outline the premise of the problem. This problem was first posed in 1832, almost a two centuries ago, and is still quite prevalent. It is applicable to traveling routes, distribution networks, computer architecture and much more. The TSP is a seminal problem that has motivated many research breakthroughs, including Kruskals algorithm!</p>
<p>The motivation of the TSP is this: given a set of locations, what is the shortest path such that we can visit each location and end back where started?</p>
<p>Suppose we wanted to take a roadtrip with friends to every state capital in the continental US as well as Washington D.C. To save money and time, we would want to minimize the distance that we travel. Since we are taking a roadtrip, we would want to avoid frivolous driving. For example, if we start in Sacremento, CA we would not want to end the trip in Boston, MA. The trip should start and end at the same location for efficiency.</p>
<p>The figure below shows the shortest trip that visits each state capital and Washington D.C. once. In this example, we can start where ever we like and will end up where we started.
<a href="#R-image-6df828c24d59a56efc97372cb26aa4d3" class="lightbox-link"><img alt="Visit each state capital" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6df828c24d59a56efc97372cb26aa4d3"><img alt="Visit each state capital" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/9/7_TSP_TOUR.png"></a>^[PatriciaNeri, August 2018 https://communities.sas.com/t5/SAS-Communities-Library/What-is-the-shortest-tour-that-visits-only-once-the-48/ta-p/490231]</p>
<p>In this problem, it is easy to get overwhelmed by all of the possibilities. Since there are 49 cities to visit, there are over <code>6.2*10^60</code> possibilities. For reference, <code>10^12</code> is equivalent to one trillion! Thus, we need an algorithmic approach to solve this problem as opposed to a brute force method.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="iv-priority-queues">Iv-Priority-Queues</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Iv-Priority-Queues</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 50</div>

<h1 id="heaps-and-priority-queues">Heaps and Priority Queues</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Heaps and Priority Queues</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Heaps and Priority Queues</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=QEFyC0gGc_E">YouTube Video</a>

<p>The next data structure we will cover is heaps. The heaps discussed in this course are not to be confused with heaps which refer to garbage collection in certain coding languages. Heaps are good for situations were we will need to frequently access and update the highest (or lowest) priority item in a set. For example, heaps are a good data structure to use in Prim&rsquo;s algorithm. In Prim&rsquo;s algorithm, we repeatedly got the smallest edge, removed the smallest edge, and then added to and sorted the list of edges.</p>
<h2 id="heap-properties">Heap Properties</h2>
<p>A heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:</p>
<ol>
<li>Each node has at most two children.</li>
<li>If there are nodes in level <code>i</code> of the tree, then level <code>i-1</code> is full. Below we have an example of how this property has been broken. Level two is not full but there are nodes on level three.
<a href="#R-image-e6e50cda33eda98e70d1753da04b54e0" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/Mod10_ex_full_level.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6e50cda33eda98e70d1753da04b54e0"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/Mod10_ex_full_level.svg"></a></li>
<li>The nodes of the last level are as far left as possible. Below we have an example of how this property has been broken.</li>
</ol>
<p><a href="#R-image-31efff6d3ea94dba4668a53794c0c755" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/Mod10_ex_left.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31efff6d3ea94dba4668a53794c0c755"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/Mod10_ex_left.svg"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>As a consequence of the above properties, the following is true as well: Only one node can have one child, all other nodes will have zero or two children. Try to construct a counterexample to see what we mean!</p>
</div>
</div>
<h2 id="types-of-heaps">Types of Heaps</h2>
<p>There are two main types of heaps, the max-heap and the min-heap. Depending on the element we want to access we may use one or the other.</p>
<p>A <strong>max-heap</strong> is a heap such that the parent node is greater than or equal to the children. For example, if we are using a heap to track work flow,we would want to use a max-heap. In this case, the highest priority element will always be the root of the tree.</p>
<p>A <strong>min-heap</strong> is a heap such that the parent node is less than or equal to the children. This is the opposite of the max-heap. The root of this heap will be the item with the lowest priority. A min-heap may feel unnatural at first, however, this is ideal for greedy algorithms such as Prim&rsquo;s algorithm. We are frequently getting the smallest edge.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-relationships">Node Relationships</h1>


<a href="https://www.youtube.com/watch?v=TZZiihhBXco">YouTube Video</a>

<p>Heaps can be viewed in two forms: as a tree or as an array. We will use the array style in code but we can have the tree structure in the back of our mind to help understand the order of the data. Here is an example of the heap as a tree on the left and the heap as an array on the right.
<a href="#R-image-c0232e619b0bb16401dc7bec08f0ae67" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/Mod10_heap_and_array_numbered.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c0232e619b0bb16401dc7bec08f0ae67"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/Mod10_heap_and_array_numbered.svg"></a>
The root of the heap will always be the first element. Then we can base the numbering of the following nodes from left to right and top to bottom. For example, the left child of the root will be the second entry and the right child will be the third.</p>
<h2 id="accessing-indexes">Accessing Indexes</h2>
<p>For full functionality of our heap, we want to be able to easily determine the parent of a node as well as the children of a node.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Critical Thinking</strong></p>
<p>Using just the array, how can we determine the parent of a node? In the example above, how can we determine the parent of the node with value 18?</p>
</div>
</div>
<p>We can formulate the relationships between parent and children nodes mathematically. For a node at index <code>i</code>, we can say that the left child of <code>i</code> will be at index <code>2i</code> and the right child will be at <code>2i+1</code>. Similarly, we can say that the parent of node <code>i</code> will be at index <code>floor(i/2)</code>.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>The function <code>floor(x)</code> like in <code>floor(i/2)</code> will round decimal values down to the next whole number. Some examples:</p>
<ul>
<li><code>floor(3.2)=3</code></li>
<li><code>floor(1.9999)=1</code></li>
<li><code>floor(4)=4</code></li>
</ul>
</div>
</div>
<p><a href="#R-image-fd3404123e5fa14e7edb3e6fae857ae2" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/heap_numbering.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fd3404123e5fa14e7edb3e6fae857ae2"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/heap_numbering.svg"></a></p>
<table>
<thead>
<tr>
<th>Node</th>
<th>Parent</th>
<th>Left Child</th>
<th>Right Child</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td><code>floor(i/2)</code></td>
<td><code>2i</code></td>
<td><code>2i + 1</code></td>
</tr>
<tr>
<td>1</td>
<td>N/A</td>
<td><code>2*1=2</code></td>
<td><code>2*1+1=3</code></td>
</tr>
<tr>
<td>2</td>
<td><code>floor(2/2)=1</code></td>
<td><code>2*2=4</code></td>
<td><code>2*2+1=5</code></td>
</tr>
<tr>
<td>3</td>
<td><code>floor(3/2)=1</code></td>
<td><code>2*3=6</code></td>
<td><code>2*3+1=7</code></td>
</tr>
<tr>
<td>4</td>
<td><code>floor(4/2)=2</code></td>
<td><code>2*4=8</code></td>
<td><code>2*4+1=9</code></td>
</tr>
<tr>
<td>5</td>
<td><code>floor(5/2)=2</code></td>
<td><code>2*5=10</code></td>
<td><code>2*5+1=11</code></td>
</tr>
<tr>
<td>Try it!</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<p>Consider the following example and try to work some out for yourself.</p>
<p><a href="#R-image-789e46972944a7dec51585453e865b8f" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/Mod10_justarray.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-789e46972944a7dec51585453e865b8f"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/Mod10_justarray.svg"></a></p>
<p>For example, if we ask for the parent of the node with value 27, our answer would be the node with value 35 The node with value 27 has index 5. Thus, the parent of that node will have index <code>floor(5/2)=2</code>. Node 35 is at index two, as such, node 35 is the parent of node 27.</p>
<details><summary markdown="span">Left child of the node with value 24:</summary>The node with value three. Node 24 has index 4, so the left child will be at index 2*4=8. That corresponds to the node with value 3.</details>
<details><summary markdown="span">Right child of the node with value 44:</summary>The node with value twelve. Node 44 has index 3, so the right child will be at index (2*3)+1=7. That corresponds to the node with value 12.</details>
<details><summary markdown="span">Parent of the node with value 36:</summary>The node with value forty-four. Node 36 has index 6, so the parent will be at index floor(6/2)=3. That corresponds to the node with value 44.</details>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>In a heap where <code>n</code> is the size of heap, the elements <code>floor(n/2)+1</code> through <code>n</code> will always be leaves. If we assume that we have just the 12 elements in this example, then based on this formula, elements 7 through 12 must be leaves. We can verify this in the tree representation!
<a href="#R-image-c1fc4acfccddebabf293b6b1ffb9babb" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/heap_numbering.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1fc4acfccddebabf293b6b1ffb9babb"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/heap_numbering.svg"></a></p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="priority-queues">Priority Queues</h1>


<a href="https://www.youtube.com/watch?v=D1t017tFAvA">YouTube Video</a>

<p>A natural implementation of heaps is priority queues.</p>
<p>A <strong>priority queue</strong> is a data structure which contains elements and each element has an associated key value. The key for an element corresponds to its importance. In real world applications, these can be used for prioritizing work tickets, emails, and much more.
<a href="#R-image-2beed02ef6cde5c8b6ea076879c0a414" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/todo_bubble.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2beed02ef6cde5c8b6ea076879c0a414"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/todo_bubble.svg"></a></p>
<p>We can use a heap to organize this data for us.</p>
<p><a href="#R-image-b79a01e338ab58db7836c832bb5f49c1" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b79a01e338ab58db7836c832bb5f49c1"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg"></a></p>
<p>As with heaps, we can have min-priority queues and max-priority queues. For the applications listed above, a max-priority queue is the most intuitive choice. For this course however, we will focus more on min-priority queues which will give us better functionality for greedy algorithms, like Prim&rsquo;s algorithm.</p>
<h2 id="prims-revisited">Prim&rsquo;s Revisited</h2>
<p>For the minimum spanning tree algorithms, using a min-priority queue helps the performance of the algorithms. Recall Prim&rsquo;s algorithm, shown below. Each time we visited a new node, we would add the outgoing edges to the list of available edges, remove the smallest edge, and sort the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRIM(GRAPH, SRC)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    VISITED = empty set
</span></span><span class="line"><span class="cl">    add SRC to VISITED
</span></span><span class="line"><span class="cl">    AVAILEDGES = list of edges where SRC is the source
</span></span><span class="line"><span class="cl">    sort AVAILEDGES
</span></span><span class="line"><span class="cl">    while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">        SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">        SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">        if TAR not in VISITED
</span></span><span class="line"><span class="cl">            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">            add TAR to VISITED
</span></span><span class="line"><span class="cl">            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">        sort AVAILEDGES
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div><p>If we implement Prim&rsquo;s algorithm with min-priority queue, we don&rsquo;t have to worry about sorting the edges every time we add or remove one.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRIM(GRAPH, SRC)
</span></span><span class="line"><span class="cl">    MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">    VISITED = empty set
</span></span><span class="line"><span class="cl">    add SRC to VISITED
</span></span><span class="line"><span class="cl">    AVAILEDGES = min-PQ of edges where SRC is the source
</span></span><span class="line"><span class="cl">    while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">        SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">        SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">        if TAR not in VISITED
</span></span><span class="line"><span class="cl">            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">            add TAR to VISITED
</span></span><span class="line"><span class="cl">            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">    return MST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="functionality">Functionality</h1>


<a href="https://www.youtube.com/watch?v=z1q2XXfWttA">YouTube Video</a>

<p><a href="#R-image-cfc68be22767210a6c00f4f1a3c21b69" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/guides_img_pythonpquml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cfc68be22767210a6c00f4f1a3c21b69"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/guides_img_pythonpquml.png"></a></p>
<h2 id="attributes">Attributes</h2>
<p>The priority queue will have a single attribute which will be the array to represent the priority queue as a heap. Elements of this array will be ordered pairs where the first entry is the priority and the second entry is the node item.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Since arrays start at index zero, we will set the first element equal to a null value and the element at index 1 will be the start of our priority queue.
<a href="#R-image-6772eb7692c6b7b245d6fae92529eb79" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/null_at_zero.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6772eb7692c6b7b245d6fae92529eb79"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/null_at_zero.svg"></a></p>
</div>
</div>
<h2 id="size">Size</h2>
<p>Similar to graphs, heaps will have a size which will be the number of elements currently in our heap.</p>
<h2 id="push">Push</h2>
<p>The <code>PUSHDOWN</code> and <code>PUSHUP</code> functions will help us to maintain the heap structure. In their own ways, described below, they will correct the ordering of nodes. Primarily making it such that the parent is always smaller then its children. Both of these will be recursive functions.</p>
<ul>
<li><code>PUSHUP</code>: This function takes an index as input and then determines if the element at that index has a lower priority than its parent. This will &lsquo;raise&rsquo; the element up through heap and move it closer to the front of the array.
<ul>
<li>Base Case: There are two base cases for <code>PUSHUP</code>. The first is if the element has greater priority than its parent, then we do nothing as the structure is correct. The second is if the index of the parent node is 0, then we do nothing as we have reached the root of the heap.</li>
<li>Recursive Case: When we are not at the root and the child has lower priority than the parent, then we will swap the parent element and the child element in the priority queue&rsquo;s array. Then we will call the <code>PUSHUP</code> function with the parent index as input.</li>
</ul>
</li>
<li><code>PUSHDOWN</code>: Similar to <code>PUSHUP</code> this function will take an index as input but will now determine if the node has higher priority than one of its children. This will &rsquo;trickle&rsquo; the element down through the heap and move it closer to the end of the array.
<ul>
<li>Base Case: There are two cases for <code>PUSHDOWN</code>. The first is if the the parent has lower priority than both of its children, then we do nothing as the structure is correct. The second is if the index of both children are out of the range of our array, then we do nothing as we have reached a leaf.</li>
<li>Recursive Case: When we are not at a leaf and at least one child has lower priority than the parent, then we will recurse. We will break this down into further cases for clarity.
<ul>
<li>Parent has a Right Child: If the priority of the left child is less than the priority of the right child, then we check the priority of the left child compared to the parent. If the left child has lower priority than the parent, then we swap the parent and the left child in the array and recurse on the left child. If the priority of the left child is not less than the priority of the right child, then we check the priority of the right child compared to the parent. If the right child has lower priority than the parent, then we swap the parent and the right child in the array and recurse on the right child.</li>
<li>Parent only has a Left Child: If the priority of the left child is less than the parent&rsquo;s priority, then swap the left child and the parent in the array and then recurse on the left child.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="remove-min">Remove Min</h2>
<p>This will remove the lowest priority element from our priority queue. If our priority queue only has one element, then we will just remove the element. However, if there is more than the single element, we will need to do some maintenance to make sure the lowest priority element is the root again. To do this, we will take the last element of the priority queue and make it the root. Then we will use the <code>PUSHDOWN</code> function to reorder the nodes.</p>
<h2 id="heapify">Heapify</h2>
<p>The <code>HEAPIFY</code> function will allow us to translate our data into a heap. It will take as input a list of priorities and a list of items. Suppose in the figure below, we are calling Prim&rsquo;s function from node 1. Thus, we want to start our heap with the outgoing edges of node 1. We will input the list of priorities, which in this case are the edge weights, and the list of the items. For this application, we have made the items ordered pairs where the first entry is the source node and the second is the target.
<a href="#R-image-8b4e104c0331a0df0475214bde496f47" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/heapify.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8b4e104c0331a0df0475214bde496f47"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/heapify.svg"></a></p>
<p>Since we are working primarily with min-priority queues, we will define <code>HEAPIFY</code> in those terms. Though, we could have an equivalent function for a max-priority queue.</p>
<p>For input, the function takes <code>RANKS</code> which is the array representation of our priority values and <code>ITEMS</code> which is the array representation of the items.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function HEAPIFY(RANKS, ITEMS)
</span></span><span class="line"><span class="cl">    if RANKS and ITEMS are the same size
</span></span><span class="line"><span class="cl">        SIZE = length of ITEMS
</span></span><span class="line"><span class="cl">        loop INDEX starting at 1 to SIZE
</span></span><span class="line"><span class="cl">            I<span class="nb">_</span>RANK = value at INDEX in RANKS
</span></span><span class="line"><span class="cl">            I<span class="nb">_</span>ITEM = item at INDEX of ITEMS 
</span></span><span class="line"><span class="cl">            append (I<span class="nb">_</span>RANK, I<span class="nb">_</span>ITEM) to priority queues array
</span></span><span class="line"><span class="cl">        QSIZE = length of our PQ - 1
</span></span><span class="line"><span class="cl">        LASTPARENT = floor(QSIZE/2) + 1
</span></span><span class="line"><span class="cl">        loop NODE starting at LASTPARENT down to 1
</span></span><span class="line"><span class="cl">            PUSHDOWN(NODE)
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        error</span></span></code></pre></div><h2 id="insert">Insert</h2>
<p>The <code>INSERT</code> function is similar to <code>HEAPIFY</code> but now we are just wanting to insert a single element. As such, <code>INSERT</code> will take the priority of the element and the element as input. We will append the ordered pair of <code>(priority, element)</code> to our priority queue array and then call the <code>PUSHUP</code> function on the last element of the array.</p>
<h2 id="heap-decrease-key">Heap Decrease Key</h2>
<p>The <code>DECREASEKEY</code> function allows us to update the priority of an element. It takes as input the array index for heap entry to update as well as the priority we will be giving the element. We first check if that the new priority is in fact less than the original. Then we update the priority and then push the element up.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">DECREASEKEY(IDX, PRIORITY)
</span></span><span class="line"><span class="cl">    ELEMENT = entry in array at IDX
</span></span><span class="line"><span class="cl">    if PRIORITY &gt; ELEMENT[0]
</span></span><span class="line"><span class="cl">        error
</span></span><span class="line"><span class="cl">    ELEMENT[0] = PRIORITY 
</span></span><span class="line"><span class="cl">    PUSHUP(IDX)
</span></span><span class="line"><span class="cl">   </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="dijkstras">Dijkstras</h1>


<a href="https://www.youtube.com/watch?v=c_JKrX7QyX4">YouTube Video</a>

<p><a href="https://core.cs.ksu.edu/4-cc315/10-pq/05-pq-dijkstra-alg-slides/" rel="external" target="_blank">Video Slides</a></p>
<p>A good application of priority queues is finding the shortest path in a graph. A common algorithm for this is Dijkstra&rsquo;s algorithm.</p>
<p>Edsger Dijkstra was a Dutch computer scientist who researched many fields. He is credited for his work in physics, programming, software engineering, and as a systems scientist. His motivation for this algorithm in particular was to be able to find the shortest path between two cities.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>&ldquo;What is the shortest way to travel from Rotterdam to Groningen, in general: from given city to given city? It is the algorithm for the shortest path, which I designed in about twenty minutes. One morning I was shopping in Amsterdam with my young fiancÃ©e, and tired, we sat down on the cafÃ© terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path.&rdquo;
- Edsger Dijkstra, Communications of the ACM 53 (8), 2001.</p>
</div>
</div>
<p>His original algorithm was defined for a path between two specific cities. Since its publication, modifications have been made to the algorithm to find the shortest path to every node given a source node.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">DIJKSTRAS(GRAPH, SRC)
</span></span><span class="line"><span class="cl">    SIZE = size of GRAPH
</span></span><span class="line"><span class="cl">    DISTS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">    PREVIOUS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">    set all of the entries in PREVIOUS to none
</span></span><span class="line"><span class="cl">    set all of the entries in DISTS to infinity 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    DISTS[SRC] = 0 
</span></span><span class="line"><span class="cl">    PQ = min-priority queue
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    loop IDX starting at 0 up to SIZE
</span></span><span class="line"><span class="cl">        insert (DISTS[IDX],IDX) into PQ
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while PQ is not empty
</span></span><span class="line"><span class="cl">        MIN = REMOVE-MIN from PQ
</span></span><span class="line"><span class="cl">        for NODE in neighbors of MIN
</span></span><span class="line"><span class="cl">            WEIGHT = graph weight between MIN and NODE
</span></span><span class="line"><span class="cl">            CALC = DISTS[MIN] + WEIGHT
</span></span><span class="line"><span class="cl">            if CALC &lt; DISTS[NODE]
</span></span><span class="line"><span class="cl">                DISTS[NODE] = CALC
</span></span><span class="line"><span class="cl">                PREVIOUS[NODE] = MIN
</span></span><span class="line"><span class="cl">                PQIDX = index of NODE in PQ
</span></span><span class="line"><span class="cl">                PQ decrease-key (PQIDX, CALC)
</span></span><span class="line"><span class="cl">    return DISTS and PREVIOUS</span></span></code></pre></div><p><a href="#R-image-409acfe42d2b2eb895dccc2c67363d7b" class="lightbox-link"><img alt="Animated demo of Dijkstras Algorithm" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/DijkstraDemo.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-409acfe42d2b2eb895dccc2c67363d7b"><img alt="Animated demo of Dijkstras Algorithm" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/DijkstraDemo.gif"></a>^[Shiyu Ji, CC BY-SA 4.0 <a href="https://creativecommons.org/licenses/by-sa/4.0" rel="external" target="_blank">https://creativecommons.org/licenses/by-sa/4.0</a>, via Wikimedia Commons, https://upload.wikimedia.org/wikipedia/commons/e/e4/DijkstraDemo.gif]</p>
<p>Aside from just finding routes for us to travel, Dijkstra&rsquo;s algorithm can accommodate for any application that can have an abstraction to finding the shortest path. For example, the following animation shows how a robot could utilize Dijkstra&rsquo;s algorithm to find the shortest path with an obstacle in the way. In this example, each node could represent one square foot of floor space and the edges would represent those spaces that are adjacent. In this scenario, we would most likely not have an associated edge weight. If the robot were traversing on a rugged terrain, then we could have the weights represent the difficultly of passing through the terrain from one space to the other.
<a href="#R-image-99f4474dea7391d82f3ad41c01bc801e" class="lightbox-link"><img alt="Robot Path Mapping" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/Dijkstras_progress_animation.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-99f4474dea7391d82f3ad41c01bc801e"><img alt="Robot Path Mapping" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/Dijkstras_progress_animation.gif"></a>^[Subh83, CC BY 3.0 <a href="https://creativecommons.org/licenses/by/3.0" rel="external" target="_blank">https://creativecommons.org/licenses/by/3.0</a>, via Wikimedia Commons, https://commons.wikimedia.org/wiki/File:Dijkstras_progress_animation.gif]</p>
<p>Another practical abstraction is in network routing. In this simplified abstraction, nodes would be routers or switches and the edges would be the physical links between them. The edge weights in this case would be the cost of sending a packet from one router to the next. Dijkstra&rsquo;s algorithm is actively used in protocols such as Intermediate System to Intermediate System (IS-IS) and Open Shortest Path First (OSPF).</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="v-requirements-analyses">V-Requirements-Analyses</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of V-Requirements-Analyses</h1>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 55</div>

<h1 id="performance">Performance</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Performance</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Performance</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="module-outline">Module Outline</h1>


<a href="https://www.youtube.com/watch?v=OXNdQbHvj8U">YouTube Video</a>

<p>In this module, we will reintroduce the data structures that we have seen and implemented throughout CC315 as well as CC310. We will discuss the running time for various operations as well as space requirements for each structure.</p>
<p>You may recall that in CC310, we did a similar comparison. We will use most of the same operations from that module so we can draw comparisons between the structures in CC310 and CC315.</p>
<ul>
<li><strong>Insert</strong> â€“ inserting a specific element into the structure, either in sorted order, or at the appropriate place as required by the definition of the data structure.</li>
<li><strong>Access</strong> â€“ accessing a desired element. For general data structures, this is the process of accessing an element by its index or key in the structure. For stacks and queues, this was the process of accessing the next element to be returned.</li>
<li><strong>Find</strong> â€“ this is the process of finding a specific element in the data structure, usually by iterating through it or using a search method if the structure is ordered in some way.</li>
<li><strong>Delete</strong> â€“ this is the process of deleting a specific element in the case of a general-purpose structure or deleting and returning the next element in the case of a stack or queue. For more advanced structures, this may also require the structure to be reorganized a bit.</li>
</ul>
<p>We will also also discuss the memory required for each structure.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="trees">Trees</h1>


<a href="https://www.youtube.com/watch?v=ygzji6IOd18">YouTube Video</a>

<p>There are three types of trees to consider: generic trees, tries, and binary trees.</p>
<h3 id="general-trees">General Trees</h3>
<p><a href="#R-image-8d11e1c26a36802d104247e6786247f1" class="lightbox-link"><img alt="Tree" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8d11e1c26a36802d104247e6786247f1"><img alt="Tree" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/2/2Tree_Implementation.svg"></a></p>
<ul>
<li>
<p><strong>Insert</strong>: In general, inserting an element into a tree by making it a child of an existing tree is a constant time operation. However, this depends on us already having access to the parent tree we&rsquo;d like to add the item to, which may require searching for that element in the tree as discussed below, which runs in linear time based on the size of the tree. As we saw in our projects, one way we can simplify this is using a hash table to help us keep track of the tree nodes while we build the tree, so that we can more quickly access a desired tree (in near constant time) and add a new child to that tree.</p>
</li>
<li>
<p><strong>Access</strong>: Again, this is a bit complex, as it requires us to make some assumptions about what information is available to us. Typically, we can only access the root element of a tree, which can be done in constant time. If we&rsquo;d like to access any of the other nodes in the tree, we&rsquo;ll have to traverse the tree to find them, either by searching for them if we don&rsquo;t know the path to the item (which is linear time based on the size of the tree), or directly walking the tree in the case that we do know the path (which is comparable to the length of the path, or linear based on the height of the tree).</p>
</li>
<li>
<p><strong>Find</strong>: Finding a particular node in a generic tree is a linear time operation based on the number of nodes in the tree. We simply must do a full traversal of the tree until we find the element we are searching for, typically either by performing a preorder or postorder traversal. This is very similar to simply looking at each element in a linear data structure.</p>
</li>
<li>
<p><strong>Delete</strong>: Removing a child from an existing tree is an interesting operation. If we&rsquo;ve already located the tree node that is the parent of the element we&rsquo;d like to remove, and we know which child we&rsquo;d like to remove, then the operation would be a linear time operation related to the number of children of that node. This is because we may have to iterate through the children of that tree node in order to find the one we&rsquo;d like to remove. Recall that trees generally store the children of each node in a linked list or an array, so the time it takes to remove a child is similar to the time it takes to remove an element from those structures. Again, if we have to search for either the parent or the tree node we&rsquo;d like to remove from that parent, we&rsquo;ll have to take that into account.</p>
</li>
<li>
<p><strong>Memory</strong>: In terms of memory usage, a generic tree uses memory that is on the order of the number of nodes in the tree. So, as the number of nodes in the tree is doubled, the amount of memory it uses doubles as well.</p>
</li>
</ul>
<h3 id="tries">Tries</h3>
<p><a href="#R-image-26dc0f918ddf806821f7ca7502cfd321" class="lightbox-link"><img alt="Trie 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/assessments/4Trie_Tree1.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-26dc0f918ddf806821f7ca7502cfd321"><img alt="Trie 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/assessments/4Trie_Tree1.svg"></a></p>
<p>Tries improve on the structure of trees in one important way - instead of using a generic list to store each child, they typically use a statically sized array, where each index in the array directly corresponds to one of the possible children that the node could have. In the case of a trie that represents words, each tree node may have an array of 26 possible children, one for each letter of the alphabet. In our implementation, we chose to use lists instead to simplify things a bit, but for this analysis we&rsquo;ll assume that the children of a trie node can be accessed in constant time through the use of these static arrays.</p>
<p>In the analysis below, we&rsquo;ll assume that we are dealing with words in a trie, not individual nodes. We&rsquo;re also going to be always starting with the root node of the overall trie data structure.</p>
<ul>
<li>
<p><strong>Insert</strong>: To insert a new word in a trie, the process will run in linear time based on the length of the word. So, to insert a 10 character word in a trie, it should take on the order of 10 steps. This is because we can find each individual node for each character in constant time since we are using arrays as described above, and we&rsquo;ll need to do that once for each character, so the overall time is linear based on the number of characters. If the path doesn&rsquo;t exist, we&rsquo;ll have to create new tree nodes to fill it in, but if the path does exist, it could be as simple as setting the boolean value at the correct node to indicate that it is indeed a word.</p>
</li>
<li>
<p><strong>Access</strong>: Similarly to determine if a particular word is in the trie, it will also run in linear time based on the length of the word. We simply must traverse through the path in the tree, and at each node it is a constant time operation to find the correct child and continue onward. So, in total this is a linear time operation.</p>
</li>
<li>
<p><strong>Find</strong>: Find is pretty much the same as access, since we can&rsquo;t just directly jump to a particular node in the tree. So, this is also in linear time based on the length of the word.</p>
</li>
<li>
<p><strong>Delete</strong>: Once again, deleting a word simply involves finding it, which runs in linear time. Once it is deleted, we may go through and prune branches that are unused, which is also a linear time operation as we work back upwards in the trie. So, overall the whole operation runs in linear time based on the length of the word.</p>
</li>
</ul>
<p>In summary, pretty much every operation performed on a trie is related to the length of the word that is provided as input. Pretty nifty!</p>
<ul>
<li><strong>Memory</strong>: Analyzing the memory usage of a trie is a bit more interesting. Traditionally, we say that the memory consumed by a trie is on the order of $n * m$, where $n$ is the number of words stored in the trie, and $m$ is the length of the longest word in the trie. We come to this value because there could be $n$ words that do not share any prefixes, and if they are all the same length $n$ then we&rsquo;ll need that many nodes to represent the whole trie. However, in practice the actual memory usage may be somewhat less because of the shared prefixes and shorter words being part of longer words, but remember that we are concerned with the <strong>worst case</strong> memory usage for a trie, which is $n * m$.</li>
</ul>
<h3 id="binary-trees">Binary Trees</h3>
<p><a href="#R-image-76d12ef22d22e4b2683b69f23d165d0a" class="lightbox-link"><img alt="Tree 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/assessments/4Binary_Tree1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76d12ef22d22e4b2683b69f23d165d0a"><img alt="Tree 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/assessments/4Binary_Tree1.png"></a></p>
<p>A binary tree is a tree that is limited to having only two children of each node, and the children and parents are sorted such that every element to the left of the node is less than or equal to its value, and all elements to the right of the node are greater than or equal to its value. Because of this, they perform a little differently than traditional trees.</p>
<p>One major concept related to binary trees is whether the tree is &ldquo;balanced&rdquo; or not. A balanced tree has children that differ in <em>height</em> by no more than 1. If the tree is <em>perfectly</em> balanced, meaning all subtrees are balanced, then there are some interesting relationships that develop.</p>
<p>Most notably, the overall height $h$ of the tree is no larger than $log_2(n)$, where $n$ is the number of elements in the tree.</p>
<p>We didn&rsquo;t cover the algorithms to balance a binary tree in this course since they can be a bit complex, but for this analysis we&rsquo;ll discuss the performance of binary trees when they are perfectly balanced as well as when they are unbalanced.</p>
<ul>
<li>
<p><strong>Insert</strong>: To insert a new element in a binary tree, we may have to descend all the way to the bottom of the tree, so the operation is linear based on the height of the tree. If the tree is a perfectly balanced binary tree, then it is on the order of $log_2(n)$. Otherwise, it is linear based on the height, which in the worst case of a completely unbalanced tree could be the number of nodes itself. Once you&rsquo;ve added the new item, a perfectly balance tree may need to rebalance itself, but that operation is not any more costly than the insert operation.</p>
</li>
<li>
<p><strong>Access</strong>: Similarly, to access a particular element in a binary tree, we&rsquo;ll have to descend through the tree until we find the element we are looking for. At each level, we know exactly which child to check, so it is once again related to the height of the tree. If the tree is a perfectly balanced binary tree, then it is on the order of $log_2(n)$. Otherwise, it is linear based on the height, which in the worst case of a completely unbalanced tree could be the number of nodes itself.</p>
</li>
<li>
<p><strong>Find</strong>: Once again, find in this instance is similar to access.</p>
</li>
<li>
<p><strong>Delete</strong>: Finally, deleting an element from a binary tree involves finding the element, which will be linear based on the height of the tree. Once the element is removed, then a perfectly balanced tree will need to rebalance itself, which could also take the same amount of time. So, in both cases, it runs on the order of $h$ time, which in the worst case is the total number of nodes $n$ on an unbalanced tree, or $log_2(n)$ on a perfectly balanced tree.</p>
</li>
</ul>
<p>So, most operations involving a perfectly balanced binary tree run in $log_2(n)$ time, which is very efficient when compared to a generic tree. However, if the tree is not balanced, then we cannot make any assumptions about the height of the tree and each operation could require $n$ time, where $n$ is the number of nodes in the tree.</p>
<ul>
<li><strong>Memory</strong>: The memory usage of a binary tree is directly correlated with the number of nodes, so we typically say that it is on the order of $n$ memory usage.</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graphs">Graphs</h1>


<a href="https://www.youtube.com/watch?v=gd2_k51IFsw">YouTube Video</a>

<p>There are two types of graphs that we&rsquo;ve covered in this class: list graphs and matrix graphs. Graphs are slightly different than other data structures, because we may want to find or access both nodes and edges in the graph. So, we&rsquo;ll need to analyze the performance of graphs with respect to both nodes and edges.</p>
<h3 id="matrix-graph">Matrix Graph</h3>
<p><a href="#R-image-8eb61de7b50776a4382ad6686e011a99" class="lightbox-link"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8eb61de7b50776a4382ad6686e011a99"><img alt="Matrix Representation Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphB.svg"></a>
<a href="#R-image-a371488cf58f0270f3d822e1143c59be" class="lightbox-link"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/matrixB.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a371488cf58f0270f3d822e1143c59be"><img alt="Matrix Representation Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/matrixB.svg"></a></p>
<p>Recall that a matrix graph uses an array to store the nodes, and a two-dimensional array to store the edges.</p>
<ul>
<li>
<p><strong>Insert Node</strong>: Inserting a node is a linear time operation. To insert node, we looped through the nodes attribute and put the node in the first open index. Thus, it is linear with respect to the number of nodes.</p>
</li>
<li>
<p><strong>Access Node</strong>: Likewise, given the index of a node, we can get it&rsquo;s value in constant time by accessing the array.</p>
</li>
<li>
<p><strong>Find Node</strong>: To find the index of a node when we are given its value, we must iterate through the array of nodes, which will be a linear time operation based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Node</strong>: Finally, to remove a node from a graph we can simply set its value in the array of nodes to <code>null</code>. However, we may also need to go through the list of edges and make sure there are no edges to or from that node, so typically this operation runs on the order of the number of nodes in the graph since we must check each one.</p>
</li>
</ul>
<p>For the operations relating to edges below, we&rsquo;ll assume that we already know the indices of the two nodes we are connecting. If we don&rsquo;t know those, we&rsquo;ll have to use the find node process above first.</p>
<ul>
<li>
<p><strong>Insert Edge</strong>: To insert an edge into the graph we simply update the element in the two-dimensional array, which can be done in constant time.</p>
</li>
<li>
<p><strong>Access Edge</strong>: Likewise, to access an edge between two nodes, we simply access the element in the two-dimensional array, which is a constant time operation.</p>
</li>
<li>
<p><strong>Find Neighbors</strong>: Instead of finding a particular edge, we&rsquo;ll say that we want to find all of the neighboring nodes that can be accessed from a given node. In this case, we&rsquo;ll need to iterate through one row of the two-dimensional array, so the whole process runs on the order of linear time based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Edge</strong>: To remove an edge, we simply find it in the two-dimensional array and set its value to infinity, which can be done in constant time.</p>
</li>
</ul>
<p>So, for most matrix graph operations, we can do nearly everything in either constant time or, at worst, linear time based on the number of nodes in the graph.</p>
<ul>
<li><strong>Memory</strong>: Here is where things get interesting. Generally, we say that a matrix graph consumes $n^2$ memory, where $n$ is the number of nodes in the graph. This is because the two-dimensional array of edges is the vast majority of the memory consumption in a matrix graph. So, if the number of nodes is doubled, the memory usage will quadruple.</li>
</ul>
<h3 id="list-graph">List Graph</h3>
<p><a href="#R-image-48519a4d60c05699b679b0ff1c9a6b00" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/6/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-48519a4d60c05699b679b0ff1c9a6b00"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/6/graphA.svg"></a>
<a href="#R-image-b384e2f413b18804951575c437e60519" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b384e2f413b18804951575c437e60519"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/7/graphA_list_rep.svg"></a></p>
<p>Recall that a list graph uses an array to store the nodes, and then each node stores a list of edges that start from that node.</p>
<ul>
<li>
<p><strong>Insert Node</strong>: Inserting a node is a linear time operation. To insert node, we looped through the nodes attribute and put the node in the first open index. Thus, it is linear with respect to the number of nodes.</p>
</li>
<li>
<p><strong>Access Node</strong>: Likewise, given the index of a node, we can get it&rsquo;s value in constant time by accessing the array.</p>
</li>
<li>
<p><strong>Find Node</strong>: To find the index of a node when we are given its value, we must iterate through the array of nodes, which will be a linear time operation based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Delete Node</strong>: Finally, to remove a node from a graph we can simply set its value in the array of nodes to <code>null</code>. However, we may also need to go through each other node and check to make sure it isn&rsquo;t in the list of edges. So typically this operation runs on the order of the number of nodes in the graph since we must check each one.</p>
</li>
</ul>
<p>So far, a list graph seems to be pretty similar to a matrix graph in terms of performance. The real difference comes with how we handle edges, as well see next.</p>
<p>For the operations relating to edges below, we&rsquo;ll assume that we already know the indices of the two nodes we are connecting. If we don&rsquo;t know those, we&rsquo;ll have to use the find node process above first.</p>
<ul>
<li>
<p><strong>Insert Edge</strong>: To insert an edge into the graph, we must get the source node from the nodes array and then add an element to the list of edges. Assuming that the edges are stored in a linked list, this is a linear time operation in terms of the number of nodes since we may have to iterate through the list of edges to make sure this edge doesn&rsquo;t already exist and need updated. In the worst case, there may be $n$ edges here, so it is a linear operation.</p>
</li>
<li>
<p><strong>Access Edge</strong>: To access an edge between two nodes, we first find the source node in the list of nodes, which is a constant time operation. Then, we&rsquo;ll have to iterate through the list of edges, which is at worst linear time based on the size of the graph, since there could be $n$ outgoing edges from this node. So, overall the operation runs on the order of linear time based on the number of nodes in the graph.</p>
</li>
<li>
<p><strong>Find Neighbors</strong>: Instead of finding a particular edge, we&rsquo;ll say that we want to find all of the neighboring nodes that can be accessed from a given node. In this case, we can just find the source node in the array of nodes, which is a constant time operation. Then, we can simply return the list of edges, which is also constant time. So, this operation is very efficient!</p>
</li>
<li>
<p><strong>Delete Edge</strong>: To remove an edge, we find the source node and iterate through the list of edges until we find the one to remove. So, this runs in linear time based on the number of nodes in the graph.</p>
</li>
</ul>
<p>So, for most list graph operations, we can also do nearly everything in either constant time or, at worst, linear time based on the number of nodes in the graph. The only real difference comes in how we handle edges, where some operations are a bit slower, but getting a list of all the neighbors of a node is actually a little quicker!</p>
<ul>
<li><strong>Memory</strong>: For a list graph, we typically say the memory usage is on the order of $n + e$, where $n$ is the number of nodes in the graph and $e$ is the number of edges in the graph.</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<h1 id="dense-vs-sparse-graphs">Dense vs. Sparse Graphs</h1>
<p>Let&rsquo;s analyze the memory usage of matrix and list graphs when dealing with dense and sparse graphs. This is the real key difference between the two data structures.</p>
<h2 id="dense-graph">Dense Graph</h2>
<p>A dense graph is a graph that has a large number of edges compared to the maximum number of edges possible. More specifically, the maximum number of edges a graph can have is $n^2$, so we would say a dense graph has a value for $e$ that is close to $n^2$. Because of this, the memory usage of a matrix graph ($n^2$) is actually a bit more efficient than a list graph ($n + n^2$) because it doesn&rsquo;t have the extra overhead of maintaining a list structure for each node.</p>
<h2 id="sparse-graph">Sparse Graph</h2>
<p>A sparse graph is a graph that has a small number of edges compared to the maximum number of edges possible. So, here we would say that the value of $e$ is much smaller than $n^2$, though it may still be larger than $n$ (otherwise each node would only have one edge coming from it, and this would be a linked list). In that case, we see that $n + e$ is much smaller than $n^2$, and a list graph is much more efficient. If you think about it, in a matrix graph a large number of the entries in the two-dimensional array would be set to infinity and unused, but they still take up memory. Those unused edges wouldn&rsquo;t exist in a list graph, making it much more memory efficient.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="priority-queues">Priority Queues</h1>


<a href="https://www.youtube.com/watch?v=doAjYITSxQI">YouTube Video</a>

<p><a href="#R-image-c510cca2e262eab838709b23ecdd0d4a" class="lightbox-link"><img class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c510cca2e262eab838709b23ecdd0d4a"><img class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/10/todo_tree_array.svg"></a></p>
<p>Let&rsquo;s look at the performance of priority queues next. These structures are based on a heap, which has some unique characteristics related to the <em>heap properties</em> that it must maintain.</p>
<p>Recall that a heap is an array which we can view as an unsorted binary tree. This tree must have the following properties:</p>
<ol>
<li>Each node has at most two children.</li>
<li>If there are nodes in level <code>i</code> of the tree, then level <code>i-1</code> is full.</li>
<li>The nodes of the last level are as far left as possible.</li>
</ol>
<ul>
<li>
<p><strong>Insert</strong> To insert a new element in a priority queue, we place it at the end and then push it upwards until it is in the correct place. Because the heap property creates a perfectly balanced tree, at most it will have to perform $log_2(n)$ or $h$ operations. So, we say that insert runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Access Minimum</strong> The most common operation for accessing elements in the priority queue is to access the minimum element. Since it should always be the first element in the array due to the heap properties, this is clearly a constant time operation.</p>
</li>
<li>
<p><strong>Find Element</strong> To find an item in a priority queue, we must simply iterate through the array that stores the heap, which is a linear time operation based on the number of elements in the heap.</p>
</li>
<li>
<p><strong>Remove Minimum</strong> To remove the smallest element, we swap it with the last element and then remove it, then push the top element down into place. Similar to the push up operation, at most it will perform $log_2(n)$ or $h$ operations. So, we say that remove minimum runs on the order of $log_2(n)$ where $n$ is the number of elements in the heap.</p>
</li>
<li>
<p><strong>Heapify</strong> This is the most interesting operation of a heap. When we use heapify, we add a large number of elements to the heap and then sort it exactly once by working from the bottom to the top and pushing down each element into place. On the surface, it appears that this should run in the order $n * log_2(n)$ time, since each push down operation takes $log_2(n)$ time, and we have to do that on the order of $n$ times to get each element in place. However, using a bit of mathematical analysis, it is possible to prove that this operation actually runs in linear time $n$ based on the number of elements. The work to actually prove this is a bit beyond the scope of this course, but <a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" rel="external" target="_blank">this StackOverflow discussion</a> is a great explanation of how it works.</p>
</li>
<li>
<p><strong>Memory</strong>: In terms of memory usage, a priority queue uses memory that is on the order of the number of elements in the priority queue.</p>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<h1 id="heapify-and-heap-sort">Heapify and Heap Sort</h1>
<p>Why is it important that heapify runs in linear time? That is because we can use heapify and remove minimum to sort data, which is a sorting algorithm known as heap sort.</p>
<p>We already saw that heapify runs in linear time based on the number of nodes, and each remove minimum operation runs in $log_2(n)$ time. To remove all the elements of the heap, we would do that $n$ times, so the overall time would be $n * log_2(n)$ time. If you recall, that is the same performance as merge sort and quicksort!</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="315-structure-performance-summary">315 Structure Performance Summary</h1>

<p>This page will be devoted to summarizing our performance discussions. Below, we have included a graph for a frame of reference for the various functions.</p>
<p><a href="#R-image-36fab80ab1033cac653d83c2f675ff97" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/12/12_graph.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-36fab80ab1033cac653d83c2f675ff97"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/12/12_graph.png"></a></p>
<h2 id="generic-trees">Generic Trees</h2>
<p>In the following, $n$ denotes the number of nodes in the tree.</p>
<ul>
<li><strong>Insert</strong>: 1 if we have the parent but $n$ if we have to find the parent</li>
<li><strong>Access</strong>: 1 if we want to access the root but $n$ otherwise</li>
<li><strong>Find</strong>: $n$</li>
<li><strong>Delete</strong>: $n$ if we have to find the parent</li>
<li><strong>Memory</strong>: $n$</li>
</ul>
<h2 id="tries">Tries</h2>
<p>In the following, $m$ denotes the length of a word and $n$ denotes the number of words in the trie.</p>
<ul>
<li><strong>Insert</strong>: $m$</li>
<li><strong>Access</strong>: $m$</li>
<li><strong>Find</strong>: $m$</li>
<li><strong>Delete</strong>: $m$</li>
<li><strong>Memory</strong>: $n\times m$</li>
</ul>
<h2 id="binary-trees">Binary Trees</h2>
<p>In the following, $n$ denotes the number of nodes in the tree.</p>
<ul>
<li><strong>Insert</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Access</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Find</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Delete</strong>: $log_2(n)$ when balanced but $n$ otherwise</li>
<li><strong>Memory</strong>: $n$</li>
</ul>
<h2 id="matrix-graph">Matrix Graph</h2>
<p>In the following, $n$ denotes the number of nodes in the graph.</p>
<ul>
<li><strong>Insert Node</strong>: $n$</li>
<li><strong>Access Node</strong>: 1</li>
<li><strong>Find Node</strong>: $n$</li>
<li><strong>Delete Node</strong>: $n$</li>
<li><strong>Insert Edge</strong>: 1</li>
<li><strong>Access Edge</strong>: 1</li>
<li><strong>Find Neighbors</strong>: $n$</li>
<li><strong>Delete Edge</strong>: 1</li>
<li><strong>Memory</strong>: $n^2$</li>
</ul>
<h2 id="list-graph">List Graph</h2>
<p>In the following, $n$ denotes the number of nodes in the graph and $e$ denotes the number of edges.</p>
<ul>
<li><strong>Insert Node</strong>: $n$</li>
<li><strong>Access Node</strong>: 1</li>
<li><strong>Find Node</strong>: $n$</li>
<li><strong>Delete Node</strong>: $n$</li>
<li><strong>Insert Edge</strong>: $n$</li>
<li><strong>Access Edge</strong>: $n$</li>
<li><strong>Find Neighbors</strong>: 1</li>
<li><strong>Delete Edge</strong>: $n$</li>
<li><strong>Memory</strong>: $n+e$</li>
</ul>
<h2 id="priority-queue">Priority Queue</h2>
<p>In the following, $n$ denotes the number of elements in the priority queue.</p>
<ul>
<li><strong>Insert</strong>: $log_2(n)$</li>
<li><strong>Access Minimum</strong>: 1</li>
<li><strong>Find</strong>: $n$</li>
<li><strong>Remove Minimum</strong>: $log_2(n)$</li>
<li><strong>Heapify</strong>: $n$</li>
<li><strong>Memory</strong>: $n$</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tree-algorithms">Tree Algorithms</h1>

<p>We will now discuss the performance of the algorithms that we discussed in this course. When examining the performance of an algorithm we will look at the time and the space that it will require.</p>
<ul>
<li><strong>Time</strong>: To analyze the time of an algorithm, we will look at the number of operations required to complete the algorithm.</li>
<li><strong>Space</strong>: To analyze the space requirement of an algorithm, we will look at the various variables within the algorithm. To calculate this, we can add up the space requirements for each variable within the algorithm</li>
</ul>
<h2 id="preorder-and-postorder">Preorder and Postorder</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PREORDER(RESULT)
</span></span><span class="line"><span class="cl">    append ITEM to RESULT
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.PREORDER(RESULT)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   append ITEM to RESULT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time required for preorder or postorder traversals will be linear with respect to the number of nodes. In a single iteration, we will execute the appending once and we will execute the for loop for each child.</li>
<li><strong>Space</strong>: Since <code>RESULT</code> is a variable defined and stored outside of the algorithm, it does not factor into our space requirement. Then we must account for the variables <code>CHILD</code> and <code>CHILDREN</code>. In any given iteration, <code>CHILD</code> will be constant and <code>CHILDREN</code> will have size equal to the number of children for the node we are currently at. In total, this would give us a space requirement that is linear with respect to the number of nodes.</li>
</ul>
<h2 id="inorder">Inorder</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function INORDER(RESULT)
</span></span><span class="line"><span class="cl">    LEFTCHILD.INORDER(RESULT)
</span></span><span class="line"><span class="cl">    append ITEM to RESULT
</span></span><span class="line"><span class="cl">    RIGHTCHILD.INORDER(RESULT)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><ul>
<li><strong>Time</strong>: For any given call to the inorder traversal, it will execute in constant time. We must factor in that we have a recursive function and as such, we will call the inorder traversal for each node. Thus our time requirement will be linear with respect to the number of nodes.</li>
<li><strong>Space</strong>: Since <code>RESULT</code> is a variable defined and stored outside of the algorithm, it does not factor into our space requirement. Then we must account for the variable <code>ITEM</code>. This will have constant space and thus, the space requirement for the inorder traversal is constant.</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graph-algorithms">Graph Algorithms</h1>

<h2 id="path-searches">Path Searches</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     STACK = empty array
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     append SRC to STACK
</span></span><span class="line"><span class="cl">6.     while STACK is not empty
</span></span><span class="line"><span class="cl">7.         CURR = top of the stack
</span></span><span class="line"><span class="cl">8.         if CURR not in DISCOVERED
</span></span><span class="line"><span class="cl">9.             if CURR is TAR
</span></span><span class="line"><span class="cl">10.                 PATH = empty array
</span></span><span class="line"><span class="cl">11.                 TRACE = TAR
</span></span><span class="line"><span class="cl">12.                 while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                     append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                     set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                 reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                 return PATH
</span></span><span class="line"><span class="cl">17.            add CURR to DISCOVERED
</span></span><span class="line"><span class="cl">18.            NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">19.            for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">20.                NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">21.                append NODE to STACK
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.    return nothing</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time analysis for the depth first search can be a bit complex. Lines 1 through 5 would execute in near constant time. When we start the while loop on line 6, it is more difficult to analyze how many times this can execute as <code>STACK</code> can contain duplicates. In the case that we have a sparse graph, this would be bound by the number of nodes. For a dense graph however, the number of executions would be bound by the number of edges. The code within the while loop would be bound by the number of nodes because of the check that we have not already discovered the node in line 8. If we haven&rsquo;t discovered it, we would take either the logic of lines 8 through 16 or lines 17 through 23 but never both in the same iteration. Both of these blocks are bound by the number of nodes in our graph. Thus the worst case time requirement would be $n^2$.</li>
<li><strong>Space</strong>: Depending on the density of our graph, the space required will be linear with respect to the number of nodes or edges. This is due to the fact that <code>STACK</code> can contain duplicate nodes. If we have a sparse graph then it will be bound by the number of nodes. If we have a dense graph then the space is bound by the number of edges.
<ul>
<li><code>STACK</code>: linear with respect to the number of edges</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of neighbors</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function BREADTHFIRSTSEARCH(GRAPH,SRC,TAR)
</span></span><span class="line"><span class="cl">2.     QUEUE = empty queue
</span></span><span class="line"><span class="cl">3.     DISCOVERED = empty set
</span></span><span class="line"><span class="cl">4.     PARENT<span class="nb">_</span>MAP = empty dictionary
</span></span><span class="line"><span class="cl">5.     add SRC to DISCOVERED
</span></span><span class="line"><span class="cl">6.     add SRC to QUEUE
</span></span><span class="line"><span class="cl">7.     while QUEUE is not empty
</span></span><span class="line"><span class="cl">8.         CURR = first element in QUEUE
</span></span><span class="line"><span class="cl">9.         if CURR is TAR 
</span></span><span class="line"><span class="cl">10.            PATH = empty list 
</span></span><span class="line"><span class="cl">11.            TRACE = TAR
</span></span><span class="line"><span class="cl">12.            while TRACE is not SRC
</span></span><span class="line"><span class="cl">13.                    append TRACE to PATH
</span></span><span class="line"><span class="cl">14.                    set TRACE equal to PARENT<span class="nb">_</span>MAP[TRACE]
</span></span><span class="line"><span class="cl">15.                reverse the order of PATH
</span></span><span class="line"><span class="cl">16.                return PATH
</span></span><span class="line"><span class="cl">17.        NEIGHS = neighbors of CURR
</span></span><span class="line"><span class="cl">18.        for EDGE in NEIGHS
</span></span><span class="line"><span class="cl">19.            NODE = first entry in EDGE
</span></span><span class="line"><span class="cl">20.            if NODE is not in DISCOVERED
</span></span><span class="line"><span class="cl">21.                add NODE to DISCOVERED
</span></span><span class="line"><span class="cl">22.                if PARENT<span class="nb">_</span>MAP does not have key NODE
</span></span><span class="line"><span class="cl">23.                    in the PARENT<span class="nb">_</span>MAP dictionary set key NODE with value CURR
</span></span><span class="line"><span class="cl">24.                append NODE to QUEUE
</span></span><span class="line"><span class="cl">25.    return nothing</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The run time expected for breadth first search is a bit more straight forward as <code>QUEUE</code> will never have duplicates. Lines 1 through 6 will all execute in constant time. The while loop will occur $n$ times where $n$ is the number of nodes. Based on the logic, either 9-16 will execute or 17-24 will execute. Both of these are bound by the number of nodes in terms of time. Each iteration of the while loop will take $n$ time and we do the while loop $n$ times; thus the running time will be $n^2$.</li>
<li><strong>Space</strong>: The space required for BFS will be linear with respect to the number of nodes. We have 5 variables which have size bound by the number of nodes. If the number of nodes doubles, then we expect the amount of space to roughly double.
<ul>
<li><code>QUEUE</code>: linear with respect to the number of nodes</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of nodes</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="msts">MSTs</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function KRUSKAL(GRAPH)
</span></span><span class="line"><span class="cl">2.     MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">3.     ALLSETS = an empty list which will contain the sets
</span></span><span class="line"><span class="cl">4.     for NODE in GRAPH NODES
</span></span><span class="line"><span class="cl">5.         SET = a set with element NODE
</span></span><span class="line"><span class="cl">6.         add SET to ALLSETS
</span></span><span class="line"><span class="cl">7.     EDGES = list of GRAPH&#39;s edges
</span></span><span class="line"><span class="cl">8.     SORTEDEDGES = EDGES sorted by edge weight, smallest to largest
</span></span><span class="line"><span class="cl">9.     for EDGE in SORTEDEDGES
</span></span><span class="line"><span class="cl">10.        SRC = source node of EDGE
</span></span><span class="line"><span class="cl">11.        TAR = target node of EDGE
</span></span><span class="line"><span class="cl">12.        SRCSET = the set from SETS in which SRC is contained
</span></span><span class="line"><span class="cl">13.        TARSET = the set form SETS in which TAR is contained
</span></span><span class="line"><span class="cl">14.        if SRCSET not equal TARSET
</span></span><span class="line"><span class="cl">15.            UNIONSET = SRCSET union TARSET
</span></span><span class="line"><span class="cl">16.            add UNIONSET to ALLSETS
</span></span><span class="line"><span class="cl">17.            remove SRCSET from ALLSETS
</span></span><span class="line"><span class="cl">18.            remove TARSET from ALLSETS
</span></span><span class="line"><span class="cl">19.            add EDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">20.    return MST</span></span></code></pre></div><ul>
<li>
<p><strong>Time</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. Lines 4-6 would take linear time with respect to the number of nodes. Then lines 9-19 would take linear time with respect to the number of edges as it would execute $e$ times and each operation can be done in constant time, except for searching through the sets and performing set operations, which require $log_2(n)$ time. Thus, Kruskal&rsquo;s algorithm will take time on the order of $e \times log_2(n)$ in the worst case.</p>
</li>
<li>
<p><strong>Space</strong>:The required space for Kruskal&rsquo;s algorithm is dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.</p>
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>ALLSETS</code>: linear with respect to the number of nodes</li>
<li><code>NODE</code>: 1</li>
<li><code>GRAPH NODES</code>: linear with respect to the number of nodes</li>
<li><code>SET</code>: 1</li>
<li><code>EDGES</code>: linear with respect to the number of edges</li>
<li><code>SORTEDEDGES</code>: linear with respect to the number of edges</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
<li><code>SRCSET</code>: 1</li>
<li><code>TARSET</code>: 1</li>
<li><code>UNIONSET</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function PRIM(GRAPH, START)
</span></span><span class="line"><span class="cl">2.     MST = GRAPH without the edges attribute(s)
</span></span><span class="line"><span class="cl">3.     VISITED = empty set
</span></span><span class="line"><span class="cl">4.     add START to VISITED
</span></span><span class="line"><span class="cl">5.     AVAILEDGES = list of edges where START is the source
</span></span><span class="line"><span class="cl">6.     sort AVAILEDGES
</span></span><span class="line"><span class="cl">7.     while VISITED is not all of the nodes
</span></span><span class="line"><span class="cl">8.         SMLEDGE = smallest edge in AVAILEDGES
</span></span><span class="line"><span class="cl">9.         SRC = source of SMLEDGE
</span></span><span class="line"><span class="cl">10.        TAR = target of SMLEDGE
</span></span><span class="line"><span class="cl">11.        if TAR not in VISITED
</span></span><span class="line"><span class="cl">12.            add SMLEDGE to MST as undirected edge
</span></span><span class="line"><span class="cl">13.            add TAR to VISITED
</span></span><span class="line"><span class="cl">14.            add the edges where TAR is the source to AVAILEDGES
</span></span><span class="line"><span class="cl">15.        remove SMLEDGE from AVAILEDGES
</span></span><span class="line"><span class="cl">16.        sort AVAILEDGES
</span></span><span class="line"><span class="cl">17.    return MST</span></span></code></pre></div><ul>
<li><strong>Time without Priority Queue</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. With a matrix graph, setting up <code>AVAILEDGES</code> would take linear time with respect to the number of nodes. With a list graph, this would happen in constant time. Then, we need to get the smallest edge from the <code>AVAILEDGES</code> list, which would be a linear time operation based on the number of edges, and we must do that once for up to each edge in the graph. So, the worst case running time for Prim&rsquo;s algorithm is $e^2$. (Our implementation is actually a bit slower than this since we sort the list of available edges each time, but that is technically not necessary - our implementation is closer to $e^2 \times log_2(e)$!)</li>
<li><strong>Time with Priority Queue</strong>: We do get an improvement when we choose to implement this with a priority queue. For the most part, the performance is the same. Using a priority queue, heapify would optimize the sorting to happen in linear time with respect to the number of elements. In that case, we can reduce the total running time to on the order of $e \times log_2(n)$, which is the same as Kruskal&rsquo;s algorithm.</li>
<li><strong>Space</strong>: The required space for Prim&rsquo;s algorithm is also dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>VISITED</code>: linear with respect to the number of nodes</li>
<li><code>AVAILEDGES</code>: linear with respect to the number of edges</li>
<li><code>SMLEDGE</code>: 1</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
</ul>
</li>
</ul>
<h2 id="shortest-path">Shortest Path</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. DIJKSTRAS(GRAPH, SRC)
</span></span><span class="line"><span class="cl">2.    SIZE = size of GRAPH
</span></span><span class="line"><span class="cl">3.    DISTS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">4.    PREVIOUS = array with length equal to SIZE
</span></span><span class="line"><span class="cl">5.    set all of the entries in PREVIOUS to none
</span></span><span class="line"><span class="cl">6.    set all of the entries in DISTS to infinity 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">7.    DISTS[SRC] = 0 
</span></span><span class="line"><span class="cl">8.    PQ = min-priority queue
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">9.    loop IDX starting at 0 up to SIZE
</span></span><span class="line"><span class="cl">10.        insert (DISTS[IDX],IDX) into PQ
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">11.    while PQ is not empty
</span></span><span class="line"><span class="cl">12.        MIN = REMOVE-MIN from PQ
</span></span><span class="line"><span class="cl">13.        for NODE in neighbors of MIN
</span></span><span class="line"><span class="cl">14.            WEIGHT = graph weight between MIN and NODE
</span></span><span class="line"><span class="cl">15.            CALC = DISTS[MIN] + WEIGHT
</span></span><span class="line"><span class="cl">16.            if CALC &lt; DISTS[NODE]
</span></span><span class="line"><span class="cl">17.                DISTS[NODE] = CALC
</span></span><span class="line"><span class="cl">18.                PREVIOUS[NODE] = MIN
</span></span><span class="line"><span class="cl">19.                PQIDX = index of NODE in PQ
</span></span><span class="line"><span class="cl">20.                PQ decrease-key (PQIDX, CALC)
</span></span><span class="line"><span class="cl">21.    return DISTS and PREVIOUS</span></span></code></pre></div><ul>
<li><strong>Time</strong>: The time required for Dijkstra&rsquo;s algorithm will be $n^2$ in the worst case. We would expect lines 1 through 8 to take constant time. The for loop on line 9 would be bound by the number of nodes. We would expect the for loop on line 13 to be bound by the number of nodes. This for loop will execute each time <code>PQ</code> is not empty (line 11), which is bound by the number of nodes. Thus, the block of code starting at 11 will take $n^2$ time to run in the worst case. This means that if we double the number of nodes, then the running time will be quadrupled. The worst case for Dijkstra&rsquo;s algorithm is characterized by being a very dense graph, meaning each node has a lot of neighbors. If the graph is sparse and our priority queue is efficient, we could expect this running time to be more along the lines of $(n + e) \times log_2(n)$, where $e$ is the number of edges.</li>
<li><strong>Space</strong>: The required space for Dijkstra&rsquo;s algorithm will be linear with respect to the number of nodes. We have 4 variables which have linear size with respect to the number of nodes. We say that this is linear because if we were to double the number of nodes, we would roughly double the space requirement.
<ul>
<li><code>SIZE</code>: 1</li>
<li><code>DISTS</code>: linear with respect to the number of nodes</li>
<li><code>PREVIOUS</code>: linear with respect to the number of nodes</li>
<li><code>PQ</code>: linear with respect to the number of nodes</li>
<li><code>IDX</code>: 1</li>
<li><code>MIN</code>: 1</li>
<li><code>NODE</code>: 1</li>
<li><code>NEIGHBORS</code>: linear with respect to the number of nodes</li>
<li><code>WEIGHT</code>: 1</li>
<li><code>CALC</code>: 1</li>
<li><code>PQIDX</code>: 1</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="310-structure-performance-summary">310 Structure Performance Summary</h1>

<h2 id="stacks">Stacks</h2>
<p>A stack is a data structure with two main operations that are simple in concept. One is the <code>push</code> operation that lets you put data into the data structure and the other is the <code>pop</code> operation that lets you get data out of the structure.</p>
<p>A stack is what we call a Last In First Out (LIFO) data structure. That means that when we <code>pop</code> a piece of data off the stack, we get the last piece of data we put on the stack.</p>
<h2 id="queues">Queues</h2>
<p>A queue data structure organizes data in a First In, First Out (FIFO) order: the first piece of data put into the queue is the first piece of data available to remove from the queue.</p>
<h2 id="lists">Lists</h2>
<p>A list is a data structure that holds a sequence of data, such as the shopping list shown below. Each list has a head item and a tail item, with all other items placed linearly between the head and the tail.</p>
<h2 id="sets">Sets</h2>
<p>A set is a collection of elements that are usually related to each other.</p>
<h2 id="hash-tables">Hash Tables</h2>
<p>A hash table is an unordered collection of key-value pairs, where each key is unique.</p>
<p>The following table compares the best- and worst-case processing time for many common data structures and operations, expressed in terms of $N$, the number of elements in the structure.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data Structure</th>
<th style="text-align:center">Insert Best</th>
<th style="text-align:center">Insert Worst</th>
<th style="text-align:center">Access Best</th>
<th style="text-align:center">Access Worst</th>
<th style="text-align:center">Find Best</th>
<th style="text-align:center">Find Worst</th>
<th style="text-align:center">Delete Best</th>
<th style="text-align:center">Delete Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Unsorted Array</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Array</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Array Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Array Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Unsorted Linked List</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Linked List</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Hash Table</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
    
    
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 60</div>

<h1 id="requirements-analysis">Requirements Analysis</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Requirements Analysis</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Requirements Analysis</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="module-outline">Module Outline</h1>


<a href="https://www.youtube.com/watch?v=ZSC3F4OdGg0">YouTube Video</a>

<p>In this module, we will discuss how we can determine which data structure we should choose when storing real-world data. We&rsquo;ll typically make this decision based on the characteristics of the data we would like to store. In general, the data structures we&rsquo;ve learned often work together well and complement each other, as we saw in Dijkstra&rsquo;s algorithm. In some cases, one structure can be utilized to implement another, such as using a linked list to implement a stack or a queue.</p>
<p>When selecting a data structure for a particular data set, there are a few considerations we should keep in mind.</p>
<h2 id="does-it-work">Does it Work?</h2>
<p>The first consideration is: does this data structure work for our data? To answer this, we would want to the characteristics in the data and then determine if our chosen data structure:</p>
<ul>
<li>maintains relationships between elements?</li>
<li>translates well to the real world data?</li>
<li>efficiently stores the data without extra overhead?</li>
<li>can store all aspects of the data clearly and concisely?</li>
</ul>
<h2 id="will-someone-else-understand">Will Someone Else Understand?</h2>
<p>Once we have chosen a possible data structure, we also must consider if the choice clearly makes sense to another person who reviews our work. Some questions we may want to ask:</p>
<ul>
<li>is this a natural choice?</li>
<li>if I look back at this 6 months from now, would I understand it?</li>
<li>do I need to provide extra comments or documentation to explain this choice?</li>
</ul>
<h2 id="does-it-perform-well">Does it Perform Well?</h2>
<p>Finally, we should always consider the performance of our program when selecting a data structure. In some cases, the most straightforward data structure may not always be the most efficient, so at times there is a trade off between performance and simplicity. Consider the hash table structure - it may seem like a more complicated array or linked list. But, if we need to find a specific item in the structure, a hash table is typically <strong>much</strong> faster due to the use of hashes. That increase in complexity pays off in faster performance. So, when analyzing data structures for performance, we typically look at these things:</p>
<ul>
<li>performance time for tasks</li>
<li>space requirements</li>
<li>complexity of the code</li>
</ul>
<p>We will address this particular facet in the next chapter. For now, we will focus on the first two portions.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="types-of-data">Types of Data</h1>


<a href="https://www.youtube.com/watch?v=pcFgY09EWmk">YouTube Video</a>

<p>The first step toward determining which data structure to use relies heavily on the format of the data. By looking at the data and trying to understand what it contains and how it works, we can get a better idea of what data structure would work best to represent the data. Here, we will discuss some main types of data that we could encounter.</p>
<h2 id="unique">Unique</h2>
<p>Unique data is the type of data where each element in a group must be unique - there can be no duplicates. However, in many cases the data itself doesn&rsquo;t have a sequence or fixed ordering, we simply care if an element is present in the group or not. Some examples of unique data:</p>
<ul>
<li>car license plates</li>
<li>personnel ID badge numbers</li>
</ul>
<p>This data is best stored in the <strong>set</strong> data structure, usually built using a hash table as we learned previously.</p>
<p>However, many times this data may be included along with other data (a person&rsquo;s ID number is part of the person&rsquo;s record), so sets are rarely used in practice. Instead, we can simply modify other data structures to enforce the uniqueness property we desire on those attributes. In addition, we see this concept come up again in relational databases, where particular attributes can be assigned a property to enforce the rule that each element must be unique.</p>
<h2 id="linear">Linear</h2>
<p>Linear data refers to data that has a sequence or fixed ordering. This can include</p>
<ul>
<li>a series of characters</li>
<li>a list of steps</li>
<li>a log of actions taken over time</li>
</ul>
<p>This data is typically stored in the <strong>array</strong> or <strong>linked list</strong> data structure, depending on how we intend to use it and what algorithms will be performed on the data.</p>
<p>We can think of this type of data as precisely one after another. This means that from one element there will be exactly one &ldquo;next&rdquo; element.</p>
<p>Finally, we can also adapt these data structures to represent FIFO (first-in, first-out) and LIFO (last-in, first-out) data structures using <strong>queues</strong> and <strong>stacks</strong>. As we saw previously, most implementations of queues and stacks are simply adaptations of existing linear data structures, usually the linked list.</p>
<h2 id="associative">Associative</h2>
<p>Associative data is data where a key is associated with a value, usually in order to quickly find and retrieve the value based on its key. Some examples are:</p>
<ul>
<li>student records associated with a student ID</li>
<li>tax forms stored with a social security number</li>
</ul>
<p>We typically use a <strong>hash table</strong> to store this data in our programs.</p>
<p>However, in many cases this data could also be stored in a relational database just as easily, and in most industry programs that may also be a good choice here. Since we haven&rsquo;t yet learned about relational databases, we&rsquo;ll just continue to use hash tables for now.</p>
<h2 id="hierarchical">Hierarchical</h2>
<p>Hierarchical data refers to data where elements can be seen as above, below, or on the same level as other elements. This can include</p>
<ul>
<li>corporate ladders</li>
<li>lineage</li>
<li>file systems</li>
</ul>
<p>In contrast to linear data, hierarchical data can have multiple elements following a single element. In hierarchical data, each element has exactly one element prior to it. We typically use some form of a <strong>tree</strong> data structure to store hierarchical data.</p>
<h2 id="relational">Relational</h2>
<p>Relational data refers to data where elements are &lsquo;close to&rsquo; or &lsquo;far from&rsquo; other elements. We can also think of this as &lsquo;more similar&rsquo; and &rsquo;less similar&rsquo; as well. This can include</p>
<ul>
<li>cities</li>
<li>computer components</li>
<li>social media posts</li>
<li>graphics</li>
</ul>
<p>In a relational data set, any element can be &lsquo;related&rsquo; to any other element. We typically use a <strong>graph</strong> data structure to store relational data.</p>
<h2 id="prioritized">Prioritized</h2>
<p>The last type of data we will discuss is prioritized data. Here, we want to store a data element along with a priority, and then be able to quickly retrieve the element with the highest or lowest priority, depending on use. This could include:</p>
<ul>
<li>process switching inside of a computer operating system</li>
<li>delivery tasks to perform</li>
<li>repairs needed on a device</li>
</ul>
<p>For this data, we typically use an implementation of a <strong>priority queue</strong> based on a heap. It is important to remember that the heap does not store the data in sorted order - otherwise we would just use a linear data structure for this. Instead, it guarantees that the next element is always stored at the front of the structure for easy access, and it includes a process to quickly determine the new next element. We&rsquo;ll learn a bit more about why this is so helpful in the next chapter covering performance.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>It is important to note that when we are given a set of requirements for a project, the developer may not use the words to classify the types of data. Based on what a user tells us, we want to be able to infer what kind of shape the data could take.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="trees">Trees</h1>

<p>In general, trees are good for hierarchical data. While trees can be used for linear data, it is inefficient to implement them in that way (from a certain point of view, a linked list is simply a tree where each node can only have one child). When data points have many predecessors, trees cannot be used. Thus, trees are not suitable for most relational data.</p>
<h2 id="trees">Trees</h2>
<p>To recap, we defined a tree as having the following structure:</p>
<ul>
<li>There must be a single root,</li>
<li>Each child node has a single parent node,</li>
<li>It must be fully connected (no disjoint parts), and</li>
<li>There can be no cycles (no loops).</li>
</ul>
<p>In this course, we used trees to represent family lineage and biologic classifications. Once we have the data in a tree, we can perform both preorder and postorder traversals to see all of the data, and we can use the structure of the tree to determine if two elements are related as ancestor and descendant or not.</p>
<p>We added constraints to trees to give us special types of trees, discussed below.</p>
<h2 id="tries">Tries</h2>
<p>A trie is a type of tree with some special characteristics, which are:</p>
<ul>
<li>Each node contains a single character, with the root node containing an empty character by convention</li>
<li>By starting at the root and traversing parent to children relationships, we can build user-defined words using those characters, and</li>
<li>Each node has a boolean property to indicate if it is the end of a word.</li>
</ul>
<p>Tries are best suited for data sets in which elements have similar prefixes. In this course we focused on tries to represent words in a language, which is the most common use of tries. We used tries for an auto-complete style application.</p>
<p><a href="#R-image-51a6af5422afa6dfe5e8e8f0b631ea49" class="lightbox-link"><img alt="Trie example: words starting with &lsquo;car&rsquo;" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/11/11_trie.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-51a6af5422afa6dfe5e8e8f0b631ea49"><img alt="Trie example: words starting with &lsquo;car&rsquo;" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/11/11_trie.svg"></a></p>
<p>Tries are a very efficient way of storing dense hierarchical data, since each node in the trie only stores a single portion of the overall data. They also allow quickly looking up if a particular element or path exists - usually much quicker than looking through a linear list of words.</p>
<h2 id="binary-trees">Binary Trees</h2>
<p>A binary tree is a type of tree with some special characteristics, which are:</p>
<ul>
<li>Each node has at most 2 children (nodes can have 0, 1, or 2 children), and</li>
<li>unlike general trees, the children in a binary tree are not an unordered set. The children must be ordered such that:
<ul>
<li>all of the descendants in the left tree are less than the parent&rsquo;s value, and</li>
<li>all of the descendants in the right tree are greater than the parent&rsquo;s value</li>
</ul>
</li>
</ul>
<p>Binary trees are the ideal structure to use when we have a data set with a well defined ordering. Once we have the data stored in a binary tree, we can also do an inorder traversal, which will access the elements in the tree in sorted order. We will discuss in the next chapter why we might want to choose a binary tree based on its performance.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graphs">Graphs</h1>

<p>Graphs are a good data structure for relational data. This would include data in which elements can have some sort of similarity or distance defined between those elements. This measure of similarity between elements can be defined as realistically or abstractly as needed for the data set. The distance can be as simple as listing neighbors or adjacent elements.</p>
<h2 id="graphs">Graphs</h2>
<p>Graphs are multidimensional data structures that can represent many different types of data using nodes and edges. We can have graphs that are weighted and/or directed and we have introduced two ways we can represent graphs:</p>
<h3 id="matrix-graphs">Matrix Graphs</h3>
<p>The first implementation of graphs that we looked at were matrix graphs. In this implementation, we had an array for the nodes and a two dimensional array for all of the possible edges.</p>
<h3 id="list-graphs">List Graphs</h3>
<p>The second implementation of graphs were list graphs. For this implementation, we had a single array of graph node objects where the graph node objects tracked their own edges.</p>
<p>Recall that we discussed sparse and dense graphs. Matrix graphs are better for dense graphs since a majority of the elements in the two dimensional array of edges will be filled. A great example of a dense graph would be relationships in a small community, where each person is connected to each other person in some way.</p>
<p>List graphs are better for sparse graphs, since each node only needs to store the outgoing edges it is connected to. This eliminates a large amount of the overhead that would be present in a matrix graph if there were thousands of nodes and each node was only connected to a few other nodes. A great example of a sparse graph would be a larger social network such as Facebook. Facebook has over a billion users, but each user has on average only a few hundred connections. So, it is much easier to store a list of those few hundred connections instead of a two dimensional matrix that has over one quintillion ($10^{18}$) elements.</p>
<p>In the next chapter, we will discuss the specific implications of using one or the other. However, in our requirement analysis it is important to take this into consideration. If we have relational data where many elements are considered to be connected to many other elements, then a matrix graph will be preferred. If the elements of our data set are infrequently connected, then a list graph is the better choice.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="priority-queues">Priority Queues</h1>

<p>The last structure we covered were priority queues. On their own, these are good for hierarchical data. We discussed using priority queues for ticketing systems where the priority is the cost or urgency. In the project, we utilized priority queues in conjunction with Dijkstra&rsquo;s algorithm.</p>
<h2 id="priority-queues">Priority Queues</h2>
<p>A priority queue is a data structure which contains elements and each element has an associated priority value. The priority for an element corresponds to its importance. For this course, we implemented priority queues using heaps.</p>
<p>A key point of priority queues is that the priority for a value can change. This is reflected by nodes moving up (via push up) or down (via push down) through the priority queue.</p>
<p>In contrast, a tree has a generally fixed order. Consider the file tree as a conceptual example, it is not practical for a parent folder to switch places with a child folder.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="examples">Examples</h1>


<a href="https://www.youtube.com/watch?v=eCa3TreKdqU">YouTube Video</a>

<p>In real world applications, it won&rsquo;t always be a straightforward choice to use one structure over another. Users may come to us with unclear ideas of what they are looking for and we will need to be able to infer what structure is best suited for their needs based on what we can learn from them. Typically, those describing applications to us may not be familiar with the nomenclature we use as programmers. Instead, we have to look for clues about how the data is structured and used to help us choose the most appropriate data structures</p>
<p>Below we have some examples with possible solutions. We say possible solutions because there may be other ways that we could implement things. It is important that no matter what structure or algorithm we use, we should always document why we chose our answer. If someone else were to join on the project at a later time, it is important that they understand our reasoning.</p>
<h2 id="costume-shop">Costume Shop</h2>
<p>A manager at a costume shop has requested that we do some data management for their online catalog. They say:</p>
<ul>
<li>Users should be able to refine their search first based on who the costumes are for (adults, children, dogs), then on the part of the costume (tops, bottoms, shoes, props) and then display those options for the user.</li>
<li>I would like if we could recommend costumes to customers based on their searches.</li>
</ul>
<p>Take a moment to think on how you might go about this. Remember, there can be multiple ways of solving these problems. We need to be sure that we can articulate and justify our answers.</p>
<p>This is a situation where we could potentially use all three data structures!</p>
<p>First, we could use a tree to represent the search refinement. Thinking along the lines of a data structure, each category and subsequently each product will have exactly one parent. While something like &lsquo;wigs&rsquo; shows up in all three categories, you wouldn&rsquo;t want dog wigs showing up in a search for adult wigs. Thus, there is a unique ancestry for each category and product.</p>
<p><a href="#R-image-06ccd5c15e3f5778f2e693d9cf82a67a" class="lightbox-link"><img alt="Tree for Search" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/11/11_costume_trie.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-06ccd5c15e3f5778f2e693d9cf82a67a"><img alt="Tree for Search" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/11/11_costume_trie.svg"></a></p>
<p>In this scenario we had a fixed ordering of our hierarchy. If the manager wanted users to be able to sort by costume part and then who it was for, our tree would not hold up.</p>
<p>The second portion that was requested was a recommendation system. We could implement this in two parts. The first would be a graph in which the nodes are the products and they are connected based on the similarity of the products.</p>
<p>For example, a purple childrens wig will be very similar to a childrens blue wig but it would be very different from an adults clown shoes. Thus, our graph would have a heavily weighted connection between the childrens purple and blue wig and there would be an edge with a very small weight between the purple wig and adult clown shoes. We can obtain this information from the manager. Since each product will be connected to every other product, a matrix graph would be best suited here.</p>
<p>Then once we have the graph, we could implement a priority queue. The priority queue would be built based off of the users search. When a user searches for a product, we would refer to our graph and get other similar products and enqueue them. The priority would be similarity to the searched products and the item would be the recommended product. As they continue to search, we would dequeue an element if the user selects it and we would change the priority of elements based on commonalities in the searches.</p>
<h2 id="video-game">Video Game</h2>
<p>A friend approaches you about their idea for a video game and ask how they could use different data structures to produce the game. They tell us about their game which is a sandbox game with no defined goals. Users can do tasks at their own chosen speed and there is no real &ldquo;completion&rdquo; of the game. They say:</p>
<ul>
<li>I want users to be able to see the tasks that are available to them and what the payout of the task is. It would be really awesome if we could display around 4 tasks that would earn them the most points.</li>
<li>I have a set of &ldquo;shortcuts&rdquo; that users can use to streamline basic functions like switching tools. It would make sense that all of the shortcuts for switching tools start with the same button clicks. So switching to a shovel would be similar to switching to a hammer.</li>
<li>I have this world in mind that is a lot like our world in terms of terrain and what not. I want players to be able to dig in the dirt and then move that dirt as they like! They could build dirt piles or houses from the trees.</li>
</ul>
<p>Take a moment to think on how you might go about this. Remember, there can be multiple ways of solving these problems. We need to be sure that we can articulate and justify our answers.</p>
<p>Again, this is a situation where we could potentially use three data structures!</p>
<p>We can use a priority queue to suggest tasks for the players to do. In this priority queue, the priority would be the payout and the item would be the task itself. As tasks get completed, we would dequeue them.</p>
<p>We can use a trie to represent the set of shortcuts. Below is a small sample of how we can implement our trie.</p>
<p><a href="#R-image-f8dada84c4e24fcbeb05475c25149fe3" class="lightbox-link"><img alt="Trie for Shortcuts" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/11/11_videogame_trie.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f8dada84c4e24fcbeb05475c25149fe3"><img alt="Trie for Shortcuts" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/11/11_videogame_trie.svg"></a></p>
<p>Since our friend mentioned that similar tasks should have similar combinations, a trie will fit well. These key combinations will have similar prefixes, so we can save ourselves space to store them by using a trie.</p>
<p>Finally, for the world layout we could use a graph. Similar to the maze project or weather station project, we can have nodes represent points on a plot and the edges will represent connections. The nodes will now have three coordinates, (x,y,z), rather than two, (x,y) or (latitude, longitude) and they will have an associated type (dirt, tree, rock, etc.).
<a href="#R-image-1bdec28b07992a8eaf0ab45357d85aa3" class="lightbox-link"><img alt="Graph for world blocks" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/11/11_videogame_graph.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1bdec28b07992a8eaf0ab45357d85aa3"><img alt="Graph for world blocks" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/11/11_videogame_graph.svg"></a></p>
<p>Two nodes will be connected if they directly adjacent. Players can harvest cubes such as soil or limestone, and it would be removed from the world. We would utilize our remove node function to reflect this kind of action. Similarly, players can build up the world in spaces that allow, such as the dirt pile in an open area, and for that we can use our add node function as well as the appropriate add edge functions.</p>
<p>In our implementation of a graph, it would be better to use a list graph. Each block will be connected to at most six other blocks.
<a href="#R-image-ff5f7e6e8ceab1e0606f956b827dbb10" class="lightbox-link"><img alt="Cubes neighbors" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc315/images/11/11_videogame_cubes.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff5f7e6e8ceab1e0606f956b827dbb10"><img alt="Cubes neighbors" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc315/images/11/11_videogame_cubes.svg"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="z-instructor-resources">Z-Instructor-Resources</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Z-Instructor-Resources</h1>
    
    
          </section>
          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Emily Alfs-Votipka
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc315/commit/c74b757cc722685c09b3a25f512ff7876161025d">Aug 8, 2022</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc315/js/clipboard.min.js?1719522770" defer></script>
    <script src="/cc315/js/perfect-scrollbar.min.js?1719522770" defer></script>
    <script src="/cc315/js/theme.js?1719522770" defer></script>
  </body>
</html>
